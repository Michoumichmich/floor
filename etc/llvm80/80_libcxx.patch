diff --git a/include/__bit_reference b/include/__bit_reference
index c208af2b4..78f1cfe10 100644
--- a/include/__bit_reference
+++ b/include/__bit_reference
@@ -333,7 +333,7 @@ __fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
     }
     // do middle whole words
     __storage_type __nw = __n / __bits_per_word;
-    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
+    __builtin_memset(_VSTD::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
     __n -= __nw * __bits_per_word;
     // do last partial word
     if (__n > 0)
@@ -363,7 +363,7 @@ __fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
     }
     // do middle whole words
     __storage_type __nw = __n / __bits_per_word;
-    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
+    __builtin_memset(_VSTD::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
     __n -= __nw * __bits_per_word;
     // do last partial word
     if (__n > 0)
@@ -430,7 +430,7 @@ __copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsCon
         // __first.__ctz_ == 0;
         // do middle words
         __storage_type __nw = __n / __bits_per_word;
-        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),
+        __builtin_memmove(_VSTD::__to_raw_pointer(__result.__seg_),
                        _VSTD::__to_raw_pointer(__first.__seg_),
                        __nw * sizeof(__storage_type));
         __n -= __nw * __bits_per_word;
@@ -571,7 +571,7 @@ __copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_C
         __storage_type __nw = __n / __bits_per_word;
         __result.__seg_ -= __nw;
         __last.__seg_ -= __nw;
-        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),
+        __builtin_memmove(_VSTD::__to_raw_pointer(__result.__seg_),
                        _VSTD::__to_raw_pointer(__last.__seg_),
                        __nw * sizeof(__storage_type));
         __n -= __nw * __bits_per_word;
diff --git a/include/__config b/include/__config
index b5e7b7632..d81621638 100644
--- a/include/__config
+++ b/include/__config
@@ -59,6 +59,8 @@
 #  define _LIBCPP_OBJECT_FORMAT_COFF  1
 #elif defined(__wasm__)
 #  define _LIBCPP_OBJECT_FORMAT_WASM  1
+#elif defined(FLOOR_COMPUTE)
+#  define _LIBCPP_OBJECT_FORMAT_FLOOR 1
 #else
 #  error Unknown object file format
 #endif
@@ -1204,8 +1206,6 @@ _LIBCPP_FUNC_VIS extern "C" void __sanitizer_annotate_contiguous_container(
 
 #if __has_feature(cxx_atomic) || __has_extension(c_atomic) || __has_keyword(_Atomic)
 #  define _LIBCPP_HAS_C_ATOMIC_IMP
-#elif _GNUC_VER > 407
-#  define _LIBCPP_HAS_GCC_ATOMIC_IMP
 #endif
 
 #if (!defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)) \
diff --git a/include/__debug b/include/__debug
index a8788f68f..30bc95882 100644
--- a/include/__debug
+++ b/include/__debug
@@ -74,7 +74,7 @@ typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);
 
 /// __libcpp_debug_function - The handler function called when a _LIBCPP_ASSERT
 ///    fails.
-extern _LIBCPP_EXPORTED_FROM_ABI __libcpp_debug_function_type __libcpp_debug_function;
+//extern _LIBCPP_EXPORTED_FROM_ABI __libcpp_debug_function_type __libcpp_debug_function;
 
 /// __libcpp_abort_debug_function - A debug handler that aborts when called.
 _LIBCPP_NORETURN _LIBCPP_FUNC_VIS
diff --git a/include/__functional_base b/include/__functional_base
index 032be99bf..8f3770b90 100644
--- a/include/__functional_base
+++ b/include/__functional_base
@@ -13,9 +13,11 @@
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
 #include <exception>
 #include <new>
+#endif
 #include <utility>
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
diff --git a/include/algorithm b/include/algorithm
index 9f425cf99..6f4c824f4 100644
--- a/include/algorithm
+++ b/include/algorithm
@@ -639,7 +639,9 @@ template <class BidirectionalIterator, class Compare>
 #include <__config>
 #include <initializer_list>
 #include <type_traits>
+#if 0
 #include <cstring>
+#endif
 #include <utility> // needed to provide swap_ranges.
 #include <memory>
 #include <functional>
@@ -1623,7 +1625,7 @@ __copy(_Tp* __first, _Tp* __last, _Up* __result)
 {
     const size_t __n = static_cast<size_t>(__last - __first);
     if (__n > 0)
-        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+        __builtin_memmove(__result, __first, __n * sizeof(_Up));
     return __result + __n;
 }
 
@@ -1661,7 +1663,7 @@ __copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
     if (__n > 0)
     {
         __result -= __n;
-        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+        __builtin_memmove(__result, __first, __n * sizeof(_Up));
     }
     return __result;
 }
@@ -1762,7 +1764,7 @@ __move(_Tp* __first, _Tp* __last, _Up* __result)
 {
     const size_t __n = static_cast<size_t>(__last - __first);
     if (__n > 0)
-        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+        __builtin_memmove(__result, __first, __n * sizeof(_Up));
     return __result + __n;
 }
 
@@ -1800,7 +1802,7 @@ __move_backward(_Tp* __first, _Tp* __last, _Up* __result)
     if (__n > 0)
     {
         __result -= __n;
-        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+        __builtin_memmove(__result, __first, __n * sizeof(_Up));
     }
     return __result;
 }
@@ -2922,6 +2924,7 @@ _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
     return static_cast<result_type>(__u + __p.a());
 }
 
+#if 0 // this is not supported
 #if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE) \
   || defined(_LIBCPP_BUILDING_LIBRARY)
 class _LIBCPP_TYPE_VIS __rs_default;
@@ -2930,7 +2933,7 @@ _LIBCPP_FUNC_VIS __rs_default __rs_get();
 
 class _LIBCPP_TYPE_VIS __rs_default
 {
-    static unsigned __c_;
+    static constant unsigned __c_ { 0u };
 
     __rs_default();
 public:
@@ -2972,6 +2975,7 @@ random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
         }
     }
 }
+#endif
 
 template <class _RandomAccessIterator, class _RandomNumberGenerator>
 _LIBCPP_DEPRECATED_IN_CXX14 void
@@ -3304,6 +3308,7 @@ __second_half_done:
     //         |
 }
 
+#if 0
 struct __return_temporary_buffer
 {
     template <class _Tp>
@@ -3340,6 +3345,7 @@ __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate
     return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                              (__first, __last, __pred, __len, __p, forward_iterator_tag());
 }
+#endif
 
 template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
 _BidirectionalIterator
@@ -3449,6 +3455,7 @@ __second_half_done:
     //         |
 }
 
+#if 0
 template <class _Predicate, class _BidirectionalIterator>
 _BidirectionalIterator
 __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
@@ -3488,6 +3495,7 @@ __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last
     return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                              (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
 }
+#endif
 
 template <class _ForwardIterator, class _Predicate>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -3793,9 +3801,9 @@ __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __c
     typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
     const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                     is_trivially_copy_assignable<value_type>::value ? 30 : 6;
-    while (true)
-    {
-    __restart:
+
+    // compute note: keep the special cases if len <= 5, but always fallback to using
+    //               __insertion_sort_3 for len > 5 as it doesn't require recursion
         difference_type __len = __last - __first;
         switch (__len)
         {
@@ -3816,165 +3824,7 @@ __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __c
             _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
             return;
         }
-        if (__len <= __limit)
-        {
             _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);
-            return;
-        }
-        // __len > 5
-        _RandomAccessIterator __m = __first;
-        _RandomAccessIterator __lm1 = __last;
-        --__lm1;
-        unsigned __n_swaps;
-        {
-        difference_type __delta;
-        if (__len >= 1000)
-        {
-            __delta = __len/2;
-            __m += __delta;
-            __delta /= 2;
-            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
-        }
-        else
-        {
-            __delta = __len/2;
-            __m += __delta;
-            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);
-        }
-        }
-        // *__m is median
-        // partition [__first, __m) < *__m and *__m <= [__m, __last)
-        // (this inhibits tossing elements equivalent to __m around unnecessarily)
-        _RandomAccessIterator __i = __first;
-        _RandomAccessIterator __j = __lm1;
-        // j points beyond range to be tested, *__m is known to be <= *__lm1
-        // The search going up is known to be guarded but the search coming down isn't.
-        // Prime the downward search with a guard.
-        if (!__comp(*__i, *__m))  // if *__first == *__m
-        {
-            // *__first == *__m, *__first doesn't go in first part
-            // manually guard downward moving __j against __i
-            while (true)
-            {
-                if (__i == --__j)
-                {
-                    // *__first == *__m, *__m <= all other elements
-                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)
-                    ++__i;  // __first + 1
-                    __j = __last;
-                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)
-                    {
-                        while (true)
-                        {
-                            if (__i == __j)
-                                return;  // [__first, __last) all equivalent elements
-                            if (__comp(*__first, *__i))
-                            {
-                                swap(*__i, *__j);
-                                ++__n_swaps;
-                                ++__i;
-                                break;
-                            }
-                            ++__i;
-                        }
-                    }
-                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
-                    if (__i == __j)
-                        return;
-                    while (true)
-                    {
-                        while (!__comp(*__first, *__i))
-                            ++__i;
-                        while (__comp(*__first, *--__j))
-                            ;
-                        if (__i >= __j)
-                            break;
-                        swap(*__i, *__j);
-                        ++__n_swaps;
-                        ++__i;
-                    }
-                    // [__first, __i) == *__first and *__first < [__i, __last)
-                    // The first part is sorted, sort the secod part
-                    // _VSTD::__sort<_Compare>(__i, __last, __comp);
-                    __first = __i;
-                    goto __restart;
-                }
-                if (__comp(*__j, *__m))
-                {
-                    swap(*__i, *__j);
-                    ++__n_swaps;
-                    break;  // found guard for downward moving __j, now use unguarded partition
-                }
-            }
-        }
-        // It is known that *__i < *__m
-        ++__i;
-        // j points beyond range to be tested, *__m is known to be <= *__lm1
-        // if not yet partitioned...
-        if (__i < __j)
-        {
-            // known that *(__i - 1) < *__m
-            // known that __i <= __m
-            while (true)
-            {
-                // __m still guards upward moving __i
-                while (__comp(*__i, *__m))
-                    ++__i;
-                // It is now known that a guard exists for downward moving __j
-                while (!__comp(*--__j, *__m))
-                    ;
-                if (__i > __j)
-                    break;
-                swap(*__i, *__j);
-                ++__n_swaps;
-                // It is known that __m != __j
-                // If __m just moved, follow it
-                if (__m == __i)
-                    __m = __j;
-                ++__i;
-            }
-        }
-        // [__first, __i) < *__m and *__m <= [__i, __last)
-        if (__i != __m && __comp(*__m, *__i))
-        {
-            swap(*__i, *__m);
-            ++__n_swaps;
-        }
-        // [__first, __i) < *__i and *__i <= [__i+1, __last)
-        // If we were given a perfect partition, see if insertion sort is quick...
-        if (__n_swaps == 0)
-        {
-            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
-            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
-            {
-                if (__fs)
-                    return;
-                __last = __i;
-                continue;
-            }
-            else
-            {
-                if (__fs)
-                {
-                    __first = ++__i;
-                    continue;
-                }
-            }
-        }
-        // sort smaller range with recursive call and larger with tail recursion elimination
-        if (__i - __first < __last - __i)
-        {
-            _VSTD::__sort<_Compare>(__first, __i, __comp);
-            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);
-            __first = ++__i;
-        }
-        else
-        {
-            _VSTD::__sort<_Compare>(__i+1, __last, __comp);
-            // _VSTD::__sort<_Compare>(__first, __i, __comp);
-            __last = __i;
-        }
-    }
 }
 
 // This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare
@@ -4026,6 +3876,7 @@ sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
     _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
 }
 
+#if 0
 _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))
 _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))
 _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))
@@ -4059,6 +3910,7 @@ _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less
 _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))
 
 _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))
+#endif
 
 // lower_bound
 
@@ -4439,6 +4291,7 @@ __inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle,
     }
 }
 
+#if 0
 template <class _BidirectionalIterator, class _Compare>
 inline _LIBCPP_INLINE_VISIBILITY
 void
@@ -4464,6 +4317,7 @@ inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _
                                             __buf.first, __buf.second);
 #endif  // _LIBCPP_DEBUG
 }
+#endif
 
 template <class _BidirectionalIterator>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -4649,6 +4503,7 @@ __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp
     __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
 }
 
+#if 0
 template <class _RandomAccessIterator, class _Compare>
 inline _LIBCPP_INLINE_VISIBILITY
 void
@@ -4673,6 +4528,7 @@ stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compar
     __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
 #endif  // _LIBCPP_DEBUG
 }
+#endif
 
 template <class _RandomAccessIterator>
 inline _LIBCPP_INLINE_VISIBILITY
diff --git a/include/array b/include/array
index 8f4e111ac..e53178e13 100644
--- a/include/array
+++ b/include/array
@@ -111,7 +111,9 @@ template <size_t I, class T, size_t N> const T&& get(const array<T, N>&&) noexce
 #include <iterator>
 #include <algorithm>
 #include <stdexcept>
+#if 0
 #include <cstdlib> // for _LIBCPP_UNREACHABLE
+#endif
 #include <version>
 #include <__debug>
 
@@ -306,49 +308,49 @@ struct _LIBCPP_TEMPLATE_VIS array<_Tp, 0>
     _LIBCPP_INLINE_VISIBILITY
     reference operator[](size_type) {
       _LIBCPP_ASSERT(false, "cannot call array<T, 0>::operator[] on a zero-sized array");
-      _LIBCPP_UNREACHABLE();
+      __builtin_unreachable();
     }
 
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
     const_reference operator[](size_type) const {
       _LIBCPP_ASSERT(false, "cannot call array<T, 0>::operator[] on a zero-sized array");
-      _LIBCPP_UNREACHABLE();
+      __builtin_unreachable();
     }
 
     _LIBCPP_INLINE_VISIBILITY
     reference at(size_type) {
       __throw_out_of_range("array<T, 0>::at");
-      _LIBCPP_UNREACHABLE();
+      __builtin_unreachable();
     }
 
     _LIBCPP_INLINE_VISIBILITY
     const_reference at(size_type) const {
       __throw_out_of_range("array<T, 0>::at");
-      _LIBCPP_UNREACHABLE();
+      __builtin_unreachable();
     }
 
     _LIBCPP_INLINE_VISIBILITY
     reference front() {
       _LIBCPP_ASSERT(false, "cannot call array<T, 0>::front() on a zero-sized array");
-      _LIBCPP_UNREACHABLE();
+      __builtin_unreachable();
     }
 
     _LIBCPP_INLINE_VISIBILITY
     const_reference front() const {
       _LIBCPP_ASSERT(false, "cannot call array<T, 0>::front() on a zero-sized array");
-      _LIBCPP_UNREACHABLE();
+      __builtin_unreachable();
     }
 
     _LIBCPP_INLINE_VISIBILITY
     reference back() {
       _LIBCPP_ASSERT(false, "cannot call array<T, 0>::back() on a zero-sized array");
-      _LIBCPP_UNREACHABLE();
+      __builtin_unreachable();
     }
 
     _LIBCPP_INLINE_VISIBILITY
     const_reference back() const {
       _LIBCPP_ASSERT(false, "cannot call array<T, 0>::back() on a zero-sized array");
-      _LIBCPP_UNREACHABLE();
+      __builtin_unreachable();
     }
 
     _LIBCPP_INLINE_VISIBILITY
diff --git a/include/atomic b/include/atomic
index d37e7b4b0..f36b79066 100644
--- a/include/atomic
+++ b/include/atomic
@@ -542,7 +542,9 @@ void atomic_signal_fence(memory_order m) noexcept;
 
 #include <__config>
 #include <cstddef>
+#if 0
 #include <cstdint>
+#endif
 #include <type_traits>
 #include <version>
 
@@ -550,10 +552,12 @@ void atomic_signal_fence(memory_order m) noexcept;
 #pragma GCC system_header
 #endif
 
+#if 0
 #ifdef _LIBCPP_HAS_NO_THREADS
 #error <atomic> is not supported on this single threaded system
 #endif
-#if !defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
+#endif
+#if !defined(_LIBCPP_HAS_C_ATOMIC_IMP)
 #error <atomic> is not implemented
 #endif
 #ifdef kill_dependency
@@ -578,280 +582,7 @@ void atomic_signal_fence(memory_order m) noexcept;
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
-typedef enum memory_order
-{
-    memory_order_relaxed, memory_order_consume, memory_order_acquire,
-    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
-} memory_order;
-
-#if defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
-namespace __gcc_atomic {
-template <typename _Tp>
-struct __gcc_atomic_t {
-
-#if _GNUC_VER >= 501
-    static_assert(is_trivially_copyable<_Tp>::value,
-      "std::atomic<Tp> requires that 'Tp' be a trivially copyable type");
-#endif
-
-  _LIBCPP_INLINE_VISIBILITY
-#ifndef _LIBCPP_CXX03_LANG
-    __gcc_atomic_t() _NOEXCEPT = default;
-#else
-    __gcc_atomic_t() _NOEXCEPT : __a_value() {}
-#endif // _LIBCPP_CXX03_LANG
-  _LIBCPP_CONSTEXPR explicit __gcc_atomic_t(_Tp value) _NOEXCEPT
-    : __a_value(value) {}
-  _Tp __a_value;
-};
-#define _Atomic(x) __gcc_atomic::__gcc_atomic_t<x>
-
-template <typename _Tp> _Tp __create();
-
-template <typename _Tp, typename _Td>
-typename enable_if<sizeof(_Tp()->__a_value = __create<_Td>()), char>::type
-    __test_atomic_assignable(int);
-template <typename _Tp, typename _Up>
-__two __test_atomic_assignable(...);
-
-template <typename _Tp, typename _Td>
-struct __can_assign {
-  static const bool value =
-      sizeof(__test_atomic_assignable<_Tp, _Td>(1)) == sizeof(char);
-};
-
-static inline _LIBCPP_CONSTEXPR int __to_gcc_order(memory_order __order) {
-  // Avoid switch statement to make this a constexpr.
-  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:
-         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:
-          (__order == memory_order_release ? __ATOMIC_RELEASE:
-           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:
-            (__order == memory_order_acq_rel ? __ATOMIC_ACQ_REL:
-              __ATOMIC_CONSUME))));
-}
-
-static inline _LIBCPP_CONSTEXPR int __to_gcc_failure_order(memory_order __order) {
-  // Avoid switch statement to make this a constexpr.
-  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:
-         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:
-          (__order == memory_order_release ? __ATOMIC_RELAXED:
-           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:
-            (__order == memory_order_acq_rel ? __ATOMIC_ACQUIRE:
-              __ATOMIC_CONSUME))));
-}
-
-} // namespace __gcc_atomic
-
-template <typename _Tp>
-static inline
-typename enable_if<
-    __gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value>::type
-__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {
-  __a->__a_value = __val;
-}
-
-template <typename _Tp>
-static inline
-typename enable_if<
-    !__gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value &&
-     __gcc_atomic::__can_assign<         _Atomic(_Tp)*, _Tp>::value>::type
-__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {
-  // [atomics.types.generic]p1 guarantees _Tp is trivially copyable. Because
-  // the default operator= in an object is not volatile, a byte-by-byte copy
-  // is required.
-  volatile char* to = reinterpret_cast<volatile char*>(&__a->__a_value);
-  volatile char* end = to + sizeof(_Tp);
-  char* from = reinterpret_cast<char*>(&__val);
-  while (to != end) {
-    *to++ = *from++;
-  }
-}
-
-template <typename _Tp>
-static inline void __c11_atomic_init(_Atomic(_Tp)* __a,  _Tp __val) {
-  __a->__a_value = __val;
-}
-
-static inline void __c11_atomic_thread_fence(memory_order __order) {
-  __atomic_thread_fence(__gcc_atomic::__to_gcc_order(__order));
-}
-
-static inline void __c11_atomic_signal_fence(memory_order __order) {
-  __atomic_signal_fence(__gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline void __c11_atomic_store(volatile _Atomic(_Tp)* __a,  _Tp __val,
-                                      memory_order __order) {
-  return __atomic_store(&__a->__a_value, &__val,
-                        __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline void __c11_atomic_store(_Atomic(_Tp)* __a,  _Tp __val,
-                                      memory_order __order) {
-  __atomic_store(&__a->__a_value, &__val,
-                 __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_load(const volatile _Atomic(_Tp)* __a,
-                                    memory_order __order) {
-  _Tp __ret;
-  __atomic_load(&__a->__a_value, &__ret,
-                __gcc_atomic::__to_gcc_order(__order));
-  return __ret;
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_load(const _Atomic(_Tp)* __a, memory_order __order) {
-  _Tp __ret;
-  __atomic_load(&__a->__a_value, &__ret,
-                __gcc_atomic::__to_gcc_order(__order));
-  return __ret;
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_exchange(volatile _Atomic(_Tp)* __a,
-                                        _Tp __value, memory_order __order) {
-  _Tp __ret;
-  __atomic_exchange(&__a->__a_value, &__value, &__ret,
-                    __gcc_atomic::__to_gcc_order(__order));
-  return __ret;
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_exchange(_Atomic(_Tp)* __a, _Tp __value,
-                                        memory_order __order) {
-  _Tp __ret;
-  __atomic_exchange(&__a->__a_value, &__value, &__ret,
-                    __gcc_atomic::__to_gcc_order(__order));
-  return __ret;
-}
-
-template <typename _Tp>
-static inline bool __c11_atomic_compare_exchange_strong(
-    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,
-    memory_order __success, memory_order __failure) {
-  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
-                                   false,
-                                   __gcc_atomic::__to_gcc_order(__success),
-                                   __gcc_atomic::__to_gcc_failure_order(__failure));
-}
-
-template <typename _Tp>
-static inline bool __c11_atomic_compare_exchange_strong(
-    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,
-    memory_order __failure) {
-  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
-                                   false,
-                                   __gcc_atomic::__to_gcc_order(__success),
-                                   __gcc_atomic::__to_gcc_failure_order(__failure));
-}
-
-template <typename _Tp>
-static inline bool __c11_atomic_compare_exchange_weak(
-    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,
-    memory_order __success, memory_order __failure) {
-  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
-                                   true,
-                                   __gcc_atomic::__to_gcc_order(__success),
-                                   __gcc_atomic::__to_gcc_failure_order(__failure));
-}
-
-template <typename _Tp>
-static inline bool __c11_atomic_compare_exchange_weak(
-    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,
-    memory_order __failure) {
-  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
-                                   true,
-                                   __gcc_atomic::__to_gcc_order(__success),
-                                   __gcc_atomic::__to_gcc_failure_order(__failure));
-}
-
-template <typename _Tp>
-struct __skip_amt { enum {value = 1}; };
-
-template <typename _Tp>
-struct __skip_amt<_Tp*> { enum {value = sizeof(_Tp)}; };
-
-// FIXME: Haven't figured out what the spec says about using arrays with
-// atomic_fetch_add. Force a failure rather than creating bad behavior.
-template <typename _Tp>
-struct __skip_amt<_Tp[]> { };
-template <typename _Tp, int n>
-struct __skip_amt<_Tp[n]> { };
-
-template <typename _Tp, typename _Td>
-static inline _Tp __c11_atomic_fetch_add(volatile _Atomic(_Tp)* __a,
-                                         _Td __delta, memory_order __order) {
-  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp, typename _Td>
-static inline _Tp __c11_atomic_fetch_add(_Atomic(_Tp)* __a, _Td __delta,
-                                         memory_order __order) {
-  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp, typename _Td>
-static inline _Tp __c11_atomic_fetch_sub(volatile _Atomic(_Tp)* __a,
-                                         _Td __delta, memory_order __order) {
-  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp, typename _Td>
-static inline _Tp __c11_atomic_fetch_sub(_Atomic(_Tp)* __a, _Td __delta,
-                                         memory_order __order) {
-  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_and(volatile _Atomic(_Tp)* __a,
-                                         _Tp __pattern, memory_order __order) {
-  return __atomic_fetch_and(&__a->__a_value, __pattern,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_and(_Atomic(_Tp)* __a,
-                                         _Tp __pattern, memory_order __order) {
-  return __atomic_fetch_and(&__a->__a_value, __pattern,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_or(volatile _Atomic(_Tp)* __a,
-                                        _Tp __pattern, memory_order __order) {
-  return __atomic_fetch_or(&__a->__a_value, __pattern,
-                           __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_or(_Atomic(_Tp)* __a, _Tp __pattern,
-                                        memory_order __order) {
-  return __atomic_fetch_or(&__a->__a_value, __pattern,
-                           __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_xor(volatile _Atomic(_Tp)* __a,
-                                         _Tp __pattern, memory_order __order) {
-  return __atomic_fetch_xor(&__a->__a_value, __pattern,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_xor(_Atomic(_Tp)* __a, _Tp __pattern,
-                                         memory_order __order) {
-  return __atomic_fetch_xor(&__a->__a_value, __pattern,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-#endif // _LIBCPP_HAS_GCC_ATOMIC_IMP
+// NOTE: memory_order defined externally
 
 template <class _Tp>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -861,36 +592,25 @@ kill_dependency(_Tp __y) _NOEXCEPT
     return __y;
 }
 
-#if defined(__CLANG_ATOMIC_BOOL_LOCK_FREE)
-# define ATOMIC_BOOL_LOCK_FREE      __CLANG_ATOMIC_BOOL_LOCK_FREE
-# define ATOMIC_CHAR_LOCK_FREE      __CLANG_ATOMIC_CHAR_LOCK_FREE
-# define ATOMIC_CHAR16_T_LOCK_FREE  __CLANG_ATOMIC_CHAR16_T_LOCK_FREE
-# define ATOMIC_CHAR32_T_LOCK_FREE  __CLANG_ATOMIC_CHAR32_T_LOCK_FREE
-# define ATOMIC_WCHAR_T_LOCK_FREE   __CLANG_ATOMIC_WCHAR_T_LOCK_FREE
-# define ATOMIC_SHORT_LOCK_FREE     __CLANG_ATOMIC_SHORT_LOCK_FREE
-# define ATOMIC_INT_LOCK_FREE       __CLANG_ATOMIC_INT_LOCK_FREE
-# define ATOMIC_LONG_LOCK_FREE      __CLANG_ATOMIC_LONG_LOCK_FREE
-# define ATOMIC_LLONG_LOCK_FREE     __CLANG_ATOMIC_LLONG_LOCK_FREE
-# define ATOMIC_POINTER_LOCK_FREE   __CLANG_ATOMIC_POINTER_LOCK_FREE
-#else
-# define ATOMIC_BOOL_LOCK_FREE      __GCC_ATOMIC_BOOL_LOCK_FREE
-# define ATOMIC_CHAR_LOCK_FREE      __GCC_ATOMIC_CHAR_LOCK_FREE
-# define ATOMIC_CHAR16_T_LOCK_FREE  __GCC_ATOMIC_CHAR16_T_LOCK_FREE
-# define ATOMIC_CHAR32_T_LOCK_FREE  __GCC_ATOMIC_CHAR32_T_LOCK_FREE
-# define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE
-# define ATOMIC_SHORT_LOCK_FREE     __GCC_ATOMIC_SHORT_LOCK_FREE
-# define ATOMIC_INT_LOCK_FREE       __GCC_ATOMIC_INT_LOCK_FREE
-# define ATOMIC_LONG_LOCK_FREE      __GCC_ATOMIC_LONG_LOCK_FREE
-# define ATOMIC_LLONG_LOCK_FREE     __GCC_ATOMIC_LLONG_LOCK_FREE
-# define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE
-#endif
+# define ATOMIC_BOOL_LOCK_FREE      false
+# define ATOMIC_CHAR_LOCK_FREE      false
+# define ATOMIC_CHAR16_T_LOCK_FREE  false
+# define ATOMIC_CHAR32_T_LOCK_FREE  true
+# define ATOMIC_WCHAR_T_LOCK_FREE   false
+# define ATOMIC_SHORT_LOCK_FREE     false
+# define ATOMIC_INT_LOCK_FREE       true
+# define ATOMIC_LONG_LOCK_FREE      FLOOR_ATOMIC_LONG_LOCK_FREE
+# define ATOMIC_LLONG_LOCK_FREE     FLOOR_ATOMIC_LLONG_LOCK_FREE
+# define ATOMIC_POINTER_LOCK_FREE   FLOOR_ATOMIC_POINTER_LOCK_FREE
 
 // general atomic<T>
 
-template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
+template <class _Tp, class _TpAS = global _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
 struct __atomic_base  // false
 {
-    mutable _Atomic(_Tp) __a_;
+    typedef _TpAS* _ptr_type;
+    
+    mutable _Tp __a_;
 
 #if defined(__cpp_lib_atomic_is_always_lock_free)
   static _LIBCPP_CONSTEXPR bool is_always_lock_free = __atomic_always_lock_free(sizeof(__a_), 0);
@@ -898,164 +618,149 @@ struct __atomic_base  // false
 
     _LIBCPP_INLINE_VISIBILITY
     bool is_lock_free() const volatile _NOEXCEPT
-    {
-#if defined(_LIBCPP_HAS_C_ATOMIC_IMP)
-    return __c11_atomic_is_lock_free(sizeof(_Tp));
-#else
-    return __atomic_is_lock_free(sizeof(_Tp), 0);
-#endif
-    }
+        {return floor_atomic_is_lock_free(sizeof(_Tp));}
     _LIBCPP_INLINE_VISIBILITY
     bool is_lock_free() const _NOEXCEPT
-        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
+        {return floor_atomic_is_lock_free(sizeof(_Tp));}
     _LIBCPP_INLINE_VISIBILITY
-    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-      _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
-        {__c11_atomic_store(&__a_, __d, __m);}
+    void store(_Tp __d, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+      //_LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
+        {floor_atomic_store(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    void store(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-      _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
-        {__c11_atomic_store(&__a_, __d, __m);}
+    void store(_Tp __d, memory_order __m = memory_order_relaxed) _NOEXCEPT
+      //_LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
+        {floor_atomic_store(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp load(memory_order __m = memory_order_seq_cst) const volatile _NOEXCEPT
-      _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
-        {return __c11_atomic_load(&__a_, __m);}
+    _Tp load(memory_order __m = memory_order_relaxed) const volatile _NOEXCEPT
+      //_LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
+        {return floor_atomic_load(reinterpret_cast<_ptr_type>(&__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp load(memory_order __m = memory_order_seq_cst) const _NOEXCEPT
-      _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
-        {return __c11_atomic_load(&__a_, __m);}
+    _Tp load(memory_order __m = memory_order_relaxed) const _NOEXCEPT
+      //_LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
+        {return floor_atomic_load(reinterpret_cast<_ptr_type>(&__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
     operator _Tp() const volatile _NOEXCEPT {return load();}
     _LIBCPP_INLINE_VISIBILITY
     operator _Tp() const _NOEXCEPT          {return load();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, __d, __m);}
+    _Tp exchange(_Tp __d, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_exchange(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, __d, __m);}
+    _Tp exchange(_Tp __d, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_exchange(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
                                memory_order __s, memory_order __f) volatile _NOEXCEPT
-      _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
+      //_LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
                                memory_order __s, memory_order __f) _NOEXCEPT
-      _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
+      //_LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                  memory_order __s, memory_order __f) volatile _NOEXCEPT
-      _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
+      //_LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                  memory_order __s, memory_order __f) _NOEXCEPT
-      _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
+      //_LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
-                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
+                              memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __m, __m);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
-                               memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                                 memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
+                               memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __m, __m);}
 
     _LIBCPP_INLINE_VISIBILITY
-#ifndef _LIBCPP_CXX03_LANG
     __atomic_base() _NOEXCEPT = default;
-#else
-    __atomic_base() _NOEXCEPT : __a_() {}
-#endif // _LIBCPP_CXX03_LANG
 
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __a_(__d) {}
-#ifndef _LIBCPP_CXX03_LANG
     __atomic_base(const __atomic_base&) = delete;
     __atomic_base& operator=(const __atomic_base&) = delete;
     __atomic_base& operator=(const __atomic_base&) volatile = delete;
-#else
-private:
-    __atomic_base(const __atomic_base&);
-    __atomic_base& operator=(const __atomic_base&);
-    __atomic_base& operator=(const __atomic_base&) volatile;
-#endif
 };
 
-#if defined(__cpp_lib_atomic_is_always_lock_free)
-template <class _Tp, bool __b>
-_LIBCPP_CONSTEXPR bool __atomic_base<_Tp, __b>::is_always_lock_free;
-#endif
-
 // atomic<Integral>
 
-template <class _Tp>
-struct __atomic_base<_Tp, true>
-    : public __atomic_base<_Tp, false>
+template <class _Tp, class _TpAS>
+struct __atomic_base<_Tp, _TpAS, true>
+    : public __atomic_base<_Tp, _TpAS, false>
 {
-    typedef __atomic_base<_Tp, false> __base;
+    typedef _TpAS* _ptr_type;
+    typedef __atomic_base<_Tp, _TpAS, false> __base;
     _LIBCPP_INLINE_VISIBILITY
     __atomic_base() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __base(__d) {}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_and(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_and(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_or(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_or(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_xor(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_xor(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
 
+    // non-standard inc/dec
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp _fetch_inc(memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_inc(reinterpret_cast<_ptr_type>(&this->__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator++(int) volatile _NOEXCEPT      {return fetch_add(_Tp(1));}
+    _Tp _fetch_inc(memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_inc(reinterpret_cast<_ptr_type>(&this->__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator++(int) _NOEXCEPT               {return fetch_add(_Tp(1));}
+    _Tp _fetch_dec(memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_dec(reinterpret_cast<_ptr_type>(&this->__a_), __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp _fetch_dec(memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_dec(reinterpret_cast<_ptr_type>(&this->__a_), __m);}
+
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator--(int) volatile _NOEXCEPT      {return fetch_sub(_Tp(1));}
+    _Tp operator++(int) volatile _NOEXCEPT      {return _fetch_inc();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator--(int) _NOEXCEPT               {return fetch_sub(_Tp(1));}
+    _Tp operator++(int) _NOEXCEPT               {return _fetch_inc();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator++() volatile _NOEXCEPT         {return fetch_add(_Tp(1)) + _Tp(1);}
+    _Tp operator--(int) volatile _NOEXCEPT      {return _fetch_dec();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator++() _NOEXCEPT                  {return fetch_add(_Tp(1)) + _Tp(1);}
+    _Tp operator--(int) _NOEXCEPT               {return _fetch_dec();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator--() volatile _NOEXCEPT         {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _Tp operator++() volatile _NOEXCEPT         {return _fetch_inc() + _Tp(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator--() _NOEXCEPT                  {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _Tp operator++() _NOEXCEPT                  {return _fetch_inc() + _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--() volatile _NOEXCEPT         {return _fetch_dec() - _Tp(1);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp operator--() _NOEXCEPT                  {return _fetch_dec() - _Tp(1);}
     _LIBCPP_INLINE_VISIBILITY
     _Tp operator+=(_Tp __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
     _LIBCPP_INLINE_VISIBILITY
@@ -1080,11 +785,11 @@ struct __atomic_base<_Tp, true>
 
 // atomic<T>
 
-template <class _Tp>
+template <class _Tp, class _TpAS = global _Tp>
 struct atomic
-    : public __atomic_base<_Tp>
+    : public __atomic_base<_Tp, _TpAS>
 {
-    typedef __atomic_base<_Tp> __base;
+    typedef __atomic_base<_Tp, _TpAS> __base;
     _LIBCPP_INLINE_VISIBILITY
     atomic() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
@@ -1100,717 +805,70 @@ struct atomic
 
 // atomic<T*>
 
-template <class _Tp>
+template <class _Tp, class _TpAS>
 struct atomic<_Tp*>
-    : public __atomic_base<_Tp*>
+    : public __atomic_base<_Tp*, _TpAS*>
 {
+    typedef _TpAS* _ptr_type;
     typedef __atomic_base<_Tp*> __base;
+    
     _LIBCPP_INLINE_VISIBILITY
     atomic() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
-    _LIBCPP_CONSTEXPR atomic(_Tp* __d) _NOEXCEPT : __base(__d) {}
+    _LIBCPP_CONSTEXPR atomic(_ptr_type __d) _NOEXCEPT : __base(__d) {}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator=(_Tp* __d) volatile _NOEXCEPT
+    _ptr_type operator=(_ptr_type __d) volatile _NOEXCEPT
         {__base::store(__d); return __d;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator=(_Tp* __d) _NOEXCEPT
+    _ptr_type operator=(_ptr_type __d) _NOEXCEPT
         {__base::store(__d); return __d;}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
+    _ptr_type fetch_add(ptrdiff_t __op, memory_order __m = memory_order_relaxed)
                                                                         volatile _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _ptr_type fetch_add(ptrdiff_t __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
+    _ptr_type fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_relaxed)
                                                                         volatile _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _ptr_type fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}
+    _ptr_type operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++(int) _NOEXCEPT                     {return fetch_add(1);}
+    _ptr_type operator++(int) _NOEXCEPT                     {return fetch_add(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}
+    _ptr_type operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--(int) _NOEXCEPT                     {return fetch_sub(1);}
+    _ptr_type operator--(int) _NOEXCEPT                     {return fetch_sub(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}
+    _ptr_type operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}
+    _ptr_type operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}
+    _ptr_type operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}
+    _ptr_type operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
+    _ptr_type operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
+    _ptr_type operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
+    _ptr_type operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
+    _ptr_type operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
 };
 
-// atomic_is_lock_free
+// NOTE: freestanding atomic<*> functions are not supported, either use the corresponding member functions,
+// or use the freestanding floor atomic functions, which operate on raw global/local type pointers
 
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_is_lock_free(const volatile atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->is_lock_free();
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_is_lock_free(const atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->is_lock_free();
-}
-
-// atomic_init
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_init(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __c11_atomic_init(&__o->__a_, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_init(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __c11_atomic_init(&__o->__a_, __d);
-}
-
-// atomic_store
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __o->store(__d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __o->store(__d);
-}
-
-// atomic_store_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-  _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
-{
-    __o->store(__d, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-  _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)
-{
-    __o->store(__d, __m);
-}
-
-// atomic_load
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load(const volatile atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->load();
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load(const atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->load();
-}
-
-// atomic_load_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
-  _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
-{
-    return __o->load(__m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
-  _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)
-{
-    return __o->load(__m);
-}
-
-// atomic_exchange
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    return __o->exchange(__d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    return __o->exchange(__d);
-}
-
-// atomic_exchange_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    return __o->exchange(__d, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    return __o->exchange(__d, __m);
-}
-
-// atomic_compare_exchange_weak
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d);
-}
-
-// atomic_compare_exchange_strong
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d);
-}
-
-// atomic_compare_exchange_weak_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
-                                      _Tp __d,
-                                      memory_order __s, memory_order __f) _NOEXCEPT
-  _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
-{
-    return __o->compare_exchange_weak(*__e, __d, __s, __f);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
-                                      memory_order __s, memory_order __f) _NOEXCEPT
-  _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
-{
-    return __o->compare_exchange_weak(*__e, __d, __s, __f);
-}
-
-// atomic_compare_exchange_strong_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
-                                        _Tp* __e, _Tp __d,
-                                        memory_order __s, memory_order __f) _NOEXCEPT
-  _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
-{
-    return __o->compare_exchange_strong(*__e, __d, __s, __f);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
-                                        _Tp __d,
-                                        memory_order __s, memory_order __f) _NOEXCEPT
-  _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)
-{
-    return __o->compare_exchange_strong(*__e, __d, __s, __f);
-}
-
-// atomic_fetch_add
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-// atomic_fetch_add_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
-                          memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-// atomic_fetch_sub
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-// atomic_fetch_sub_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
-                          memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-// atomic_fetch_and
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_and(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_and(__op);
-}
-
-// atomic_fetch_and_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_and(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_and(__op, __m);
-}
-
-// atomic_fetch_or
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_or(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_or(__op);
-}
-
-// atomic_fetch_or_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_or(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_or(__op, __m);
-}
-
-// atomic_fetch_xor
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_xor(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_xor(__op);
-}
-
-// atomic_fetch_xor_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_xor(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_xor(__op, __m);
-}
-
-// flag type and operations
-
-typedef struct atomic_flag
-{
-    _Atomic(bool) __a_;
-
-    _LIBCPP_INLINE_VISIBILITY
-    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, true, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool test_and_set(memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, true, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    void clear(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {__c11_atomic_store(&__a_, false, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    void clear(memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {__c11_atomic_store(&__a_, false, __m);}
-
-    _LIBCPP_INLINE_VISIBILITY
-#ifndef _LIBCPP_CXX03_LANG
-    atomic_flag() _NOEXCEPT = default;
-#else
-    atomic_flag() _NOEXCEPT : __a_() {}
-#endif // _LIBCPP_CXX03_LANG
-
-    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
-    atomic_flag(bool __b) _NOEXCEPT : __a_(__b) {} // EXTENSION
-
-#ifndef _LIBCPP_CXX03_LANG
-    atomic_flag(const atomic_flag&) = delete;
-    atomic_flag& operator=(const atomic_flag&) = delete;
-    atomic_flag& operator=(const atomic_flag&) volatile = delete;
-#else
-private:
-    atomic_flag(const atomic_flag&);
-    atomic_flag& operator=(const atomic_flag&);
-    atomic_flag& operator=(const atomic_flag&) volatile;
-#endif
-} atomic_flag;
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set(volatile atomic_flag* __o) _NOEXCEPT
-{
-    return __o->test_and_set();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set(atomic_flag* __o) _NOEXCEPT
-{
-    return __o->test_and_set();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->test_and_set(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->test_and_set(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear(volatile atomic_flag* __o) _NOEXCEPT
-{
-    __o->clear();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear(atomic_flag* __o) _NOEXCEPT
-{
-    __o->clear();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    __o->clear(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    __o->clear(__m);
-}
+// NOTE: atomic_flag is not supported, use an appropriate atomic<uint32_t> instead
 
 // fences
 
@@ -1818,47 +876,48 @@ inline _LIBCPP_INLINE_VISIBILITY
 void
 atomic_thread_fence(memory_order __m) _NOEXCEPT
 {
-    __c11_atomic_thread_fence(__m);
+    floor_atomic_thread_fence(__m);
 }
 
 inline _LIBCPP_INLINE_VISIBILITY
 void
 atomic_signal_fence(memory_order __m) _NOEXCEPT
 {
-    __c11_atomic_signal_fence(__m);
+    floor_atomic_signal_fence(__m);
 }
 
 // Atomics for standard typedef types
 
-typedef atomic<bool>               atomic_bool;
-typedef atomic<char>               atomic_char;
-typedef atomic<signed char>        atomic_schar;
-typedef atomic<unsigned char>      atomic_uchar;
-typedef atomic<short>              atomic_short;
-typedef atomic<unsigned short>     atomic_ushort;
+// NOTE: commented out types are not supported!
+//typedef atomic<bool>               atomic_bool;
+//typedef atomic<char>               atomic_char;
+//typedef atomic<signed char>        atomic_schar;
+//typedef atomic<unsigned char>      atomic_uchar;
+//typedef atomic<short>              atomic_short;
+//typedef atomic<unsigned short>     atomic_ushort;
 typedef atomic<int>                atomic_int;
 typedef atomic<unsigned int>       atomic_uint;
 typedef atomic<long>               atomic_long;
 typedef atomic<unsigned long>      atomic_ulong;
 typedef atomic<long long>          atomic_llong;
 typedef atomic<unsigned long long> atomic_ullong;
-typedef atomic<char16_t>           atomic_char16_t;
+//typedef atomic<char16_t>           atomic_char16_t;
 typedef atomic<char32_t>           atomic_char32_t;
-typedef atomic<wchar_t>            atomic_wchar_t;
+//typedef atomic<wchar_t>            atomic_wchar_t;
 
-typedef atomic<int_least8_t>   atomic_int_least8_t;
-typedef atomic<uint_least8_t>  atomic_uint_least8_t;
-typedef atomic<int_least16_t>  atomic_int_least16_t;
-typedef atomic<uint_least16_t> atomic_uint_least16_t;
+//typedef atomic<int_least8_t>   atomic_int_least8_t;
+//typedef atomic<uint_least8_t>  atomic_uint_least8_t;
+//typedef atomic<int_least16_t>  atomic_int_least16_t;
+//typedef atomic<uint_least16_t> atomic_uint_least16_t;
 typedef atomic<int_least32_t>  atomic_int_least32_t;
 typedef atomic<uint_least32_t> atomic_uint_least32_t;
 typedef atomic<int_least64_t>  atomic_int_least64_t;
 typedef atomic<uint_least64_t> atomic_uint_least64_t;
 
-typedef atomic<int_fast8_t>   atomic_int_fast8_t;
-typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
-typedef atomic<int_fast16_t>  atomic_int_fast16_t;
-typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
+//typedef atomic<int_fast8_t>   atomic_int_fast8_t;
+//typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
+//typedef atomic<int_fast16_t>  atomic_int_fast16_t;
+//typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
 typedef atomic<int_fast32_t>  atomic_int_fast32_t;
 typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
 typedef atomic<int_fast64_t>  atomic_int_fast64_t;
@@ -1880,7 +939,7 @@ typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
 typedef atomic<intmax_t>  atomic_intmax_t;
 typedef atomic<uintmax_t> atomic_uintmax_t;
 
-#define ATOMIC_FLAG_INIT {false}
+#define ATOMIC_FLAG_INIT {0u}
 #define ATOMIC_VAR_INIT(__v) {__v}
 
 _LIBCPP_END_NAMESPACE_STD
diff --git a/include/cstddef b/include/cstddef
index b4c42b19d..46321b5c2 100644
--- a/include/cstddef
+++ b/include/cstddef
@@ -41,8 +41,7 @@ Types:
 #pragma GCC system_header
 #endif
 
-// Don't include our own <stddef.h>; we don't want to declare ::nullptr_t.
-#include_next <stddef.h>
+#include <stddef.h>
 #include <__nullptr>
 
 _LIBCPP_BEGIN_NAMESPACE_STD
diff --git a/include/exception b/include/exception
index fdd83d10c..685b96966 100644
--- a/include/exception
+++ b/include/exception
@@ -79,7 +79,9 @@ template <class E> void rethrow_if_nested(const E& e);
 
 #include <__config>
 #include <cstddef>
+#if 0
 #include <cstdlib>
+#endif
 #include <type_traits>
 #include <version>
 
@@ -178,7 +180,8 @@ make_exception_ptr(_Ep __e) _NOEXCEPT
     }
 #else
     ((void)__e);
-    _VSTD::abort();
+    // NOTE/TODO: there is no compute abort - trap instead?
+    //_VSTD::abort();
 #endif
 }
 
diff --git a/include/float.h b/include/float.h
deleted file mode 100644
index 759ac8e79..000000000
--- a/include/float.h
+++ /dev/null
@@ -1,94 +0,0 @@
-// -*- C++ -*-
-//===--------------------------- float.h ----------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef _LIBCPP_FLOAT_H
-#define _LIBCPP_FLOAT_H
-
-/*
-    float.h synopsis
-
-Macros:
-
-    FLT_ROUNDS
-    FLT_EVAL_METHOD     // C99
-    FLT_RADIX
-
-    FLT_MANT_DIG
-    DBL_MANT_DIG
-    LDBL_MANT_DIG
-
-    FLT_HAS_SUBNORM     // C11
-    DBL_HAS_SUBNORM     // C11
-    LDBL_HAS_SUBNORM    // C11
-
-    DECIMAL_DIG         // C99
-    FLT_DECIMAL_DIG     // C11
-    DBL_DECIMAL_DIG     // C11
-    LDBL_DECIMAL_DIG    // C11
-
-    FLT_DIG
-    DBL_DIG
-    LDBL_DIG
-
-    FLT_MIN_EXP
-    DBL_MIN_EXP
-    LDBL_MIN_EXP
-
-    FLT_MIN_10_EXP
-    DBL_MIN_10_EXP
-    LDBL_MIN_10_EXP
-
-    FLT_MAX_EXP
-    DBL_MAX_EXP
-    LDBL_MAX_EXP
-
-    FLT_MAX_10_EXP
-    DBL_MAX_10_EXP
-    LDBL_MAX_10_EXP
-
-    FLT_MAX
-    DBL_MAX
-    LDBL_MAX
-
-    FLT_EPSILON
-    DBL_EPSILON
-    LDBL_EPSILON
-
-    FLT_MIN
-    DBL_MIN
-    LDBL_MIN
-
-    FLT_TRUE_MIN        // C11
-    DBL_TRUE_MIN        // C11
-    LDBL_TRUE_MIN       // C11
-
-*/
-
-#include <__config>
-
-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-#pragma GCC system_header
-#endif
-
-#include_next <float.h>
-
-#ifdef __cplusplus
-
-#ifndef FLT_EVAL_METHOD
-#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
-#endif
-
-#ifndef DECIMAL_DIG
-#define DECIMAL_DIG __DECIMAL_DIG__
-#endif
-
-#endif // __cplusplus
-
-#endif  // _LIBCPP_FLOAT_H
diff --git a/include/functional b/include/functional
index 1fb44f271..248df04b6 100644
--- a/include/functional
+++ b/include/functional
@@ -489,8 +489,10 @@ POLICY:  For non-variadic implementations, the number of arguments is limited
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
 #include <exception>
+#endif
 #include <memory>
 #include <tuple>
 #include <utility>
@@ -1420,7 +1422,7 @@ void __throw_bad_function_call()
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw bad_function_call();
 #else
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
@@ -1887,8 +1889,12 @@ struct __policy
     // True if this is the null policy (no value).
     const bool __is_null;
 
+#ifndef _LIBCPP_NO_RTTI
     // The target type. May be null if RTTI is disabled.
     const std::type_info* const __type_info;
+#else
+	const void* const __type_info;
+#endif
 
     // Returns a pointer to a static policy object suitable for the functor
     // type.
@@ -2434,16 +2440,16 @@ namespace placeholders
 template <int _Np> struct __ph {};
 
 #if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_LIBRARY)
-_LIBCPP_FUNC_VIS extern const __ph<1>   _1;
-_LIBCPP_FUNC_VIS extern const __ph<2>   _2;
-_LIBCPP_FUNC_VIS extern const __ph<3>   _3;
-_LIBCPP_FUNC_VIS extern const __ph<4>   _4;
-_LIBCPP_FUNC_VIS extern const __ph<5>   _5;
-_LIBCPP_FUNC_VIS extern const __ph<6>   _6;
-_LIBCPP_FUNC_VIS extern const __ph<7>   _7;
-_LIBCPP_FUNC_VIS extern const __ph<8>   _8;
-_LIBCPP_FUNC_VIS extern const __ph<9>   _9;
-_LIBCPP_FUNC_VIS extern const __ph<10> _10;
+_LIBCPP_FUNC_VIS extern constant const __ph<1>   _1;
+_LIBCPP_FUNC_VIS extern constant const __ph<2>   _2;
+_LIBCPP_FUNC_VIS extern constant const __ph<3>   _3;
+_LIBCPP_FUNC_VIS extern constant const __ph<4>   _4;
+_LIBCPP_FUNC_VIS extern constant const __ph<5>   _5;
+_LIBCPP_FUNC_VIS extern constant const __ph<6>   _6;
+_LIBCPP_FUNC_VIS extern constant const __ph<7>   _7;
+_LIBCPP_FUNC_VIS extern constant const __ph<8>   _8;
+_LIBCPP_FUNC_VIS extern constant const __ph<9>   _9;
+_LIBCPP_FUNC_VIS extern constant const __ph<10> _10;
 #else
 /* _LIBCPP_INLINE_VAR */ constexpr __ph<1>   _1{};
 /* _LIBCPP_INLINE_VAR */ constexpr __ph<2>   _2{};
diff --git a/include/inttypes.h b/include/inttypes.h
deleted file mode 100644
index 058f54b51..000000000
--- a/include/inttypes.h
+++ /dev/null
@@ -1,258 +0,0 @@
-// -*- C++ -*-
-//===--------------------------- inttypes.h -------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef _LIBCPP_INTTYPES_H
-#define _LIBCPP_INTTYPES_H
-
-/*
-    inttypes.h synopsis
-
-This entire header is C99 / C++0X
-
-#include <stdint.h>  // <cinttypes> includes <cstdint>
-
-Macros:
-
-    PRId8
-    PRId16
-    PRId32
-    PRId64
-
-    PRIdLEAST8
-    PRIdLEAST16
-    PRIdLEAST32
-    PRIdLEAST64
-
-    PRIdFAST8
-    PRIdFAST16
-    PRIdFAST32
-    PRIdFAST64
-
-    PRIdMAX
-    PRIdPTR
-
-    PRIi8
-    PRIi16
-    PRIi32
-    PRIi64
-
-    PRIiLEAST8
-    PRIiLEAST16
-    PRIiLEAST32
-    PRIiLEAST64
-
-    PRIiFAST8
-    PRIiFAST16
-    PRIiFAST32
-    PRIiFAST64
-
-    PRIiMAX
-    PRIiPTR
-
-    PRIo8
-    PRIo16
-    PRIo32
-    PRIo64
-
-    PRIoLEAST8
-    PRIoLEAST16
-    PRIoLEAST32
-    PRIoLEAST64
-
-    PRIoFAST8
-    PRIoFAST16
-    PRIoFAST32
-    PRIoFAST64
-
-    PRIoMAX
-    PRIoPTR
-
-    PRIu8
-    PRIu16
-    PRIu32
-    PRIu64
-
-    PRIuLEAST8
-    PRIuLEAST16
-    PRIuLEAST32
-    PRIuLEAST64
-
-    PRIuFAST8
-    PRIuFAST16
-    PRIuFAST32
-    PRIuFAST64
-
-    PRIuMAX
-    PRIuPTR
-
-    PRIx8
-    PRIx16
-    PRIx32
-    PRIx64
-
-    PRIxLEAST8
-    PRIxLEAST16
-    PRIxLEAST32
-    PRIxLEAST64
-
-    PRIxFAST8
-    PRIxFAST16
-    PRIxFAST32
-    PRIxFAST64
-
-    PRIxMAX
-    PRIxPTR
-
-    PRIX8
-    PRIX16
-    PRIX32
-    PRIX64
-
-    PRIXLEAST8
-    PRIXLEAST16
-    PRIXLEAST32
-    PRIXLEAST64
-
-    PRIXFAST8
-    PRIXFAST16
-    PRIXFAST32
-    PRIXFAST64
-
-    PRIXMAX
-    PRIXPTR
-
-    SCNd8
-    SCNd16
-    SCNd32
-    SCNd64
-
-    SCNdLEAST8
-    SCNdLEAST16
-    SCNdLEAST32
-    SCNdLEAST64
-
-    SCNdFAST8
-    SCNdFAST16
-    SCNdFAST32
-    SCNdFAST64
-
-    SCNdMAX
-    SCNdPTR
-
-    SCNi8
-    SCNi16
-    SCNi32
-    SCNi64
-
-    SCNiLEAST8
-    SCNiLEAST16
-    SCNiLEAST32
-    SCNiLEAST64
-
-    SCNiFAST8
-    SCNiFAST16
-    SCNiFAST32
-    SCNiFAST64
-
-    SCNiMAX
-    SCNiPTR
-
-    SCNo8
-    SCNo16
-    SCNo32
-    SCNo64
-
-    SCNoLEAST8
-    SCNoLEAST16
-    SCNoLEAST32
-    SCNoLEAST64
-
-    SCNoFAST8
-    SCNoFAST16
-    SCNoFAST32
-    SCNoFAST64
-
-    SCNoMAX
-    SCNoPTR
-
-    SCNu8
-    SCNu16
-    SCNu32
-    SCNu64
-
-    SCNuLEAST8
-    SCNuLEAST16
-    SCNuLEAST32
-    SCNuLEAST64
-
-    SCNuFAST8
-    SCNuFAST16
-    SCNuFAST32
-    SCNuFAST64
-
-    SCNuMAX
-    SCNuPTR
-
-    SCNx8
-    SCNx16
-    SCNx32
-    SCNx64
-
-    SCNxLEAST8
-    SCNxLEAST16
-    SCNxLEAST32
-    SCNxLEAST64
-
-    SCNxFAST8
-    SCNxFAST16
-    SCNxFAST32
-    SCNxFAST64
-
-    SCNxMAX
-    SCNxPTR
-
-Types:
-
-    imaxdiv_t
-
-intmax_t  imaxabs(intmax_t j);
-imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
-intmax_t  strtoimax(const char* restrict nptr, char** restrict endptr, int base);
-uintmax_t strtoumax(const char* restrict nptr, char** restrict endptr, int base);
-intmax_t  wcstoimax(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
-uintmax_t wcstoumax(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
-
-*/
-
-#include <__config>
-
-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-#pragma GCC system_header
-#endif
-
-/* C99 stdlib (e.g. glibc < 2.18) does not provide format macros needed
-   for C++11 unless __STDC_FORMAT_MACROS is defined
-*/
-#if defined(__cplusplus) && !defined(__STDC_FORMAT_MACROS)
-#   define __STDC_FORMAT_MACROS
-#endif
-
-#include_next <inttypes.h>
-
-#ifdef __cplusplus
-
-#include <stdint.h>
-
-#undef imaxabs
-#undef imaxdiv
-
-#endif // __cplusplus
-
-#endif  // _LIBCPP_INTTYPES_H
diff --git a/include/iosfwd b/include/iosfwd
index 31f1902e5..4c393cfc7 100644
--- a/include/iosfwd
+++ b/include/iosfwd
@@ -93,7 +93,12 @@ typedef fpos<char_traits<wchar_t>::state_type> wstreampos;
 */
 
 #include <__config>
+#if 0
 #include <wchar.h>  // for mbstate_t
+#else
+// NOTE: not supported!
+typedef size_t mbstate_t;
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #pragma GCC system_header
diff --git a/include/limits b/include/limits
index 5ea9a9e6f..9d4829fcc 100644
--- a/include/limits
+++ b/include/limits
@@ -440,6 +440,54 @@ protected:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
 };
 
+#if defined(FLOOR_COMPUTE)
+template <>
+class __libcpp_numeric_limits<__fp16, true>
+{
+protected:
+    typedef __fp16 type;
+
+    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
+
+    static _LIBCPP_CONSTEXPR const bool is_signed = true;
+    static _LIBCPP_CONSTEXPR const int  digits = __HALF_MANT_DIG__;
+    static _LIBCPP_CONSTEXPR const int  digits10 = __HALF_DIG__;
+    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __HALF_MIN__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __HALF_MAX__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
+
+    static _LIBCPP_CONSTEXPR const bool is_integer = false;
+    static _LIBCPP_CONSTEXPR const bool is_exact = false;
+    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __HALF_EPSILON__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5h;}
+
+    static _LIBCPP_CONSTEXPR const int  min_exponent = __HALF_MIN_EXP__;
+    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __HALF_MIN_10_EXP__;
+    static _LIBCPP_CONSTEXPR const int  max_exponent = __HALF_MAX_EXP__;
+    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __HALF_MAX_10_EXP__;
+
+    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
+    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
+    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;
+    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
+    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valh();}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanh("");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansh("");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __HALF_DENORM_MIN__;}
+
+    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
+    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
+    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
+
+    static _LIBCPP_CONSTEXPR const bool traps = false;
+    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
+    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
+};
+#endif
+
 template <class _Tp>
 class _LIBCPP_TEMPLATE_VIS numeric_limits
     : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
@@ -486,6 +534,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_specialized;
 template <class _Tp>
@@ -532,6 +581,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<_Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TEMPLATE_VIS numeric_limits<const _Tp>
@@ -579,6 +629,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_specialized;
 template <class _Tp>
@@ -625,6 +676,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const _Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TEMPLATE_VIS numeric_limits<volatile _Tp>
@@ -672,6 +724,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_specialized;
 template <class _Tp>
@@ -718,6 +771,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<volatile _Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TEMPLATE_VIS numeric_limits<const volatile _Tp>
@@ -765,6 +819,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_specialized;
 template <class _Tp>
@@ -811,6 +866,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;
+#endif
 
 _LIBCPP_END_NAMESPACE_STD
 
diff --git a/include/memory b/include/memory
index 3e8f5936e..f70ba5ea6 100644
--- a/include/memory
+++ b/include/memory
@@ -651,9 +651,13 @@ void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
+#endif
 #include <cstddef>
+#if 0
 #include <cstdint>
+#endif
 #include <new>
 #include <utility>
 #include <limits>
@@ -662,8 +666,10 @@ void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
 #include <iosfwd>
 #include <tuple>
 #include <stdexcept>
+#if 0
 #include <cstring>
 #include <cassert>
+#endif
 #if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
 #  include <atomic>
 #endif
@@ -1632,7 +1638,7 @@ struct _LIBCPP_TEMPLATE_VIS allocator_traits
             ptrdiff_t _Np = __end1 - __begin1;
             if (_Np > 0)
             {
-                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
+                __builtin_memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
                 __begin2 += _Np;
             }
         }
@@ -1663,7 +1669,7 @@ struct _LIBCPP_TEMPLATE_VIS allocator_traits
             ptrdiff_t _Np = __end1 - __begin1;
             if (_Np > 0)
             {
-                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));
+                __builtin_memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));
                 __begin2 += _Np;
             }
         }
@@ -1696,7 +1702,7 @@ struct _LIBCPP_TEMPLATE_VIS allocator_traits
             ptrdiff_t _Np = __end1 - __begin1;
             __end2 -= _Np;
             if (_Np > 0)
-                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
+                __builtin_memcpy(__end2, __begin1, _Np * sizeof(_Tp));
         }
 
 private:
@@ -2003,6 +2009,7 @@ public:
 #endif
 };
 
+#if 0
 template <class _Tp>
 _LIBCPP_NODISCARD_EXT _LIBCPP_NO_CFI
 pair<_Tp*, ptrdiff_t>
@@ -2054,6 +2061,7 @@ void return_temporary_buffer(_Tp* __p) _NOEXCEPT
 {
   _VSTD::__libcpp_deallocate_unsized((void*)__p, __alignof(_Tp));
 }
+#endif
 
 #if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
 template <class _Tp>
@@ -3493,7 +3501,7 @@ void __throw_bad_weak_ptr()
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw bad_weak_ptr();
 #else
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
diff --git a/include/new b/include/new
index 24ffcad5a..4bfc9920d 100644
--- a/include/new
+++ b/include/new
@@ -86,9 +86,11 @@ void  operator delete[](void* ptr, void*) noexcept;
 #include <type_traits>
 #include <cstddef>
 #include <version>
+#if 0
 #ifdef _LIBCPP_NO_EXCEPTIONS
 #include <cstdlib>
 #endif
+#endif
 
 #if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)
 #include <new.h>
@@ -122,7 +124,7 @@ namespace std  // purposefully not using versioning namespace
 
 #if !defined(_LIBCPP_ABI_MICROSOFT) || defined(_LIBCPP_NO_VCRUNTIME)
 struct _LIBCPP_TYPE_VIS nothrow_t {};
-extern _LIBCPP_FUNC_VIS const nothrow_t nothrow;
+//_LIBCPP_FUNC_VIS const nothrow_t nothrow;
 
 class _LIBCPP_EXCEPTION_ABI bad_alloc
     : public exception
@@ -167,7 +169,7 @@ enum align_val_t { __zero = 0, __max = (size_t)-1 };
 #define _THROW_BAD_ALLOC
 #endif
 
-#if !defined(_LIBCPP_DEFER_NEW_TO_VCRUNTIME)
+#if !defined(_LIBCPP_DEFER_NEW_TO_VCRUNTIME) && 0
 
 _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;
 _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;
diff --git a/include/stddef.h b/include/stddef.h
deleted file mode 100644
index f65065d86..000000000
--- a/include/stddef.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// -*- C++ -*-
-//===--------------------------- stddef.h ---------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
-    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)
-
-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-#pragma GCC system_header
-#endif
-
-#include_next <stddef.h>
-
-#elif !defined(_LIBCPP_STDDEF_H)
-#define _LIBCPP_STDDEF_H
-
-/*
-    stddef.h synopsis
-
-Macros:
-
-    offsetof(type,member-designator)
-    NULL
-
-Types:
-
-    ptrdiff_t
-    size_t
-    max_align_t
-    nullptr_t
-
-*/
-
-#include <__config>
-
-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-#pragma GCC system_header
-#endif
-
-#include_next <stddef.h>
-
-#ifdef __cplusplus
-
-extern "C++" {
-#include <__nullptr>
-using std::nullptr_t;
-}
-
-// Re-use the compiler's <stddef.h> max_align_t where possible.
-#if !defined(__CLANG_MAX_ALIGN_T_DEFINED) && !defined(_GCC_MAX_ALIGN_T) && \
-    !defined(__DEFINED_max_align_t) && !defined(__NetBSD__)
-typedef long double max_align_t;
-#endif
-
-#endif
-
-#endif  // _LIBCPP_STDDEF_H
diff --git a/include/stdexcept b/include/stdexcept
index 3ec79349a..81fd3b8ab 100644
--- a/include/stdexcept
+++ b/include/stdexcept
@@ -45,9 +45,11 @@ public:
 #include <__config>
 #include <exception>
 #include <iosfwd>  // for string forward decl
+#if 0
 #ifdef _LIBCPP_NO_EXCEPTIONS
 #include <cstdlib>
 #endif
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #pragma GCC system_header
@@ -57,7 +59,7 @@ _LIBCPP_BEGIN_NAMESPACE_STD
 
 class _LIBCPP_HIDDEN __libcpp_refstring
 {
-    const char* __imp_;
+    constant const char* __imp_;
 
     bool __uses_refcount() const;
 public:
@@ -66,7 +68,7 @@ public:
     __libcpp_refstring& operator=(const __libcpp_refstring& __s) _NOEXCEPT;
     ~__libcpp_refstring();
 
-    const char* c_str() const _NOEXCEPT {return __imp_;}
+    constant const char* c_str() const _NOEXCEPT {return __imp_;}
 };
 
 _LIBCPP_END_NAMESPACE_STD
@@ -81,7 +83,7 @@ private:
     _VSTD::__libcpp_refstring __imp_;
 public:
     explicit logic_error(const string&);
-    explicit logic_error(const char*);
+    explicit logic_error(const constant char*);
 
     logic_error(const logic_error&) _NOEXCEPT;
     logic_error& operator=(const logic_error&) _NOEXCEPT;
@@ -98,7 +100,7 @@ private:
     _VSTD::__libcpp_refstring __imp_;
 public:
     explicit runtime_error(const string&);
-    explicit runtime_error(const char*);
+    explicit runtime_error(const constant char*);
 
     runtime_error(const runtime_error&) _NOEXCEPT;
     runtime_error& operator=(const runtime_error&) _NOEXCEPT;
@@ -113,7 +115,7 @@ class _LIBCPP_EXCEPTION_ABI domain_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const constant char* __s)   : logic_error(__s) {}
 
     virtual ~domain_error() _NOEXCEPT;
 };
@@ -123,7 +125,7 @@ class _LIBCPP_EXCEPTION_ABI invalid_argument
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const constant char* __s)   : logic_error(__s) {}
 
     virtual ~invalid_argument() _NOEXCEPT;
 };
@@ -133,7 +135,7 @@ class _LIBCPP_EXCEPTION_ABI length_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit length_error(const constant char* __s)   : logic_error(__s) {}
 
     virtual ~length_error() _NOEXCEPT;
 };
@@ -143,7 +145,7 @@ class _LIBCPP_EXCEPTION_ABI out_of_range
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const constant char* __s)   : logic_error(__s) {}
 
     virtual ~out_of_range() _NOEXCEPT;
 };
@@ -153,7 +155,7 @@ class _LIBCPP_EXCEPTION_ABI range_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit range_error(const constant char* __s)   : runtime_error(__s) {}
 
     virtual ~range_error() _NOEXCEPT;
 };
@@ -163,7 +165,7 @@ class _LIBCPP_EXCEPTION_ABI overflow_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const constant char* __s)   : runtime_error(__s) {}
 
     virtual ~overflow_error() _NOEXCEPT;
 };
@@ -173,7 +175,7 @@ class _LIBCPP_EXCEPTION_ABI underflow_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const constant char* __s)   : runtime_error(__s) {}
 
     virtual ~underflow_error() _NOEXCEPT;
 };
@@ -186,90 +188,90 @@ _LIBCPP_BEGIN_NAMESPACE_STD
 _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);
 
 _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
-void __throw_logic_error(const char*__msg)
+void __throw_logic_error(const constant char*__msg)
 {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw logic_error(__msg);
 #else
     ((void)__msg);
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
 _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
-void __throw_domain_error(const char*__msg)
+void __throw_domain_error(const constant char*__msg)
 {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw domain_error(__msg);
 #else
     ((void)__msg);
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
 _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
-void __throw_invalid_argument(const char*__msg)
+void __throw_invalid_argument(const constant char*__msg)
 {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw invalid_argument(__msg);
 #else
     ((void)__msg);
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
 _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
-void __throw_length_error(const char*__msg)
+void __throw_length_error(const constant char*__msg)
 {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw length_error(__msg);
 #else
     ((void)__msg);
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
 _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
-void __throw_out_of_range(const char*__msg)
+void __throw_out_of_range(const constant char*__msg)
 {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw out_of_range(__msg);
 #else
     ((void)__msg);
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
 _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
-void __throw_range_error(const char*__msg)
+void __throw_range_error(const constant char*__msg)
 {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw range_error(__msg);
 #else
     ((void)__msg);
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
 _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
-void __throw_overflow_error(const char*__msg)
+void __throw_overflow_error(const constant char*__msg)
 {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw overflow_error(__msg);
 #else
     ((void)__msg);
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
 _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY
-void __throw_underflow_error(const char*__msg)
+void __throw_underflow_error(const constant char*__msg)
 {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw underflow_error(__msg);
 #else
     ((void)__msg);
-    _VSTD::abort();
+    //_VSTD::abort();
 #endif
 }
 
diff --git a/include/type_traits b/include/type_traits
index ab010716f..408954f68 100644
--- a/include/type_traits
+++ b/include/type_traits
@@ -531,8 +531,8 @@ struct _LIBCPP_TEMPLATE_VIS integral_constant
 #endif
 };
 
-template <class _Tp, _Tp __v>
-_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
+//template <class _Tp, _Tp __v>
+//_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
 
 #if _LIBCPP_STD_VER > 14
 template <bool __b>
@@ -744,6 +744,9 @@ template <class _Tp> struct __libcpp_is_floating_point              : public fal
 template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
 template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
 template <>          struct __libcpp_is_floating_point<long double> : public true_type {};
+#if defined(FLOOR_COMPUTE)
+template <>          struct __libcpp_is_floating_point<__fp16>      : public true_type {};
+#endif
 
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point
     : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
diff --git a/include/utility b/include/utility
index fb7f44705..84e3842c6 100644
--- a/include/utility
+++ b/include/utility
@@ -201,8 +201,10 @@ template <size_t I>
 #include <type_traits>
 #include <initializer_list>
 #include <cstddef>
+#if 0
 #include <cstring>
 #include <cstdint>
+#endif
 #include <version>
 #include <__debug>
 
@@ -975,7 +977,7 @@ _Size
 __loadword(const void* __p)
 {
     _Size __r;
-    std::memcpy(&__r, __p, sizeof(__r));
+    __builtin_memcpy(&__r, __p, sizeof(__r));
     return __r;
 }
 
