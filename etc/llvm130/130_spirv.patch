diff --git a/include/LLVMSPIRVLib.h b/include/LLVMSPIRVLib.h
index a88d0f0..bfc340e 100644
--- a/include/LLVMSPIRVLib.h
+++ b/include/LLVMSPIRVLib.h
@@ -42,6 +42,7 @@
 #define SPIRV_H
 
 #include "LLVMSPIRVOpts.h"
+#include "llvm/../../projects/spirv/lib/SPIRV/libSPIRV/SPIRVUtil.h"
 
 #include <iostream>
 #include <string>
@@ -51,6 +52,7 @@ namespace llvm {
 // PassSupport.h.
 class PassRegistry;
 void initializeLLVMToSPIRVLegacyPass(PassRegistry &);
+void initializeLLVMToSPIRVTransformationsPass(PassRegistry&);
 void initializeOCLToSPIRVLegacyPass(PassRegistry &);
 void initializeOCLTypeToSPIRVLegacyPass(PassRegistry &);
 void initializeSPIRVLowerBoolLegacyPass(PassRegistry &);
@@ -81,7 +83,7 @@ bool isSpirvBinary(const std::string &Img);
 /// This function is not thread safe and should not be used in multi-thread
 /// applications unless guarded by a critical section.
 /// \returns true if succeeds.
-bool convertSpirv(std::istream &IS, std::ostream &OS, std::string &ErrMsg,
+bool convertSpirv(std::istream &IS, spv_ostream &OS, std::string &ErrMsg,
                   bool FromText, bool ToText);
 
 /// \brief Convert SPIR-V between binary and internal text formats.
@@ -111,7 +113,7 @@ namespace llvm {
 
 /// \brief Translate LLVM module to SPIR-V and write to ostream.
 /// \returns true if succeeds.
-bool writeSpirv(Module *M, std::ostream &OS, std::string &ErrMsg);
+bool writeSpirv(Module *M, spv_ostream &OS, std::string &ErrMsg);
 
 /// \brief Load SPIR-V from istream and translate to LLVM module.
 /// \returns true if succeeds.
@@ -120,7 +122,7 @@ bool readSpirv(LLVMContext &C, std::istream &IS, Module *&M,
 
 /// \brief Translate LLVM module to SPIR-V and write to ostream.
 /// \returns true if succeeds.
-bool writeSpirv(Module *M, const SPIRV::TranslatorOpts &Opts, std::ostream &OS,
+bool writeSpirv(Module *M, const SPIRV::TranslatorOpts &Opts, spv_ostream &OS,
                 std::string &ErrMsg);
 
 /// \brief Load SPIR-V from istream and translate to LLVM module.
@@ -161,6 +163,10 @@ void mangleOpenClBuiltin(const std::string &UnmangledName,
 /// Create a pass for translating LLVM to SPIR-V.
 ModulePass *createLLVMToSPIRVLegacy(SPIRV::SPIRVModule *);
 
+/// Create a pass that transforms certain IR to constructs that are better, or
+/// more easily, representable in SPIR-V.
+ModulePass *createLLVMToSPIRVTransformations();
+
 /// Create a pass for translating OCL C builtin functions to SPIR-V builtin
 /// functions.
 ModulePass *createOCLToSPIRVLegacy();
diff --git a/include/LLVMSPIRVOpts.h b/include/LLVMSPIRVOpts.h
index 83bb4fa..fe48825 100644
--- a/include/LLVMSPIRVOpts.h
+++ b/include/LLVMSPIRVOpts.h
@@ -61,10 +61,11 @@ enum class VersionNumber : uint32_t {
   SPIRV_1_1 = 0x00010100,
   SPIRV_1_2 = 0x00010200,
   SPIRV_1_3 = 0x00010300,
-  // TODO: populate this enum with the latest versions (up to 1.5) once
+  SPIRV_1_4 = 0x00010400,
+  SPIRV_1_5 = 0x00010500,
   // translator get support of corresponding features
   MinimumVersion = SPIRV_1_0,
-  MaximumVersion = SPIRV_1_3
+  MaximumVersion = SPIRV_1_5
 };
 
 enum class ExtensionID : uint32_t {
diff --git a/lib/SPIRV/CMakeLists.txt b/lib/SPIRV/CMakeLists.txt
index c212eda..37a9593 100644
--- a/lib/SPIRV/CMakeLists.txt
+++ b/lib/SPIRV/CMakeLists.txt
@@ -1,6 +1,7 @@
 add_llvm_library(LLVMSPIRVLib
   LLVMSPIRVOpts.cpp
   LLVMToSPIRVDbgTran.cpp
+  LLVMToSPIRVTransformations.cpp
   Mangler/FunctionDescriptor.cpp
   Mangler/Mangler.cpp
   Mangler/ManglingUtils.cpp
@@ -9,6 +10,7 @@ add_llvm_library(LLVMSPIRVLib
   OCLTypeToSPIRV.cpp
   OCLUtil.cpp
   VectorComputeUtil.cpp
+  SPIRVContainerWriterPass.cpp
   SPIRVLowerBool.cpp
   SPIRVLowerConstExpr.cpp
   SPIRVLowerMemmove.cpp
diff --git a/lib/SPIRV/LLVMToSPIRVTransformations.cpp b/lib/SPIRV/LLVMToSPIRVTransformations.cpp
new file mode 100644
index 0000000..8627272
--- /dev/null
+++ b/lib/SPIRV/LLVMToSPIRVTransformations.cpp
@@ -0,0 +1,302 @@
+//===- LLVMToSPIRVTransformations.cpp -------------------------------------===//
+//
+//  Flo's Open libRary (floor)
+//  Copyright (C) 2004 - 2021 Florian Ziesche
+//
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; version 2 of the License only.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License along
+//  with this program; if not, write to the Free Software Foundation, Inc.,
+//  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+//
+//===----------------------------------------------------------------------===//
+//
+// Pre-pass (prior to SPIRVWriter) that performs a few LLVM to SPIR-V
+// transformations.
+//
+//===----------------------------------------------------------------------===//
+
+#include "SPIRVInternal.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/IR/CallingConv.h"
+#include "llvm/IR/ConstantRange.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/DebugInfo.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/Dominators.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/InlineAsm.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/IR/InstVisitor.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/Metadata.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/Pass.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/raw_ostream.h"
+#include <vector>
+using namespace llvm;
+using namespace SPIRV;
+
+#define DEBUG_TYPE "LLVMToSPIRVTransformations"
+
+#if 1
+#define DBG(x)
+#else
+#define DBG(x) x
+#endif
+
+namespace SPIRV {
+struct LLVMToSPIRVTransformations
+    : public InstVisitor<LLVMToSPIRVTransformations>,
+      ModulePass {
+  static char ID; // Pass identification, replacement for typeid
+
+  Module *M{nullptr};
+  LLVMContext *ctx{nullptr};
+  bool was_modified{false};
+
+  // used by composite construction replacement
+  // we keep this both as an unordered_set for fast lookup and in a vector,
+  // because erasing must happen in reverse use order
+  std::unordered_set<Instruction *> kill_set;
+  std::vector<Instruction *> kill_list;
+
+  LLVMToSPIRVTransformations() : ModulePass(ID) {
+    initializeLLVMToSPIRVTransformationsPass(*PassRegistry::getPassRegistry());
+  }
+
+  StringRef getPassName() const override {
+    return "LLVM to SPIR-V transformations";
+  }
+
+  bool runOnModule(Module &Mod) override {
+    M = &Mod;
+    ctx = &M->getContext();
+    was_modified = false;
+
+    // return if not compiling Vulkan/SPIR-V
+    auto Src = getSPIRVSource(M);
+    if (std::get<0>(Src) != spv::SourceLanguageGLSL) {
+      return false;
+    }
+
+    //
+    for (auto &F : *M) {
+      // only handle actual functions
+      if (F.isDeclaration())
+        continue;
+      runOnFunction(F);
+    }
+
+    return was_modified;
+  }
+
+  void runOnFunction(Function &F) {
+    kill_set.clear();
+    kill_list.clear();
+    visit(F);
+    for (auto iter = kill_list.rbegin(); iter != kill_list.rend(); ++iter) {
+      (*iter)->eraseFromParent();
+    }
+  }
+
+  // InstVisitor overrides
+  using InstVisitor<LLVMToSPIRVTransformations>::visit;
+  void visit(Instruction &I) {
+    InstVisitor<LLVMToSPIRVTransformations>::visit(I);
+  }
+
+  // vector insert chain replacement
+  void visitInsertElement(InsertElementInst &I) {
+    if (kill_set.count(&I) > 0) {
+      return;
+    }
+
+    // sanity check
+    const auto vec_type = dyn_cast_or_null<FixedVectorType>(I.getType());
+    if (!vec_type) {
+      return;
+    }
+
+    // only continue this if the first object to insert into is undef
+    if (!isa<UndefValue>(I.getOperand(0))) {
+      return;
+    }
+
+    const auto elem_type = vec_type->getElementType();
+    const auto elem_count = vec_type->getNumElements();
+
+    bool replace = true;
+    std::vector<InsertElementInst *> insert_elems{&I};
+    std::vector<Value *> elems{I.getOperand(1)};
+    InsertElementInst *cur_insert = &I;
+    for (uint32_t i = 1;; ++i) {
+      // abort if the index isn't constant or is not contiguous in 0..#elems-1
+      // NOTE: we do except that LLVM has ordered these
+      auto idx = dyn_cast<ConstantInt>(cur_insert->getOperand(2));
+      if (idx == nullptr || idx->getZExtValue() != (i - 1)) {
+        replace = false;
+        break;
+      }
+
+      // done here
+      if (i == elem_count) {
+        break;
+      }
+
+      // abort if not exactly 1 use (this isn't a straight chain of inserts)
+      if (cur_insert->getNumUses() != 1) {
+        replace = false;
+        break;
+      }
+
+      //
+      cur_insert = dyn_cast<InsertElementInst>(*cur_insert->users().begin());
+      if (cur_insert == nullptr) {
+        replace = false;
+        break;
+      }
+      insert_elems.emplace_back(cur_insert);
+      elems.emplace_back(cur_insert->getOperand(1));
+    }
+    if (!replace)
+      return;
+
+    // we need to create a unique function name for this type
+    std::string func_name =
+        "floor.composite_construct.llvm." + std::to_string(elem_count) + "x";
+    raw_string_ostream func_name_stream(func_name);
+    elem_type->print(func_name_stream);
+    func_name_stream.flush();
+
+    // create composite construct at the last InsertElementInst + replace all
+    // its uses
+    std::vector<Type *> param_types(elem_count, elem_type);
+    const auto func_type =
+        llvm::FunctionType::get(vec_type, param_types, false);
+    llvm::CallInst *CI =
+        CallInst::Create(M->getOrInsertFunction(func_name, func_type), elems,
+                         (I.hasName() ? I.getName() + ".composite_construct"
+                                      : "composite_construct"),
+                         cur_insert);
+    CI->setCallingConv(CallingConv::FLOOR_FUNC);
+    CI->setDebugLoc(I.getDebugLoc()); // keep debug loc of first insert
+    cur_insert->replaceAllUsesWith(CI);
+
+    // add all replaced InsertElementInsts to the kill list
+    for (auto &instr : insert_elems) {
+      kill_list.emplace_back(instr);
+      kill_set.emplace(instr);
+    }
+
+    was_modified = true;
+  }
+
+  // aggregate insert chain replacement
+  void visitInsertValue(InsertValueInst &) {
+    // TODO: implement this
+  }
+
+  // vector shuffle with undef replacement
+  void visitShuffleVector(ShuffleVectorInst &I) {
+    if (isa<UndefValue>(I.getOperand(1))) {
+      I.setOperand(1, I.getOperand(0));
+      was_modified = true;
+      return;
+    }
+    if (isa<UndefValue>(I.getOperand(0))) {
+      I.setOperand(0, I.getOperand(1));
+      was_modified = true;
+      return;
+    }
+  }
+
+  //! returns a constant zero val for the specified type
+  //! NOTE: validation must have already happened
+  static Constant *make_zero_val(llvm::Type *val_type) {
+    if (val_type->isVectorTy()) {
+      auto vec_type = dyn_cast_or_null<FixedVectorType>(val_type);
+      auto vec_elem_type = vec_type->getElementType();
+      return ConstantVector::getSplat(
+          vec_type->getElementCount(),
+          vec_elem_type->isIntegerTy() ? ConstantInt::get(vec_elem_type, 0)
+                                       : ConstantFP::get(vec_elem_type, 0.0));
+    } else if (val_type->isIntegerTy()) {
+      return ConstantInt::get(val_type, 0);
+    } else if (val_type->isFloatingPointTy()) {
+      return ConstantFP::get(val_type, 0.0);
+    } else if (val_type->isPointerTy()) {
+      auto phi_ptr_type = dyn_cast_or_null<PointerType>(val_type);
+      assert(phi_ptr_type && "invalid ptr type");
+      return ConstantPointerNull::get(phi_ptr_type);
+    }
+    llvm_unreachable("invalid phi type");
+  }
+  // don't allow undef values in PHIs
+  void visitPHINode(PHINode &phi) {
+    auto val_type = phi.getType();
+    if (val_type->isVectorTy()) {
+      auto vec_type = dyn_cast_or_null<FixedVectorType>(val_type);
+      if (!vec_type || (!vec_type->getElementType()->isIntegerTy() &&
+                        !vec_type->getElementType()->isFloatingPointTy())) {
+        return; // can't handle this
+      }
+    } else if (!val_type->isIntegerTy() &&
+               !val_type->isFloatingPointTy() &&
+               !val_type->isPointerTy()) {
+      return; // can't handle this
+    }
+    for (uint32_t in_idx = 0, in_count = phi.getNumIncomingValues();
+         in_idx < in_count; ++in_idx) {
+      auto in_val = phi.getIncomingValue(in_idx);
+      if (auto undef = dyn_cast_or_null<UndefValue>(in_val)) {
+        phi.setIncomingValue(in_idx, make_zero_val(val_type));
+        was_modified = true;
+      }
+    }
+  }
+
+  void visitCallInst(CallInst &CI) {
+    // remove placeholder function calls
+    if (CI.getCalledFunction()->getName().startswith("floor.merge_block") ||
+        CI.getCalledFunction()->getName().startswith("floor.continue_block") ||
+        CI.getCalledFunction()->getName().startswith("floor.keep_block")) {
+      CI.eraseFromParent();
+      was_modified = true;
+    }
+#if 0
+    // remove unnecessary selection merge calls (branch that is no longer conditional)
+    if (CI.getCalledFunction()->getName() == "floor.selection_merge") {
+      auto term = CI.getParent()->getTerminator();
+      if (auto br = dyn_cast_or_null<BranchInst>(term); br && !br->isConditional()) {
+        CI.eraseFromParent();
+        was_modified = true;
+      }
+    }
+#endif
+  }
+};
+
+char LLVMToSPIRVTransformations::ID = 0;
+} // namespace SPIRV
+
+ModulePass *llvm::createLLVMToSPIRVTransformations() {
+  return new LLVMToSPIRVTransformations();
+}
+INITIALIZE_PASS(LLVMToSPIRVTransformations, "LLVM to SPIR-V transformations",
+                "LLVM to SPIR-V transformations", false, false)
diff --git a/lib/SPIRV/Mangler/ManglingUtils.cpp b/lib/SPIRV/Mangler/ManglingUtils.cpp
index b201f70..4f5acb3 100644
--- a/lib/SPIRV/Mangler/ManglingUtils.cpp
+++ b/lib/SPIRV/Mangler/ManglingUtils.cpp
@@ -66,6 +66,24 @@ static const char *PrimitiveNames[PRIMITIVE_NUM] = {
     "image2d_msaa_depth_rw_t",
     "image2d_array_msaa_depth_rw_t",
     "image3d_rw_t",
+	// --> for libfloor Vulkan/OpenCL
+    "image1d_t",
+    "image1d_array_t",
+    "image1d_buffer_t",
+    "image2d_t",
+    "image2d_array_t",
+    "image3d_t",
+    "image2d_msaa_t",
+    "image2d_array_msaa_t",
+    "image2d_msaa_depth_t",
+    "image2d_array_msaa_depth_t",
+    "image2d_depth_t",
+    "image2d_array_depth_t",
+    "imagecube_t",
+    "imagecube_array_t",
+    "imagecube_depth_t",
+    "imagecube_array_depth_t",
+	// <-- for libfloor Vulkan/OpenCL
     "event_t",
     "pipe_ro_t",
     "pipe_wo_t",
@@ -143,6 +161,24 @@ const char *MangledTypes[PRIMITIVE_NUM] = {
     "25ocl_image2d_msaa_depth_rw",       // PRIMITIVE_IMAGE2D_MSAA_DEPTH_RW_T
     "31ocl_image2d_array_msaa_depth_rw", // PRIMITIVE_IMAGE2D_ARRAY_MSAA_DEPTH_RW_T
     "14ocl_image3d_rw",                  // PRIMITIVE_IMAGE3D_RW_T
+	// --> for libfloor Vulkan/OpenCL
+	"11ocl_image1d",               // PRIMITIVE_IMAGE_1D_T
+    "16ocl_image1darray",          // PRIMITIVE_IMAGE_1D_ARRAY_T
+    "17ocl_image1dbuffer",         // PRIMITIVE_IMAGE_1D_BUFFER_T
+    "11ocl_image2d",               // PRIMITIVE_IMAGE_2D_T
+    "16ocl_image2darray",          // PRIMITIVE_IMAGE_2D_ARRAY_T
+    "11ocl_image3d",               // PRIMITIVE_IMAGE_3D_T
+    "15ocl_image2dmsaa",           // PRIMITIVE_IMAGE_2D_MSAA_T
+    "20ocl_image2darraymsaa",      // PRIMITIVE_IMAGE_2D_ARRAY_MSAA_T
+    "20ocl_image2dmsaadepth",      // PRIMITIVE_IMAGE_2D_MSAA_DEPTH_T
+    "25ocl_image2darraymsaadepth", // PRIMITIVE_IMAGE_2D_ARRAY_MSAA_DEPTH_T
+    "16ocl_image2ddepth",          // PRIMITIVE_IMAGE_2D_DEPTH_T
+    "21ocl_image2darraydepth",     // PRIMITIVE_IMAGE_2D_ARRAY_DEPTH_T
+    "13ocl_imagecube",             // PRIMITIVE_IMAGE_CUBE_T
+    "18ocl_imagecubearray",        // PRIMITIVE_IMAGE_CUBE_ARRAY_T
+    "18ocl_imagecubedepth",        // PRIMITIVE_IMAGE_CUBE_DEPTH_T
+    "23ocl_imagecubearraydepth",   // PRIMITIVE_IMAGE_CUBE_ARRAY_DEPTH_T
+	// <-- for libfloor Vulkan/OpenCL
     "9ocl_event",                        // PRIMITIVE_EVENT_T
     "11ocl_pipe_ro",                     // PRIMITIVE_PIPE_RO_T
     "11ocl_pipe_wo",                     // PRIMITIVE_PIPE_WO_T
@@ -235,6 +271,24 @@ static const SPIRversion PrimitiveSupportedVersions[PRIMITIVE_NUM] = {
     SPIR12, // PRIMITIVE_IMAGE2D_MSAA_DEPTH_RW_T
     SPIR12, // PRIMITIVE_IMAGE2D_ARRAY_MSAA_DEPTH_RW_T
     SPIR12, // PRIMITIVE_IMAGE3D_RW_T
+	// --> for libfloor Vulkan/OpenCL
+    SPIR12, // PRIMITIVE_IMAGE_1D_T
+    SPIR12, // PRIMITIVE_IMAGE_1D_ARRAY_T
+    SPIR12, // PRIMITIVE_IMAGE_1D_BUFFER_T
+    SPIR12, // PRIMITIVE_IMAGE_2D_T
+    SPIR12, // PRIMITIVE_IMAGE_2D_ARRAY_T
+    SPIR12, // PRIMITIVE_IMAGE_3D_T
+    SPIR12, // PRIMITIVE_IMAGE_2D_MSAA_T
+    SPIR12, // PRIMITIVE_IMAGE_2D_ARRAY_MSAA_T
+    SPIR12, // PRIMITIVE_IMAGE_2D_MSAA_DEPTH_T
+    SPIR12, // PRIMITIVE_IMAGE_2D_ARRAY_MSAA_DEPTH_T
+    SPIR12, // PRIMITIVE_IMAGE_2D_DEPTH_T
+    SPIR12, // PRIMITIVE_IMAGE_2D_ARRAY_DEPTH_T
+    SPIR20, // PRIMITIVE_IMAGE_CUBE_T
+    SPIR20, // PRIMITIVE_IMAGE_CUBE_ARRAY_T
+    SPIR20, // PRIMITIVE_IMAGE_CUBE_DEPTH_T
+    SPIR20, // PRIMITIVE_IMAGE_CUBE_ARRAY_DEPTH_T
+	// <-- for libfloor Vulkan/OpenCL
     SPIR12, // PRIMITIVE_EVENT_T
     SPIR20, // PRIMITIVE_PIPE_RO_T
     SPIR20, // PRIMITIVE_PIPE_WO_T
diff --git a/lib/SPIRV/Mangler/ParameterType.h b/lib/SPIRV/Mangler/ParameterType.h
index cd05954..b39e799 100644
--- a/lib/SPIRV/Mangler/ParameterType.h
+++ b/lib/SPIRV/Mangler/ParameterType.h
@@ -84,6 +84,24 @@ enum TypePrimitiveEnum {
   PRIMITIVE_IMAGE2D_MSAA_DEPTH_RW_T,
   PRIMITIVE_IMAGE2D_ARRAY_MSAA_DEPTH_RW_T,
   PRIMITIVE_IMAGE3D_RW_T,
+  // --> for libfloor Vulkan/OpenCL
+  PRIMITIVE_IMAGE_1D_T,
+  PRIMITIVE_IMAGE_1D_ARRAY_T,
+  PRIMITIVE_IMAGE_1D_BUFFER_T,
+  PRIMITIVE_IMAGE_2D_T,
+  PRIMITIVE_IMAGE_2D_ARRAY_T,
+  PRIMITIVE_IMAGE_3D_T,
+  PRIMITIVE_IMAGE_2D_MSAA_T,
+  PRIMITIVE_IMAGE_2D_ARRAY_MSAA_T,
+  PRIMITIVE_IMAGE_2D_MSAA_DEPTH_T,
+  PRIMITIVE_IMAGE_2D_ARRAY_MSAA_DEPTH_T,
+  PRIMITIVE_IMAGE_2D_DEPTH_T,
+  PRIMITIVE_IMAGE_2D_ARRAY_DEPTH_T,
+  PRIMITIVE_IMAGE_CUBE_T,
+  PRIMITIVE_IMAGE_CUBE_ARRAY_T,
+  PRIMITIVE_IMAGE_CUBE_DEPTH_T,
+  PRIMITIVE_IMAGE_CUBE_ARRAY_DEPTH_T,
+  // <-- for libfloor Vulkan/OpenCL
   PRIMITIVE_EVENT_T,
   PRIMITIVE_PIPE_RO_T,
   PRIMITIVE_PIPE_WO_T,
diff --git a/lib/SPIRV/OCLToSPIRV.cpp b/lib/SPIRV/OCLToSPIRV.cpp
index 3e7f149..c731be7 100644
--- a/lib/SPIRV/OCLToSPIRV.cpp
+++ b/lib/SPIRV/OCLToSPIRV.cpp
@@ -41,6 +41,8 @@
 #include "OCLTypeToSPIRV.h"
 #include "OCLUtil.h"
 #include "SPIRVInternal.h"
+#include "SPIRVFunction.h"
+#include "SPIRVInstruction.h"
 #include "libSPIRV/SPIRVDebug.h"
 
 #include "llvm/ADT/StringSwitch.h"
@@ -193,6 +195,9 @@ public:
   ///   return __spirv_ImageSampleExplicitLod_R{ReturnType}(sampled_image, ...);
   void visitCallReadImageWithSampler(CallInst *CI, StringRef MangledName);
 
+  void visitCallReadImageWithSamplerShader(CallInst *CI, StringRef MangledName,
+                                           const std::string &DemangledName);
+
   /// Transform read_image with msaa image arguments.
   /// Sample argument must be acoded as Image Operand.
   void visitCallReadImageMSAA(CallInst *CI, StringRef MangledName);
@@ -200,6 +205,9 @@ public:
   /// Transform {read|write}_image without sampler arguments.
   void visitCallReadWriteImage(CallInst *CI, StringRef DemangledName);
 
+  void visitCallWriteImageShader(CallInst *CI, StringRef MangledName,
+                                 const std::string &DemangledName);
+
   /// Transform to_{global|local|private}.
   ///
   /// T* a = ...;
@@ -272,6 +280,7 @@ private:
   Module *M;
   LLVMContext *Ctx;
   unsigned CLVer; /// OpenCL version as major*10+minor
+  spv::SourceLanguage SrcLang;
   std::set<Value *> ValuesToDelete;
   OCLTypeToSPIRVBase *OCLTypeToSPIRVPtr;
 
@@ -356,17 +365,34 @@ bool OCLToSPIRVBase::runOCLToSPIRV(Module &Module) {
   M = &Module;
   Ctx = &M->getContext();
   auto Src = getSPIRVSource(&Module);
+  SrcLang = (spv::SourceLanguage)std::get<0>(Src);
   // This is a pre-processing pass, which transform LLVM IR module to a more
-  // suitable form for the SPIR-V translation: it is specifically designed to
-  // handle OpenCL C built-in functions and shouldn't be launched for other
-  // source languages
-  if (std::get<0>(Src) != spv::SourceLanguageOpenCL_C)
+  // suitable form for the SPIR-V translation
+  if (SrcLang != spv::SourceLanguageOpenCL_C &&
+      SrcLang != spv::SourceLanguageGLSL)
     return false;
 
   CLVer = std::get<1>(Src);
 
   LLVM_DEBUG(dbgs() << "Enter OCLToSPIRV:\n");
 
+  // language specific handling
+  if (SrcLang == spv::SourceLanguageGLSL) {
+    // as of now, Vulkan/SPIR-V/GLSL doesn't know constant/UniformConstant
+    // values/object, so replace all uses of the constant address space with the
+    // Function storage class
+    // NOTE: SPIRVWriter will also move all global constant vars to the inside
+    // of their respective functions (users)
+    SPIRSPIRVAddrSpaceMap::replace(SPIRAS_Constant, StorageClassFunction);
+
+    // add shader image caps
+    SPIRVImageInstBase::addCap(spv::CapabilityShader);
+    SPIRVImageQueryInstBase::addCap(spv::CapabilityImageQuery);
+  } else {
+    // set kernel image caps
+    SPIRVImageInstBase::addCap(spv::CapabilityImageBasic);
+  }
+
   transWorkItemBuiltinsToVariables();
 
   visit(*M);
@@ -422,8 +448,10 @@ void OCLToSPIRVBase::visitCallInst(CallInst &CI) {
       DemangledName.find(kOCLBuiltinName::AtomPrefix) == 0) {
 
     // Compute atomic builtins do not support floating types.
+    // NOTE: allowing this for Vulkan
     if (CI.getType()->isFloatingPointTy() &&
-        isComputeAtomicOCLBuiltin(DemangledName))
+        isComputeAtomicOCLBuiltin(DemangledName) &&
+        SrcLang != spv::SourceLanguageGLSL)
       return;
 
     auto PCI = &CI;
@@ -475,7 +503,11 @@ void OCLToSPIRVBase::visitCallInst(CallInst &CI) {
   }
   if (DemangledName.find(kOCLBuiltinName::ReadImage) == 0) {
     if (MangledName.find(kMangledName::Sampler) != StringRef::npos) {
-      visitCallReadImageWithSampler(&CI, MangledName);
+      if (SrcLang != spv::SourceLanguageGLSL) {
+        visitCallReadImageWithSampler(&CI, MangledName);
+      } else {
+        visitCallReadImageWithSamplerShader(&CI, MangledName, DemangledName.str());
+      }
       return;
     }
     if (MangledName.find("msaa") != StringRef::npos) {
@@ -485,7 +517,12 @@ void OCLToSPIRVBase::visitCallInst(CallInst &CI) {
   }
   if (DemangledName.find(kOCLBuiltinName::ReadImage) == 0 ||
       DemangledName.find(kOCLBuiltinName::WriteImage) == 0) {
-    visitCallReadWriteImage(&CI, DemangledName);
+    if (SrcLang != spv::SourceLanguageGLSL) {
+      visitCallReadWriteImage(&CI, DemangledName);
+    } else {
+      assert(DemangledName.find(kOCLBuiltinName::ReadImage) == std::string::npos && "should not be here");
+      visitCallWriteImageShader(&CI, MangledName, DemangledName.str());
+    }
     return;
   }
   if (DemangledName == kOCLBuiltinName::ToGlobal ||
@@ -524,6 +561,7 @@ void OCLToSPIRVBase::visitCallInst(CallInst &CI) {
   }
   if (DemangledName == kOCLBuiltinName::FMin ||
       DemangledName == kOCLBuiltinName::FMax ||
+      DemangledName == kOCLBuiltinName::FMod ||
       DemangledName == kOCLBuiltinName::Min ||
       DemangledName == kOCLBuiltinName::Max ||
       DemangledName == kOCLBuiltinName::Step ||
@@ -841,10 +879,23 @@ void OCLToSPIRVBase::transAtomicBuiltin(CallInst *CI,
       M, CI,
       [=](CallInst *CI, std::vector<Value *> &Args) {
         Info.PostProc(Args);
+
+        // rename atomic functions if necessary
+        std::string atom_func_name = Info.UniqName;
+        if (CI->getCalledFunction()->getReturnType()->isFloatTy()) {
+          if (atom_func_name == "atom_add") {
+            atom_func_name = "atom_fadd";
+          } else if (atom_func_name == "atomic_add") {
+            atom_func_name = "atomic_fadd";
+          } else if (atom_func_name == "atomic_fetch_add_explicit") {
+            atom_func_name = "atomic_fetch_fadd_explicit";
+          }
+        }
+
         // Order of args in OCL20:
         // object, 0-2 other args, 1-2 order, scope
         const size_t NumOrder =
-            getAtomicBuiltinNumMemoryOrderArgs(Info.UniqName);
+            getAtomicBuiltinNumMemoryOrderArgs(atom_func_name);
         const size_t ArgsCount = Args.size();
         const size_t ScopeIdx = ArgsCount - 1;
         const size_t OrderIdx = ScopeIdx - NumOrder;
@@ -853,8 +904,46 @@ void OCLToSPIRVBase::transAtomicBuiltin(CallInst *CI,
             transOCLMemScopeIntoSPIRVScope(Args[ScopeIdx], OCLMS_device, CI);
 
         for (size_t I = 0; I < NumOrder; ++I) {
-          Args[OrderIdx + I] = transOCLMemOrderIntoSPIRVMemorySemantics(
-              Args[OrderIdx + I], OCLMO_seq_cst, CI);
+          if (SrcLang == spv::SourceLanguageGLSL) {
+            Args[OrderIdx + I] = mapUInt(M, cast<ConstantInt>(Args[OrderIdx + I]),
+              [&Args, this](unsigned Ord) {
+                // add Vulkan/GLSL specific memory semantics
+                spv::MemorySemanticsMask memsem = spv::MemorySemanticsMaskNone;
+                if (SrcLang == spv::SourceLanguageGLSL) {
+                  switch (
+                      SPIRSPIRVAddrSpaceMap::map(static_cast<SPIRAddressSpace>(
+                          Args[0]->getType()->getPointerAddressSpace()))) {
+                  case spv::StorageClassUniform:
+                    memsem = spv::MemorySemanticsUniformMemoryMask;
+                    break;
+                  // TODO: no sub-group storage class? handled differently?
+                  case spv::StorageClassWorkgroup:
+                    memsem = spv::MemorySemanticsWorkgroupMemoryMask;
+                    break;
+                  case spv::StorageClassStorageBuffer:
+                  case spv::StorageClassCrossWorkgroup:
+                    memsem = spv::MemorySemanticsCrossWorkgroupMemoryMask;
+                    break;
+                  case spv::StorageClassAtomicCounter:
+                    memsem = spv::MemorySemanticsAtomicCounterMemoryMask;
+                    break;
+                  case spv::StorageClassImage:
+                    memsem = spv::MemorySemanticsImageMemoryMask;
+                    break;
+                  default:
+                    break;
+                  }
+                  // SequentiallyConsistent memory order is not supported -> use AcquireRelease
+                  if (Ord == OCLMO_seq_cst) {
+                    Ord = OCLMO_acq_rel;
+                  }
+                }
+                return mapOCLMemSemanticToSPIRV(0, static_cast<OCLMemOrderKind>(Ord)) | memsem;
+              });
+          } else {
+            Args[OrderIdx + I] = transOCLMemOrderIntoSPIRVMemorySemantics(
+                Args[OrderIdx + I], OCLMO_seq_cst, CI);
+          }
         }
         // Order of args in SPIR-V:
         // object, scope, 1-2 order, 0-2 other args
@@ -864,11 +953,11 @@ void OCLToSPIRVBase::transAtomicBuiltin(CallInst *CI,
           // argument just where it should be, so don't move the last argument
           // then.
           int Offset =
-              Info.UniqName.find("atomic_compare_exchange") == 0 ? 1 : 0;
+              atom_func_name.find("atomic_compare_exchange") == 0 ? 1 : 0;
           std::rotate(Args.begin() + 2, Args.begin() + OrderIdx,
                       Args.end() - Offset);
         }
-        return getSPIRVFuncName(OCLSPIRVBuiltinMap::map(Info.UniqName));
+        return getSPIRVFuncName(OCLSPIRVBuiltinMap::map(atom_func_name));
       },
       &Attrs);
 }
@@ -888,7 +977,9 @@ void OCLToSPIRVBase::visitCallBarrier(CallInst *CI) {
         // But if the flags argument is set to 0, we use
         // None(Relaxed) memory order.
         unsigned MemFenceFlag = std::get<0>(Lit);
-        OCLMemOrderKind MemOrder = MemFenceFlag ? OCLMO_seq_cst : OCLMO_relaxed;
+        // NOTE: we can not use OCLMO_seq_cst with Vulkan memory model
+        OCLMemOrderKind MemOrder = MemFenceFlag && SrcLang != spv::SourceLanguageGLSL ?
+            OCLMO_seq_cst : OCLMO_relaxed;
         Args[2] = addInt32(mapOCLMemSemanticToSPIRV(
             MemFenceFlag, MemOrder)); // Memory semantics
         return getSPIRVFuncName(OpControlBarrier);
@@ -1061,6 +1152,9 @@ void OCLToSPIRVBase::transBuiltin(CallInst *CI, OCLBuiltinTransInfo &Info) {
   AttributeList Attrs = CI->getCalledFunction()->getAttributes();
   Op OC = OpNop;
   unsigned ExtOp = ~0U;
+  const auto ext_kind =
+      (SrcLang == spv::SourceLanguageOpenCL_C ? SPIRVEIS_OpenCL
+                                              : SPIRVEIS_GLSL);
   if (StringRef(Info.UniqName).startswith(kSPIRVName::Prefix))
     return;
   if (OCLSPIRVBuiltinMap::find(Info.UniqName, &OC)) {
@@ -1079,8 +1173,8 @@ void OCLToSPIRVBase::transBuiltin(CallInst *CI, OCLBuiltinTransInfo &Info) {
     } else {
       Info.UniqName = getSPIRVFuncName(OC);
     }
-  } else if ((ExtOp = getExtOp(Info.MangledName, Info.UniqName)) != ~0U)
-    Info.UniqName = getSPIRVExtFuncName(SPIRVEIS_OpenCL, ExtOp);
+  } else if ((ExtOp = getExtOp(Info.MangledName, Info.UniqName, ext_kind)) != ~0U)
+    Info.UniqName = getSPIRVExtFuncName(ext_kind, ExtOp);
   else
     return;
   if (!Info.RetTy)
@@ -1180,6 +1274,12 @@ void OCLToSPIRVBase::visitCallReadImageWithSampler(CallInst *CI,
       &Attrs);
 }
 
+void OCLToSPIRVBase::visitCallReadImageWithSamplerShader(
+    CallInst *CI, StringRef MangledName, const std::string &DemangledName) {
+  // NOTE: we'll be handling this in SPIRVWriter, not here, because we need
+  // information that is only available there
+}
+
 void OCLToSPIRVBase::visitCallGetImageSize(CallInst *CI,
                                            StringRef DemangledName) {
   AttributeList Attrs = CI->getCalledFunction()->getAttributes();
@@ -1195,7 +1295,7 @@ void OCLToSPIRVBase::visitCallGetImageSize(CallInst *CI,
   mutateCallInstSPIRV(
       M, CI,
       [&](CallInst *, std::vector<Value *> &Args, Type *&Ret) {
-        assert(Args.size() == 1);
+        assert(Args.size() == 1 || (Args.size() == 2 && SrcLang == spv::SourceLanguageGLSL));
         Ret = CI->getType()->isIntegerTy(64) ? Type::getInt64Ty(*Ctx)
                                              : Type::getInt32Ty(*Ctx);
         if (Dim > 1)
@@ -1203,7 +1303,9 @@ void OCLToSPIRVBase::visitCallGetImageSize(CallInst *CI,
         if (Desc.Dim == DimBuffer)
           return getSPIRVFuncName(OpImageQuerySize, CI->getType());
         else {
-          Args.push_back(getInt32(M, 0));
+          if (Args.size() == 1) {
+            Args.push_back(getInt32(M, 0));
+          }
           return getSPIRVFuncName(OpImageQuerySizeLod, CI->getType());
         }
       },
@@ -1349,6 +1451,13 @@ void OCLToSPIRVBase::visitCallReadWriteImage(CallInst *CI,
   transBuiltin(CI, Info);
 }
 
+void OCLToSPIRVBase::visitCallWriteImageShader(CallInst *CI,
+                                               StringRef MangledName,
+                                               const std::string &DemangledName) {
+  // NOTE: we'll be handling this in SPIRVWriter, not here, because we need
+  // information that is only available there
+}
+
 void OCLToSPIRVBase::visitCallToAddr(CallInst *CI, StringRef DemangledName) {
   auto AddrSpace =
       static_cast<SPIRAddressSpace>(CI->getType()->getPointerAddressSpace());
@@ -1490,6 +1599,7 @@ void OCLToSPIRVBase::visitCallScalToVec(CallInst *CI, StringRef MangledName,
   std::vector<unsigned int> ScalarPos;
   if (DemangledName == kOCLBuiltinName::FMin ||
       DemangledName == kOCLBuiltinName::FMax ||
+      DemangledName == kOCLBuiltinName::FMod ||
       DemangledName == kOCLBuiltinName::Min ||
       DemangledName == kOCLBuiltinName::Max) {
     VecPos.push_back(0);
@@ -1512,6 +1622,9 @@ void OCLToSPIRVBase::visitCallScalToVec(CallInst *CI, StringRef MangledName,
   }
 
   AttributeList Attrs = CI->getCalledFunction()->getAttributes();
+  const auto ext_kind =
+      (SrcLang == spv::SourceLanguageOpenCL_C ? SPIRVEIS_OpenCL
+                                              : SPIRVEIS_GLSL);
   mutateCallInstSPIRV(
       M, CI,
       [=](CallInst *, std::vector<Value *> &Args) {
@@ -1532,8 +1645,8 @@ void OCLToSPIRVBase::visitCallScalToVec(CallInst *CI, StringRef MangledName,
 
           Args[I] = NewVec;
         }
-        return getSPIRVExtFuncName(SPIRVEIS_OpenCL,
-                                   getExtOp(MangledName, DemangledName));
+        return getSPIRVExtFuncName(ext_kind,
+                                   getExtOp(MangledName, DemangledName, ext_kind));
       },
       &Attrs);
 }
@@ -1616,7 +1729,7 @@ void OCLToSPIRVBase::visitCallEnqueueKernel(CallInst *CI,
       FunctionType::get(CI->getType(), getTypes(Args), false /*isVarArg*/);
   Function *NewF =
       Function::Create(FT, GlobalValue::ExternalLinkage, NewName, M);
-  NewF->setCallingConv(CallingConv::SPIR_FUNC);
+  NewF->setCallingConv(CallingConv::FLOOR_FUNC);
   CallInst *NewCall = CallInst::Create(NewF, Args, "", CI);
   NewCall->setCallingConv(NewF->getCallingConv());
   CI->replaceAllUsesWith(NewCall);
@@ -1919,9 +2032,9 @@ void OCLToSPIRVBase::visitSubgroupAVCBuiltinCallWithSampler(
 } // namespace SPIRV
 
 INITIALIZE_PASS_BEGIN(OCLToSPIRVLegacy, "ocl-to-spv",
-                      "Transform OCL 2.0 to SPIR-V", false, false)
+                      "Transform OCL 2.0 / GLSL to SPIR-V", false, false)
 INITIALIZE_PASS_DEPENDENCY(OCLTypeToSPIRVLegacy)
 INITIALIZE_PASS_END(OCLToSPIRVLegacy, "ocl-to-spv",
-                    "Transform OCL 2.0 to SPIR-V", false, false)
+                    "Transform OCL 2.0 / GLSL to SPIR-V", false, false)
 
 ModulePass *llvm::createOCLToSPIRVLegacy() { return new OCLToSPIRVLegacy(); }
diff --git a/lib/SPIRV/OCLTypeToSPIRV.cpp b/lib/SPIRV/OCLTypeToSPIRV.cpp
index 5ad8075..d39d7a6 100644
--- a/lib/SPIRV/OCLTypeToSPIRV.cpp
+++ b/lib/SPIRV/OCLTypeToSPIRV.cpp
@@ -111,6 +111,10 @@ void OCLTypeToSPIRVBase::addAdaptedType(Value *V, Type *T) {
   AdaptedTy[V] = T;
 }
 
+void OCLTypeToSPIRVBase::addAdaptedType(Argument &A, Type *T) {
+  addAdaptedType(&A, T);
+}
+
 void OCLTypeToSPIRVBase::addWork(Function *F) {
   LLVM_DEBUG(dbgs() << "[add work] "; F->printAsOperand(dbgs(), true, M);
              dbgs() << '\n');
diff --git a/lib/SPIRV/OCLTypeToSPIRV.h b/lib/SPIRV/OCLTypeToSPIRV.h
index 68df6f0..d3f1b16 100644
--- a/lib/SPIRV/OCLTypeToSPIRV.h
+++ b/lib/SPIRV/OCLTypeToSPIRV.h
@@ -77,6 +77,7 @@ private:
   void adaptArgumentsBySamplerUse(Module &M);
   void adaptFunction(Function *F);
   void addAdaptedType(Value *V, Type *T);
+  void addAdaptedType(Argument &A, Type *T);
   void addWork(Function *F);
 };
 
diff --git a/lib/SPIRV/OCLUtil.cpp b/lib/SPIRV/OCLUtil.cpp
index 87f6482..552aef5 100644
--- a/lib/SPIRV/OCLUtil.cpp
+++ b/lib/SPIRV/OCLUtil.cpp
@@ -194,6 +194,11 @@ template <> void SPIRVMap<OclExt::Kind, std::string>::init() {
   _SPIRV_OP(cl_khr_mipmap_image_writes)
   _SPIRV_OP(cl_khr_egl_event)
   _SPIRV_OP(cl_khr_srgb_image_writes)
+  _SPIRV_OP(vk_capability_int16)
+  _SPIRV_OP(vk_capability_int64)
+  _SPIRV_OP(vk_capability_float16)
+  _SPIRV_OP(vk_capability_float64)
+  _SPIRV_OP(vk_capability_multiview)
 #undef _SPIRV_OP
 }
 
@@ -206,6 +211,11 @@ template <> void SPIRVMap<OclExt::Kind, SPIRVCapabilityKind>::init() {
   add(OclExt::cl_khr_subgroups, CapabilityGroups);
   add(OclExt::cl_khr_mipmap_image, CapabilityImageMipmap);
   add(OclExt::cl_khr_mipmap_image_writes, CapabilityImageMipmap);
+  add(OclExt::vk_capability_int16, CapabilityInt16);
+  add(OclExt::vk_capability_int64, CapabilityInt64);
+  add(OclExt::vk_capability_float16, CapabilityFloat16);
+  add(OclExt::vk_capability_float64, CapabilityFloat64);
+  add(OclExt::vk_capability_multiview, CapabilityMultiView);
 }
 
 /// Map OpenCL work functions to SPIR-V builtin variables.
@@ -245,6 +255,8 @@ template <> void SPIRVMap<std::string, SPIRVBuiltinVariableKind>::init() {
 class SPIRVInstruction;
 template <> void SPIRVMap<std::string, Op, SPIRVInstruction>::init() {
 #define _SPIRV_OP(x, y) add("atom_" #x, OpAtomic##y);
+  // Vulkan float32/float64 atomic add
+  _SPIRV_OP(fadd, FAddEXT)
   // cl_khr_int64_base_atomics builtins
   _SPIRV_OP(add, IAdd)
   _SPIRV_OP(sub, ISub)
@@ -270,6 +282,8 @@ template <> void SPIRVMap<std::string, Op, SPIRVInstruction>::init() {
   _SPIRV_OP(compare_exchange_weak_explicit, AtomicCompareExchangeWeak)
   _SPIRV_OP(inc, AtomicIIncrement)
   _SPIRV_OP(dec, AtomicIDecrement)
+  // Vulkan float32/float64 atomic add
+  _SPIRV_OP(fetch_fadd_explicit, AtomicFAddEXT)
   _SPIRV_OP(fetch_add_explicit, AtomicIAdd)
   _SPIRV_OP(fetch_sub_explicit, AtomicISub)
   _SPIRV_OP(fetch_umin_explicit, AtomicUMin)
@@ -368,6 +382,8 @@ template <> void SPIRVMap<std::string, Op, SPIRVInstruction>::init() {
   _SPIRV_OP(get_image_channel_order, ImageQueryOrder)
   _SPIRV_OP(get_image_num_mip_levels, ImageQueryLevels)
   _SPIRV_OP(get_image_num_samples, ImageQuerySamples)
+  // GLSL or standard SPIR-V (TODO: how to ignore these for OpenCL?)
+  _SPIRV_OP(fmod, FMod)
   // Intel Subgroups builtins
   _SPIRV_OP(intel_sub_group_shuffle, SubgroupShuffleINTEL)
   _SPIRV_OP(intel_sub_group_shuffle_down, SubgroupShuffleDownINTEL)
@@ -661,6 +677,7 @@ bool isComputeAtomicOCLBuiltin(StringRef DemangledName) {
     return false;
 
   return llvm::StringSwitch<bool>(DemangledName)
+      .EndsWith("fadd", true)
       .EndsWith("add", true)
       .EndsWith("sub", true)
       .EndsWith("inc", true)
@@ -671,6 +688,7 @@ bool isComputeAtomicOCLBuiltin(StringRef DemangledName) {
       .EndsWith("and", true)
       .EndsWith("or", true)
       .EndsWith("xor", true)
+      .EndsWith("fadd_explicit", true)
       .EndsWith("add_explicit", true)
       .EndsWith("sub_explicit", true)
       .EndsWith("or_explicit", true)
@@ -703,34 +721,62 @@ BarrierLiterals getBarrierLiterals(CallInst *CI) {
                          Scope);
 }
 
-unsigned getExtOp(StringRef OrigName, StringRef GivenDemangledName) {
+unsigned getExtOp(StringRef OrigName, StringRef GivenDemangledName,
+                  SPIRVExtInstSetKind ext_kind) {
   std::string DemangledName{GivenDemangledName};
   if (DemangledName.empty() || !oclIsBuiltin(OrigName, GivenDemangledName))
     return ~0U;
   LLVM_DEBUG(dbgs() << "getExtOp: demangled name: " << DemangledName << '\n');
-  OCLExtOpKind EOC;
-  bool Found = OCLExtOpMap::rfind(DemangledName, &EOC);
-  if (!Found) {
-    std::string Prefix;
-    switch (lastFuncParamType(OrigName)) {
-    case ParamType::UNSIGNED:
-      Prefix = "u_";
-      break;
-    case ParamType::SIGNED:
-      Prefix = "s_";
-      break;
-    case ParamType::FLOAT:
-      Prefix = "f";
-      break;
-    case ParamType::UNKNOWN:
-      break;
+  if (ext_kind == SPIRVExtInstSetKind::SPIRVEIS_OpenCL) {
+    OCLExtOpKind EOC;
+    bool Found = OCLExtOpMap::rfind(DemangledName, &EOC);
+    if (!Found) {
+      std::string Prefix;
+      switch (lastFuncParamType(OrigName)) {
+      case ParamType::UNSIGNED:
+        Prefix = "u_";
+        break;
+      case ParamType::SIGNED:
+        Prefix = "s_";
+        break;
+      case ParamType::FLOAT:
+        Prefix = "f";
+        break;
+      case ParamType::UNKNOWN:
+        break;
+      }
+      Found = OCLExtOpMap::rfind(Prefix + DemangledName, &EOC);
+    }
+    if (Found)
+      return EOC;
+    else
+      return ~0U;
+  } else if (ext_kind == SPIRVExtInstSetKind::SPIRVEIS_GLSL) {
+    GLSLExtOpKind EGLSL;
+    bool Found = GLSLExtOpMap::rfind(DemangledName, &EGLSL);
+    if (!Found) {
+      std::string Prefix;
+      switch (lastFuncParamType(OrigName)) {
+      case ParamType::UNSIGNED:
+        Prefix = "u_";
+        break;
+      case ParamType::SIGNED:
+        Prefix = "s_";
+        break;
+      case ParamType::FLOAT:
+        Prefix = "f";
+        break;
+      default:
+        llvm_unreachable("unknown mangling!");
+      }
+      Found = GLSLExtOpMap::rfind(Prefix + DemangledName, &EGLSL);
     }
-    Found = OCLExtOpMap::rfind(Prefix + DemangledName, &EOC);
+    if (Found)
+      return EGLSL;
+    else
+      return ~0U;
   }
-  if (Found)
-    return EOC;
-  else
-    return ~0U;
+  llvm_unreachable("invalid ext set");
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -945,6 +991,24 @@ getOCLOpaqueTypeAddrSpace(SPIR::TypePrimitiveEnum Prim) {
   case SPIR::PRIMITIVE_IMAGE2D_MSAA_DEPTH_RW_T:
   case SPIR::PRIMITIVE_IMAGE2D_ARRAY_MSAA_DEPTH_RW_T:
   case SPIR::PRIMITIVE_IMAGE3D_RW_T:
+  // --> for libfloor Vulkan/OpenCL
+  case SPIR::PRIMITIVE_IMAGE_1D_T:
+  case SPIR::PRIMITIVE_IMAGE_1D_ARRAY_T:
+  case SPIR::PRIMITIVE_IMAGE_1D_BUFFER_T:
+  case SPIR::PRIMITIVE_IMAGE_2D_T:
+  case SPIR::PRIMITIVE_IMAGE_2D_ARRAY_T:
+  case SPIR::PRIMITIVE_IMAGE_3D_T:
+  case SPIR::PRIMITIVE_IMAGE_2D_MSAA_T:
+  case SPIR::PRIMITIVE_IMAGE_2D_ARRAY_MSAA_T:
+  case SPIR::PRIMITIVE_IMAGE_2D_MSAA_DEPTH_T:
+  case SPIR::PRIMITIVE_IMAGE_2D_ARRAY_MSAA_DEPTH_T:
+  case SPIR::PRIMITIVE_IMAGE_2D_DEPTH_T:
+  case SPIR::PRIMITIVE_IMAGE_2D_ARRAY_DEPTH_T:
+  case SPIR::PRIMITIVE_IMAGE_CUBE_T:
+  case SPIR::PRIMITIVE_IMAGE_CUBE_ARRAY_T:
+  case SPIR::PRIMITIVE_IMAGE_CUBE_DEPTH_T:
+  case SPIR::PRIMITIVE_IMAGE_CUBE_ARRAY_DEPTH_T:
+  // <-- for libfloor Vulkan/OpenCL
     return mapAddrSpaceEnums(SPIRV_IMAGE_ADDR_SPACE);
   default:
     llvm_unreachable("No address space is determined for a SPIR primitive");
diff --git a/lib/SPIRV/OCLUtil.h b/lib/SPIRV/OCLUtil.h
index f420240..2e05bcf 100644
--- a/lib/SPIRV/OCLUtil.h
+++ b/lib/SPIRV/OCLUtil.h
@@ -94,11 +94,11 @@ enum OCLScopeKind {
 // To avoid any inconsistence here, constants are explicitly initialized with
 // the corresponding constants from 'std::memory_order' enum.
 enum OCLMemOrderKind {
-  OCLMO_relaxed = std::memory_order::memory_order_relaxed,
-  OCLMO_acquire = std::memory_order::memory_order_acquire,
-  OCLMO_release = std::memory_order::memory_order_release,
-  OCLMO_acq_rel = std::memory_order::memory_order_acq_rel,
-  OCLMO_seq_cst = std::memory_order::memory_order_seq_cst
+  OCLMO_relaxed = (uint32_t)std::memory_order_relaxed,
+  OCLMO_acquire = (uint32_t)std::memory_order_acquire,
+  OCLMO_release = (uint32_t)std::memory_order_release,
+  OCLMO_acq_rel = (uint32_t)std::memory_order_acq_rel,
+  OCLMO_seq_cst = (uint32_t)std::memory_order_seq_cst
 };
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -240,6 +240,7 @@ const static char FixedLogINTEL[] = "intel_arbitrary_fixed_log";
 const static char FixedExpINTEL[] = "intel_arbitrary_fixed_exp";
 const static char FMax[] = "fmax";
 const static char FMin[] = "fmin";
+const static char FMod[] = "fmod";
 const static char FPGARegIntel[] = "__builtin_intel_fpga_reg";
 const static char GetFence[] = "get_fence";
 const static char GetImageArraySize[] = "get_image_array_size";
@@ -353,6 +354,11 @@ enum Kind {
   _SPIRV_OP(cl_khr_mipmap_image_writes)
   _SPIRV_OP(cl_khr_egl_event)
   _SPIRV_OP(cl_khr_srgb_image_writes)
+  _SPIRV_OP(vk_capability_int16)
+  _SPIRV_OP(vk_capability_int64)
+  _SPIRV_OP(vk_capability_float16)
+  _SPIRV_OP(vk_capability_float64)
+  _SPIRV_OP(vk_capability_multiview)
 #undef _SPIRV_OP
 };
 // clang-format on
@@ -374,12 +380,14 @@ const static char TypePrefix[] = "opencl.intel_sub_group_avc_";
 
 /// Get instruction index for SPIR-V extended instruction for OpenCL.std
 ///   extended instruction set.
-/// \param MangledName The mangled name of OpenCL builtin function.
-/// \param DemangledName The demangled name of OpenCL builtin function if
+/// \param MangledName The mangled name of OpenCL/GLSL builtin function.
+/// \param DemangledName The demangled name of OpenCL/GLSL builtin function if
 ///   not empty.
-/// \return instruction index of extended instruction if the OpenCL builtin
-///   function is translated to an extended instruction, otherwise ~0U.
-unsigned getExtOp(StringRef MangledName, StringRef DemangledName = "");
+/// \param ext_kind the extended instruction set kind that should be used
+/// \return instruction index of extended instruction if the OpenCL/GLSL
+///   builtin function is translated to an extended instruction, otherwise ~0U.
+unsigned getExtOp(StringRef MangledName, StringRef DemangledName,
+                  SPIRVExtInstSetKind ext_kind);
 
 /// Get literal arguments of call of atomic_work_item_fence.
 AtomicWorkItemFenceLiterals getAtomicWorkItemFenceLiterals(CallInst *CI);
diff --git a/lib/SPIRV/PreprocessMetadata.cpp b/lib/SPIRV/PreprocessMetadata.cpp
index d28fd10..69540c8 100644
--- a/lib/SPIRV/PreprocessMetadata.cpp
+++ b/lib/SPIRV/PreprocessMetadata.cpp
@@ -144,6 +144,11 @@ void PreprocessMetadataBase::visit(Module *M) {
   SPIRVMDBuilder B(*M);
   SPIRVMDWalker W(*M);
 
+  Triple TT(M->getTargetTriple());
+  assert(isSupportedTriple(TT) && "Invalid triple");
+  const bool is_vulkan =
+      (TT.getEnvironment() == llvm::Triple::EnvironmentType::Vulkan);
+
   preprocessOCLMetadata(M, &B, &W);
   preprocessVectorComputeMetadata(M, &B, &W);
 
@@ -155,21 +160,29 @@ void PreprocessMetadataBase::visit(Module *M) {
   if (auto *GV = M->getGlobalVariable("llvm.global_ctors"))
     preprocessCXXStructorList(EM, GV, spv::ExecutionModeInitializer);
 
+  if (is_vulkan) {
+    // NOTE: don't want work-group size metadata here, this is already
+    // handled elsewhere
+    return;
+  }
+
   // Add execution modes for kernels. We take it from metadata attached to
   // the kernel functions.
-  for (Function &Kernel : *M) {
-    if (Kernel.getCallingConv() != CallingConv::SPIR_KERNEL)
+  for (Function &Func : *M) {
+    if (Func.getCallingConv() != CallingConv::FLOOR_KERNEL &&
+		Func.getCallingConv() != CallingConv::FLOOR_VERTEX &&
+		Func.getCallingConv() != CallingConv::FLOOR_FRAGMENT)
       continue;
 
     // Specifing execution modes for the Kernel and adding it to the list
     // of ExecutionMode instructions.
 
     // !{void (i32 addrspace(1)*)* @kernel, i32 17, i32 X, i32 Y, i32 Z}
-    if (MDNode *WGSize = Kernel.getMetadata(kSPIR2MD::WGSize)) {
+    if (MDNode *WGSize = Func.getMetadata(kSPIR2MD::WGSize)) {
       unsigned X, Y, Z;
       decodeMDNode(WGSize, X, Y, Z);
       EM.addOp()
-          .add(&Kernel)
+          .add(&Func)
           .add(spv::ExecutionModeLocalSize)
           .add(X)
           .add(Y)
@@ -178,11 +191,11 @@ void PreprocessMetadataBase::visit(Module *M) {
     }
 
     // !{void (i32 addrspace(1)*)* @kernel, i32 18, i32 X, i32 Y, i32 Z}
-    if (MDNode *WGSizeHint = Kernel.getMetadata(kSPIR2MD::WGSizeHint)) {
+    if (MDNode *WGSizeHint = Func.getMetadata(kSPIR2MD::WGSizeHint)) {
       unsigned X, Y, Z;
       decodeMDNode(WGSizeHint, X, Y, Z);
       EM.addOp()
-          .add(&Kernel)
+          .add(&Func)
           .add(spv::ExecutionModeLocalSizeHint)
           .add(X)
           .add(Y)
@@ -191,18 +204,18 @@ void PreprocessMetadataBase::visit(Module *M) {
     }
 
     // !{void (i32 addrspace(1)*)* @kernel, i32 30, i32 hint}
-    if (MDNode *VecTypeHint = Kernel.getMetadata(kSPIR2MD::VecTyHint)) {
+    if (MDNode *VecTypeHint = Func.getMetadata(kSPIR2MD::VecTyHint)) {
       EM.addOp()
-          .add(&Kernel)
+          .add(&Func)
           .add(spv::ExecutionModeVecTypeHint)
           .add(transVecTypeHint(VecTypeHint))
           .done();
     }
 
     // !{void (i32 addrspace(1)*)* @kernel, i32 35, i32 size}
-    if (MDNode *ReqdSubgroupSize = Kernel.getMetadata(kSPIR2MD::SubgroupSize)) {
+    if (MDNode *ReqdSubgroupSize = Func.getMetadata(kSPIR2MD::SubgroupSize)) {
       EM.addOp()
-          .add(&Kernel)
+          .add(&Func)
           .add(spv::ExecutionModeSubgroupSize)
           .add(getMDOperandAsInt(ReqdSubgroupSize, 0))
           .done();
@@ -211,11 +224,11 @@ void PreprocessMetadataBase::visit(Module *M) {
     // !{void (i32 addrspace(1)*)* @kernel, i32 max_work_group_size, i32 X,
     //         i32 Y, i32 Z}
     if (MDNode *MaxWorkgroupSizeINTEL =
-            Kernel.getMetadata(kSPIR2MD::MaxWGSize)) {
+            Func.getMetadata(kSPIR2MD::MaxWGSize)) {
       unsigned X, Y, Z;
       decodeMDNode(MaxWorkgroupSizeINTEL, X, Y, Z);
       EM.addOp()
-          .add(&Kernel)
+          .add(&Func)
           .add(spv::ExecutionModeMaxWorkgroupSizeINTEL)
           .add(X)
           .add(Y)
@@ -224,23 +237,23 @@ void PreprocessMetadataBase::visit(Module *M) {
     }
 
     // !{void (i32 addrspace(1)*)* @kernel, i32 no_global_work_offset}
-    if (Kernel.getMetadata(kSPIR2MD::NoGlobalOffset)) {
-      EM.addOp().add(&Kernel).add(spv::ExecutionModeNoGlobalOffsetINTEL).done();
+    if (Func.getMetadata(kSPIR2MD::NoGlobalOffset)) {
+      EM.addOp().add(&Func).add(spv::ExecutionModeNoGlobalOffsetINTEL).done();
     }
 
     // !{void (i32 addrspace(1)*)* @kernel, i32 max_global_work_dim, i32 dim}
-    if (MDNode *MaxWorkDimINTEL = Kernel.getMetadata(kSPIR2MD::MaxWGDim)) {
+    if (MDNode *MaxWorkDimINTEL = Func.getMetadata(kSPIR2MD::MaxWGDim)) {
       EM.addOp()
-          .add(&Kernel)
+          .add(&Func)
           .add(spv::ExecutionModeMaxWorkDimINTEL)
           .add(getMDOperandAsInt(MaxWorkDimINTEL, 0))
           .done();
     }
 
     // !{void (i32 addrspace(1)*)* @kernel, i32 num_simd_work_items, i32 num}
-    if (MDNode *NumSIMDWorkitemsINTEL = Kernel.getMetadata(kSPIR2MD::NumSIMD)) {
+    if (MDNode *NumSIMDWorkitemsINTEL = Func.getMetadata(kSPIR2MD::NumSIMD)) {
       EM.addOp()
-          .add(&Kernel)
+          .add(&Func)
           .add(spv::ExecutionModeNumSIMDWorkitemsINTEL)
           .add(getMDOperandAsInt(NumSIMDWorkitemsINTEL, 0))
           .done();
@@ -249,9 +262,9 @@ void PreprocessMetadataBase::visit(Module *M) {
     // !{void (i32 addrspace(1)*)* @kernel, i32 scheduler_target_fmax_mhz,
     //   i32 num}
     if (MDNode *SchedulerTargetFmaxMhzINTEL =
-            Kernel.getMetadata(kSPIR2MD::FmaxMhz)) {
+            Func.getMetadata(kSPIR2MD::FmaxMhz)) {
       EM.addOp()
-          .add(&Kernel)
+          .add(&Func)
           .add(spv::ExecutionModeSchedulerTargetFmaxMhzINTEL)
           .add(getMDOperandAsInt(SchedulerTargetFmaxMhzINTEL, 0))
           .done();
@@ -264,13 +277,23 @@ void PreprocessMetadataBase::preprocessOCLMetadata(Module *M, SPIRVMDBuilder *B,
   unsigned CLVer = getOCLVersion(M, true);
   if (CLVer == 0)
     return;
+
+  Triple TT(M->getTargetTriple());
+  assert(isSupportedTriple(TT) && "Invalid triple");
+  const bool is_vulkan =
+      (TT.getEnvironment() == llvm::Triple::EnvironmentType::Vulkan);
+  if (is_vulkan)
+    EraseOCLMD = true;
+
   // Preprocess OpenCL-specific metadata
   // !spirv.Source = !{!x}
   // !{x} = !{i32 3, i32 102000}
   B->addNamedMD(kSPIRVMD::Source)
       .addOp()
-      .add(CLVer == kOCLVer::CL21 ? spv::SourceLanguageOpenCL_CPP
-                                  : spv::SourceLanguageOpenCL_C)
+      .add(!is_vulkan ? (CLVer == kOCLVer::CL21 ?
+						 spv::SourceLanguageOpenCL_CPP :
+						 spv::SourceLanguageOpenCL_C) :
+		   spv::SourceLanguageGLSL)
       .add(CLVer)
       .done();
   if (EraseOCLMD)
@@ -278,14 +301,20 @@ void PreprocessMetadataBase::preprocessOCLMetadata(Module *M, SPIRVMDBuilder *B,
 
   // !spirv.MemoryModel = !{!x}
   // !{x} = !{i32 1, i32 2}
-  Triple TT(M->getTargetTriple());
-  assert(isSupportedTriple(TT) && "Invalid triple");
-  B->addNamedMD(kSPIRVMD::MemoryModel)
-      .addOp()
-      .add(TT.isArch32Bit() ? spv::AddressingModelPhysical32
-                            : spv::AddressingModelPhysical64)
-      .add(spv::MemoryModelOpenCL)
-      .done();
+  if (!is_vulkan) {
+    B->addNamedMD(kSPIRVMD::MemoryModel)
+        .addOp()
+        .add(TT.isArch32Bit() ? spv::AddressingModelPhysical32
+                              : spv::AddressingModelPhysical64)
+        .add(spv::MemoryModelOpenCL)
+        .done();
+  } else {
+    B->addNamedMD(kSPIRVMD::MemoryModel)
+        .addOp()
+        .add(spv::AddressingModelPhysicalStorageBuffer64)
+        .add(spv::MemoryModelVulkan)
+        .done();
+  }
 
   // Add source extensions
   // !spirv.SourceExtension = !{!x, !y, ...}
@@ -294,8 +323,12 @@ void PreprocessMetadataBase::preprocessOCLMetadata(Module *M, SPIRVMDBuilder *B,
   auto Exts = getNamedMDAsStringSet(M, kSPIR2MD::Extensions);
   if (!Exts.empty()) {
     auto N = B->addNamedMD(kSPIRVMD::SourceExtension);
-    for (auto &I : Exts)
+    for (auto &I : Exts) {
+      // skip cl_* extensions for vulkan
+      if (is_vulkan && I.find("cl_") == 0)
+        continue;
       N.addOp().add(I).done();
+    }
   }
   if (EraseOCLMD)
     B->eraseNamedMD(kSPIR2MD::Extensions).eraseNamedMD(kSPIR2MD::OptFeatures);
@@ -312,7 +345,7 @@ void PreprocessMetadataBase::preprocessVectorComputeMetadata(Module *M,
   auto EM = B->addNamedMD(kSPIRVMD::ExecutionMode);
 
   for (auto &F : *M) {
-    if (F.getCallingConv() != CallingConv::SPIR_KERNEL)
+    if (F.getCallingConv() != CallingConv::FLOOR_KERNEL)
       continue;
 
     // Add VC float control execution modes
diff --git a/lib/SPIRV/SPIRVContainerWriterPass.cpp b/lib/SPIRV/SPIRVContainerWriterPass.cpp
new file mode 100644
index 0000000..5fbdc39
--- /dev/null
+++ b/lib/SPIRV/SPIRVContainerWriterPass.cpp
@@ -0,0 +1,248 @@
+//===- SPIRVContainerWriterPass.cpp - SPIRV writing pass ------------------===//
+//
+//  Flo's Open libRary (floor)
+//  Copyright (C) 2004 - 2021 Florian Ziesche
+//
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; version 2 of the License only.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License along
+//  with this program; if not, write to the Free Software Foundation, Inc.,
+//  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+//
+//===----------------------------------------------------------------------===//
+//
+// SPIRVContainerWriterPass implementation: this is used to split up (clone) a
+// LLVM module into individual per-entry-point modules, which is necessary for
+// SPIR-V shaders, because we can't generally have globals that use the same
+// descriptor set index and binding index with different layouts, even if an
+// entry point only makes specific use of a valid set of descriptors.
+// This will then combine all SPIR-V binaries/modules into a single container
+// file, with some additional helpful metadata (function names and types per
+// SPIR-V module).
+//
+// TODO: in the future, it might make sense to specify a specific pipeline in
+// the source (set of shader functions), for which we can then guarantee (or
+// enforce) that only a valid set of descriptors is being used. This would then
+// allow these shaders to be emitted in one single SPIR-V module.
+//
+//
+// #### SPIR-V container file format ####
+// ## header
+// char[4]: identifier "SPVC"
+// uint32_t: version (currently 2)
+// uint32_t: entry_count
+//
+// ## header entries [entry_count]
+// uint32_t: function_entry_count
+// uint32_t: SPIR-V module word count (word == uint32_t)
+//
+// ## module entries [entry_count]
+// uint32_t[header_entry[i].word_count]: SPIR-V module
+//
+// ## additional metadata [entry_count]
+// uint32_t[function_entry_count]: function types
+// char[function_entry_count][]: function names (always \0 terminated, with \0
+//                                               padding to achieve
+//                                               4-byte/uint32_t alignment)
+//
+// ####
+//
+// function type (enum):
+//  * compute/kernel: 1
+//  * vertex: 2
+//  * fragment: 3
+//  * geometry: 4
+//  * tessellation control: 5
+//  * tessellation evaluation: 6
+//
+//===----------------------------------------------------------------------===//
+
+#include "SPIRVContainerWriterPass.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/PassManager.h"
+#include "llvm/Pass.h"
+#include "llvm/Support/Casting.h"
+#include "LLVMSPIRVLib.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+#include <string>
+#include <unordered_set>
+using namespace llvm;
+
+static bool is_used_in_function(const Function *F, const GlobalVariable *GV) {
+  // always flag certain builtin constants as used
+  switch (F->getCallingConv()) {
+  case CallingConv::FLOOR_KERNEL:
+    if (GV->getName().find(".vulkan_constant.workgroup_size") !=
+        StringRef::npos)
+      return true;
+    break;
+  case CallingConv::FLOOR_VERTEX:
+    break;
+  case CallingConv::FLOOR_FRAGMENT:
+    break;
+  }
+
+  for (const auto &user : GV->users()) {
+    if (const auto instr = dyn_cast<Instruction>(user)) {
+      if (instr->getParent()->getParent() == F) {
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+static bool write_container(Module &M, raw_ostream &OS) {
+  bool success = true;
+
+  // header
+  static constexpr const uint32_t container_version{2u};
+  OS.write("SPVC", 4);
+  OS.write((const char *)&container_version, sizeof(container_version));
+
+  // gather entry point functions that we want to clone/emit
+  std::unordered_set<const Function *> clone_functions;
+  for (const auto &F : M) {
+    if (F.getCallingConv() != CallingConv::FLOOR_KERNEL &&
+        F.getCallingConv() != CallingConv::FLOOR_VERTEX &&
+        F.getCallingConv() != CallingConv::FLOOR_FRAGMENT) {
+      continue;
+    }
+    clone_functions.emplace(&F);
+  }
+  // entry count
+  const auto entry_count = uint32_t(clone_functions.size());
+  OS.write((const char *)&entry_count, sizeof(entry_count));
+
+  // we need a separate stream for the actual spir-v data, since we need to know
+  // the size of each spir-v module/file (no way to know this beforehand)
+  std::string spirv_data{""};
+  raw_string_ostream spirv_stream(spirv_data);
+
+  for (const auto &func : clone_functions) {
+    // clone the module with the current entry point function and any global
+    // vars that we need
+    ValueToValueMapTy VMap;
+    auto cloned_mod = CloneModule(M, VMap, [&func](const GlobalValue *GV) {
+      if (GV == func) {
+        return true;
+      }
+      // only clone global vars if they are needed in a specific function
+      if (const GlobalVariable *GVar = dyn_cast<GlobalVariable>(GV)) {
+        return is_used_in_function(func, GVar);
+      }
+      return false;
+    });
+
+    // function entry count
+    const uint32_t function_entry_count = 1u;
+    OS.write((const char *)&function_entry_count, sizeof(function_entry_count));
+
+    // spir-v binary
+    const auto cur_pos = spirv_stream.tell();
+    std::string err;
+    // TODO: only enable extensions that are generally supported (needs host enablement as well)
+    SPIRV::TranslatorOpts::ExtensionsStatusMap exts;
+    exts[SPIRV::ExtensionID::SPV_EXT_shader_atomic_float_add] = true;
+    //exts[SPIRV::ExtensionID::SPV_KHR_no_integer_wrap_decoration] = true;
+    //exts[SPIRV::ExtensionID::SPV_KHR_float_controls] = true;
+    SPIRV::TranslatorOpts opts(SPIRV::VersionNumber::MaximumVersion, exts);
+    const auto module_success = writeSpirv(cloned_mod.get(), opts, spirv_stream, err);
+    auto module_size = uint32_t(spirv_stream.tell() - cur_pos);
+    if (module_size % 4 != 0) {
+      success = false;
+      errs() << "SPIR-V data size is not a multiple of 4\n";
+    }
+
+    // write the SPIR-V data word count
+    module_size /= 4;
+    OS.write((const char *)&module_size, sizeof(module_size));
+
+    // emit error if unsuccessful (still continue though)
+    success &= module_success;
+    if (!module_success) {
+      errs() << "failed to write/translate module for \"" << func->getName()
+             << "\": " << err << "\n";
+    }
+  }
+
+  // all header entries written -> write actual spir-v data
+  spirv_stream.flush();
+  OS.write(spirv_data.c_str(), spirv_data.size());
+
+  // write per-module metadata
+  for (const auto &func : clone_functions) {
+    // function types
+    uint32_t function_type = 0;
+    switch (func->getCallingConv()) {
+    case CallingConv::FLOOR_KERNEL:
+      function_type = 1;
+      break;
+    case CallingConv::FLOOR_VERTEX:
+      function_type = 2;
+      break;
+    case CallingConv::FLOOR_FRAGMENT:
+      function_type = 3;
+      break;
+    default:
+      llvm_unreachable("invalid function type");
+    }
+    OS.write((const char *)&function_type, sizeof(function_type));
+
+    // function names
+    const auto name = func->getName().str();
+    const auto name_len = (uint32_t)name.size();
+    const auto name_padding = 4u - (name_len % 4u);
+    OS << name.c_str();
+    switch (name_padding) {
+    case 4:
+      OS << '\0';
+    LLVM_FALLTHROUGH; case 3:
+      OS << '\0';
+    LLVM_FALLTHROUGH; case 2:
+      OS << '\0';
+    LLVM_FALLTHROUGH; case 1:
+      OS << '\0';
+      break;
+    default:
+      llvm_unreachable("bad math");
+    }
+  }
+
+  return success;
+}
+
+PreservedAnalyses SPIRVContainerWriterPass::run(Module &M, ModuleAnalysisManager &) {
+  write_container(M, OS);
+  return PreservedAnalyses::all();
+}
+
+namespace {
+class WriteSPIRVContainerPass : public ModulePass {
+  raw_ostream &OS; // raw_ostream to print on
+public:
+  static char ID; // Pass identification, replacement for typeid
+  explicit WriteSPIRVContainerPass(raw_ostream &o) : ModulePass(ID), OS(o) {}
+
+  StringRef getPassName() const override { return "SPIR-V Container Writer"; }
+
+  bool runOnModule(Module &M) override {
+    write_container(M, OS);
+    return false;
+  }
+};
+}
+
+char WriteSPIRVContainerPass::ID = 0;
+
+ModulePass *llvm::createSPIRVContainerWriterPass(raw_ostream &Str) {
+  return new WriteSPIRVContainerPass(Str);
+}
diff --git a/lib/SPIRV/SPIRVContainerWriterPass.h b/lib/SPIRV/SPIRVContainerWriterPass.h
new file mode 100644
index 0000000..82678dc
--- /dev/null
+++ b/lib/SPIRV/SPIRVContainerWriterPass.h
@@ -0,0 +1,62 @@
+//===-SPIRVContainerWriterPass.h - SPIR-V container writing pass -- C++ -*-===//
+//
+//  Flo's Open libRary (floor)
+//  Copyright (C) 2004 - 2021 Florian Ziesche
+//
+//  This program is free software; you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation; version 2 of the License only.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License along
+//  with this program; if not, write to the Free Software Foundation, Inc.,
+//  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+//
+//===----------------------------------------------------------------------===//
+/// \file
+///
+/// This file provides a SPIR-V container writing pass.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_SPIRVCONTAINERWRITERPASS_H
+#define LLVM_SPIRVCONTAINERWRITERPASS_H
+
+#include "llvm/ADT/StringRef.h"
+#include "llvm/IR/PassManager.h"
+
+namespace llvm {
+class Module;
+class ModulePass;
+class raw_ostream;
+class PreservedAnalyses;
+
+/// \brief Create and return a pass that writes the module to the specified
+/// ostream. Note that this pass is designed for use with the legacy pass
+/// manager.
+ModulePass *createSPIRVContainerWriterPass(raw_ostream &Str);
+
+/// \brief Pass for writing a module of IR out to a SPIR-V container file.
+///
+/// Note that this is intended for use with the new pass manager. To construct
+/// a pass for the legacy pass manager, use the function above.
+class SPIRVContainerWriterPass : public PassInfoMixin<SPIRVContainerWriterPass> {
+  raw_ostream &OS;
+
+public:
+  /// \brief Construct a SPIRV writer pass around a particular output stream.
+  explicit SPIRVContainerWriterPass(raw_ostream &OS) : OS(OS) {}
+
+  /// \brief Run the SPIRV writer pass, and output the module to the selected
+  /// output stream.
+  PreservedAnalyses run(Module &M, ModuleAnalysisManager &);
+
+  static StringRef name() { return "SPIRVContainerWriterPass"; }
+};
+}
+
+#endif
diff --git a/lib/SPIRV/SPIRVInternal.h b/lib/SPIRV/SPIRVInternal.h
index d1eb537..f3df588 100644
--- a/lib/SPIRV/SPIRVInternal.h
+++ b/lib/SPIRV/SPIRVInternal.h
@@ -182,17 +182,30 @@ typedef SPIRVMap<Op, Op, IntBoolOpMapId> IntBoolOpMap;
   "-v128:128:128-v192:256:256-v256:256:256"                                    \
   "-v512:512:512-v1024:1024:1024"
 
+// NOTE: modify VulkanFinal pass and clang Targets when this changes
 enum SPIRAddressSpace {
-  SPIRAS_Private,
-  SPIRAS_Global,
-  SPIRAS_Constant,
-  SPIRAS_Local,
-  SPIRAS_Generic,
-  SPIRAS_GlobalDevice,
-  SPIRAS_GlobalHost,
-  SPIRAS_Input,
-  SPIRAS_Output,
-  SPIRAS_Count,
+  SPIRAS_Private = 0,
+  SPIRAS_Global = 1,
+  SPIRAS_Constant = 2,
+  SPIRAS_Local = 3,
+  SPIRAS_Generic = 4,
+  // OpenCL
+  SPIRAS_GlobalDevice = 100,
+  SPIRAS_GlobalHost = 101,
+  // Vulkan/GLSL specific ones
+  SPIRAS_Uniform = 5,
+  SPIRAS_Input = 6,
+  SPIRAS_Output = 7,
+  SPIRAS_VulkanPrivate = 8, // != SPIRAS_Private
+  SPIRAS_PushConstant = 9,
+  SPIRAS_AtomicCounter = 10,
+  SPIRAS_Image = 11,
+  SPIRAS_StorageBuffer = 12,
+  // Workgroup == SPIRAS_Local
+  // CrossWorkgroup == SPIRAS_Global
+  // Function = SPIRAS_Private
+  // UniformConstant = SPIRAS_Constant
+  SPIRAS_PhysicalStorageBuffer = 5349,
 };
 
 template <> inline void SPIRVMap<SPIRAddressSpace, std::string>::init() {
@@ -201,9 +214,17 @@ template <> inline void SPIRVMap<SPIRAddressSpace, std::string>::init() {
   add(SPIRAS_Constant, "Constant");
   add(SPIRAS_Local, "Local");
   add(SPIRAS_Generic, "Generic");
-  add(SPIRAS_Input, "Input");
   add(SPIRAS_GlobalDevice, "GlobalDevice");
   add(SPIRAS_GlobalHost, "GlobalHost");
+  add(SPIRAS_Uniform, "Uniform");
+  add(SPIRAS_Input, "Input");
+  add(SPIRAS_Output, "Output");
+  add(SPIRAS_VulkanPrivate, "Private");
+  add(SPIRAS_PushConstant, "PushConstant");
+  add(SPIRAS_AtomicCounter, "AtomicCounter");
+  add(SPIRAS_Image, "Image");
+  add(SPIRAS_StorageBuffer, "StorageBuffer");
+  add(SPIRAS_PhysicalStorageBuffer, "PhysicalStorageBuffer");
 }
 typedef SPIRVMap<SPIRAddressSpace, SPIRVStorageClassKind>
     SPIRAddrSpaceCapitalizedNameMap;
@@ -215,9 +236,17 @@ inline void SPIRVMap<SPIRAddressSpace, SPIRVStorageClassKind>::init() {
   add(SPIRAS_Constant, StorageClassUniformConstant);
   add(SPIRAS_Local, StorageClassWorkgroup);
   add(SPIRAS_Generic, StorageClassGeneric);
-  add(SPIRAS_Input, StorageClassInput);
   add(SPIRAS_GlobalDevice, StorageClassDeviceOnlyINTEL);
   add(SPIRAS_GlobalHost, StorageClassHostOnlyINTEL);
+  add(SPIRAS_Uniform, StorageClassUniform);
+  add(SPIRAS_Input, StorageClassInput);
+  add(SPIRAS_Output, StorageClassOutput);
+  add(SPIRAS_VulkanPrivate, StorageClassPrivate);
+  add(SPIRAS_PushConstant, StorageClassPushConstant);
+  add(SPIRAS_AtomicCounter, StorageClassAtomicCounter);
+  add(SPIRAS_Image, StorageClassImage);
+  add(SPIRAS_StorageBuffer, StorageClassStorageBuffer);
+  add(SPIRAS_PhysicalStorageBuffer, StorageClassPhysicalStorageBuffer);
 }
 typedef SPIRVMap<SPIRAddressSpace, SPIRVStorageClassKind> SPIRSPIRVAddrSpaceMap;
 
@@ -227,6 +256,7 @@ inline void SPIRVMap<std::string, SPIRVAccessQualifierKind>::init() {
   add("read_only", AccessQualifierReadOnly);
   add("write_only", AccessQualifierWriteOnly);
   add("read_write", AccessQualifierReadWrite);
+  add("", AccessQualifierNone);
 }
 typedef SPIRVMap<std::string, SPIRVAccessQualifierKind>
     SPIRSPIRVAccessQualifierMap;
@@ -261,6 +291,7 @@ template <>
 inline void
 SPIRVMap<SPIRVExtInstSetKind, std::string, SPIRVExtSetShortName>::init() {
   add(SPIRVEIS_OpenCL, "ocl");
+  add(SPIRVEIS_GLSL, "glsl");
 }
 typedef SPIRVMap<SPIRVExtInstSetKind, std::string, SPIRVExtSetShortName>
     SPIRVExtSetShortNameMap;
@@ -887,9 +918,10 @@ std::string getSPIRVImageSampledTypeName(SPIRVType *Ty);
 /// E.g. %opencl.image1d_rw_t -> %spirv.Image._void_0_0_0_0_0_0_2
 Type *getSPIRVImageTypeFromOCL(Module *M, Type *T);
 
-/// Get LLVM type for sampled type of SPIR-V image type by postfix.
-Type *getLLVMTypeForSPIRVImageSampledTypePostfix(StringRef Postfix,
-                                                 LLVMContext &Ctx);
+/// Translates GLSL image type names to SPIR-V.
+Type *getSPIRVImageTypeFromGLSL(Module *M, Type *T, const char *sample_type,
+                                const bool is_storage,
+                                const spv::ImageFormat format);
 
 /// Return the unqualified and unsuffixed base name of an image type.
 /// E.g. opencl.image2d_ro_t.3 -> image2d_t
@@ -954,6 +986,10 @@ std::string getSPIRVFriendlyIRFunctionName(OCLExtOpKind ExtOpId,
                                            ArrayRef<Type *> ArgTys,
                                            Type *RetTy = nullptr);
 
+std::string getSPIRVFriendlyIRFunctionName(GLSLExtOpKind ExtOpId,
+                                           ArrayRef<Type *> ArgTys,
+                                           Type *RetTy = nullptr);
+
 /// Mangle a function in SPIR-V friendly IR manner
 /// \param UniqName full unmangled name of the SPIR-V built-in function that
 /// contains possible postfixes that depend not on opcode but on decorations or
diff --git a/lib/SPIRV/SPIRVLowerConstExpr.cpp b/lib/SPIRV/SPIRVLowerConstExpr.cpp
index 536d436..1c800da 100644
--- a/lib/SPIRV/SPIRVLowerConstExpr.cpp
+++ b/lib/SPIRV/SPIRVLowerConstExpr.cpp
@@ -144,7 +144,21 @@ void SPIRVLowerConstExprBase::visit(Module *M) {
         auto *CE = cast<ConstantExpr>(V);
         SPIRVDBG(dbgs() << "[lowerConstantExpressions] " << *CE;)
         auto ReplInst = CE->getAsInstruction();
-        auto InsPoint = II->getParent() == &*FBegin ? II : &FBegin->back();
+        Instruction *InsPoint = nullptr;
+        if (II->getParent() == &*FBegin) {
+          InsPoint = II;
+        } else {
+          InsPoint = &FBegin->back();
+          // ensure that the insertion point does not come before a selection/loop merge in the block
+          if (InsPoint && InsPoint->isTerminator()) {
+            if (auto pre_term_call_instr = dyn_cast_or_null<CallInst>(InsPoint->getPrevNode()); pre_term_call_instr) {
+              const auto& call_func_name = pre_term_call_instr->getCalledFunction()->getName();
+              if (call_func_name == "floor.selection_merge" || call_func_name == "floor.loop_merge") {
+                InsPoint = pre_term_call_instr;
+              }
+            }
+          }
+        }
         ReplInst->insertBefore(InsPoint);
         SPIRVDBG(dbgs() << " -> " << *ReplInst << '\n';)
         std::vector<Instruction *> Users;
diff --git a/lib/SPIRV/SPIRVReader.cpp b/lib/SPIRV/SPIRVReader.cpp
index de789a1..251cddc 100644
--- a/lib/SPIRV/SPIRVReader.cpp
+++ b/lib/SPIRV/SPIRVReader.cpp
@@ -317,7 +317,7 @@ bool SPIRVToLLVM::transOCLBuiltinFromVariable(GlobalVariable *GV,
   if (!Func) {
     FunctionType *FT = FunctionType::get(ReturnTy, ArgTy, false);
     Func = Function::Create(FT, GlobalValue::ExternalLinkage, MangledName, M);
-    Func->setCallingConv(CallingConv::SPIR_FUNC);
+    Func->setCallingConv(CallingConv::FLOOR_FUNC);
     Func->addFnAttr(Attribute::NoUnwind);
     Func->addFnAttr(Attribute::ReadNone);
     Func->addFnAttr(Attribute::WillReturn);
@@ -2424,7 +2424,7 @@ Value *SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *BV, Function *F,
         cast<FunctionType>(V->getType()->getPointerElementType()), V,
         transValue(BC->getArgumentValues(), F, BB), BC->getName(), BB);
     // Assuming we are calling a regular device function
-    Call->setCallingConv(CallingConv::SPIR_FUNC);
+    Call->setCallingConv(CallingConv::FLOOR_FUNC);
     // Don't set attributes, because at translation time we don't know which
     // function exactly we are calling.
     return mapValue(BV, Call);
@@ -2736,7 +2736,7 @@ CallInst *SPIRVToLLVM::transFixedPointInst(SPIRVInstruction *BI,
   FunctionCallee FCallee = M->getOrInsertFunction(FuncName, FT);
 
   auto *Fn = cast<Function>(FCallee.getCallee());
-  Fn->setCallingConv(CallingConv::SPIR_FUNC);
+  Fn->setCallingConv(CallingConv::FLOOR_FUNC);
   if (isFuncNoUnwind())
     Fn->addFnAttr(Attribute::NoUnwind);
 
@@ -2863,7 +2863,7 @@ CallInst *SPIRVToLLVM::transArbFloatInst(SPIRVInstruction *BI, BasicBlock *BB,
   FunctionCallee FCallee = M->getOrInsertFunction(FuncName, FT);
 
   auto *Func = cast<Function>(FCallee.getCallee());
-  Func->setCallingConv(CallingConv::SPIR_FUNC);
+  Func->setCallingConv(CallingConv::FLOOR_FUNC);
   if (isFuncNoUnwind())
     Func->addFnAttr(Attribute::NoUnwind);
 
@@ -2909,8 +2909,8 @@ Function *SPIRVToLLVM::transFunction(SPIRVFunction *BF) {
   if (F->isIntrinsic())
     return F;
 
-  F->setCallingConv(IsKernel ? CallingConv::SPIR_KERNEL
-                             : CallingConv::SPIR_FUNC);
+  F->setCallingConv(IsKernel ? CallingConv::FLOOR_KERNEL
+                             : CallingConv::FLOOR_FUNC);
   if (BF->hasDecorate(DecorationReferencedIndirectlyINTEL))
     F->addFnAttr("referenced-indirectly");
   if (isFuncNoUnwind())
@@ -3298,7 +3298,7 @@ Instruction *SPIRVToLLVM::transBuiltinFromInst(const std::string &FuncName,
   if (!Func || Func->getFunctionType() != FT) {
     LLVM_DEBUG(for (auto &I : ArgTys) { dbgs() << *I << '\n'; });
     Func = Function::Create(FT, GlobalValue::ExternalLinkage, MangledName, M);
-    Func->setCallingConv(CallingConv::SPIR_FUNC);
+    Func->setCallingConv(CallingConv::FLOOR_FUNC);
     if (isFuncNoUnwind())
       Func->addFnAttr(Attribute::NoUnwind);
     auto OC = BI->getOpCode();
@@ -3406,7 +3406,6 @@ std::string getSPIRVFuncSuffix(SPIRVInstruction *BI) {
            "Invalid type of CreatePipeFromStorage");
     auto PipeType = static_cast<SPIRVTypePipe *>(CPFPS->getType());
     switch (PipeType->getAccessQualifier()) {
-    default:
     case AccessQualifierReadOnly:
       Suffix = "_read";
       break;
@@ -3416,6 +3415,8 @@ std::string getSPIRVFuncSuffix(SPIRVInstruction *BI) {
     case AccessQualifierReadWrite:
       Suffix = "_read_write";
       break;
+    case AccessQualifierNone:
+      break;
     }
   }
   if (BI->hasDecorate(DecorationSaturatedConversion)) {
@@ -3534,20 +3535,19 @@ bool SPIRVToLLVM::transAddressingModel() {
   case AddressingModelPhysical64:
     M->setTargetTriple(SPIR_TARGETTRIPLE64);
     M->setDataLayout(SPIR_DATALAYOUT64);
-    break;
+    return true;
   case AddressingModelPhysical32:
     M->setTargetTriple(SPIR_TARGETTRIPLE32);
     M->setDataLayout(SPIR_DATALAYOUT32);
-    break;
+    return true;
   case AddressingModelLogical:
+  case AddressingModelPhysicalStorageBuffer64:
     // Do not set target triple and data layout
-    break;
+    return true;
   default:
-    SPIRVCKRT(0, InvalidAddressingModel,
-              "Actual addressing mode is " +
-                  std::to_string(BM->getAddressingModel()));
+    break;
   }
-  return true;
+  llvm_unreachable("invalid addressing model");
 }
 
 void generateIntelFPGAAnnotation(const SPIRVEntry *E,
@@ -4004,7 +4004,7 @@ bool SPIRVToLLVM::transMetadata() {
         BF->getExecutionMode(internal::ExecutionModeFastCompositeKernelINTEL))
       F->addFnAttr(kVCMetadata::VCFCEntry);
 
-    if (F->getCallingConv() != CallingConv::SPIR_KERNEL)
+    if (F->getCallingConv() != CallingConv::FLOOR_KERNEL)
       continue;
 
     // Generate metadata for reqd_work_group_size
@@ -4074,7 +4074,7 @@ bool SPIRVToLLVM::transMetadata() {
 bool SPIRVToLLVM::transOCLMetadata(SPIRVFunction *BF) {
   Function *F = static_cast<Function *>(getTranslatedValue(BF));
   assert(F && "Invalid translated function");
-  if (F->getCallingConv() != CallingConv::SPIR_KERNEL)
+  if (F->getCallingConv() != CallingConv::FLOOR_KERNEL)
     return true;
 
   if (BF->hasDecorate(DecorationVectorComputeFunctionINTEL))
@@ -4378,16 +4378,26 @@ bool SPIRVToLLVM::transAlign(SPIRVValue *BV, Value *V) {
 Instruction *SPIRVToLLVM::transOCLBuiltinFromExtInst(SPIRVExtInst *BC,
                                                      BasicBlock *BB) {
   assert(BB && "Invalid BB");
-  auto ExtOp = static_cast<OCLExtOpKind>(BC->getExtOp());
-  std::string UnmangledName = OCLExtOpMap::map(ExtOp);
 
-  assert(BM->getBuiltinSet(BC->getExtSetId()) == SPIRVEIS_OpenCL &&
-         "Not OpenCL extended instruction");
+  const auto ext_kind = BM->getBuiltinSet(BC->getExtSetId());
+  assert((ext_kind == SPIRVEIS_OpenCL || ext_kind == SPIRVEIS_GLSL) &&
+         "Not OpenCL or GLSL extended instruction");
 
   std::vector<Type *> ArgTypes = transTypeVector(BC->getArgTypes());
   Type *RetTy = transType(BC->getType());
-  std::string MangledName =
-      getSPIRVFriendlyIRFunctionName(ExtOp, ArgTypes, RetTy);
+
+  std::string UnmangledName, MangledName;
+  if (ext_kind == SPIRVEIS_OpenCL) {
+    auto CLExtOp = static_cast<OCLExtOpKind>(BC->getExtOp());
+    UnmangledName = OCLExtOpMap::map(CLExtOp);
+    MangledName = getSPIRVFriendlyIRFunctionName(CLExtOp, ArgTypes, RetTy);
+  } else if (ext_kind == SPIRVEIS_GLSL) {
+    auto GLSLExtOp = static_cast<GLSLExtOpKind>(BC->getExtOp());
+    UnmangledName = GLSLExtOpMap::map(GLSLExtOp);
+    MangledName = getSPIRVFriendlyIRFunctionName(GLSLExtOp, ArgTypes, RetTy);
+  } else {
+    llvm_unreachable("invalid extension kind");
+  }
 
   SPIRVDBG(spvdbgs() << "[transOCLBuiltinFromExtInst] UnmangledName: "
                      << UnmangledName << " MangledName: " << MangledName
@@ -4397,7 +4407,7 @@ Instruction *SPIRVToLLVM::transOCLBuiltinFromExtInst(SPIRVExtInst *BC,
   Function *F = M->getFunction(MangledName);
   if (!F) {
     F = Function::Create(FT, GlobalValue::ExternalLinkage, MangledName, M);
-    F->setCallingConv(CallingConv::SPIR_FUNC);
+    F->setCallingConv(CallingConv::FLOOR_FUNC);
     if (isFuncNoUnwind())
       F->addFnAttr(Attribute::NoUnwind);
     if (isFuncReadNone(UnmangledName))
diff --git a/lib/SPIRV/SPIRVRegularizeLLVM.cpp b/lib/SPIRV/SPIRVRegularizeLLVM.cpp
index 59a2f86..4ed7610 100644
--- a/lib/SPIRV/SPIRVRegularizeLLVM.cpp
+++ b/lib/SPIRV/SPIRVRegularizeLLVM.cpp
@@ -41,10 +41,12 @@
 #include "SPIRVInternal.h"
 #include "libSPIRV/SPIRVDebug.h"
 
+#include "llvm/IR/Dominators.h"
 #include "llvm/IR/InstVisitor.h"
 #include "llvm/IR/Instructions.h"
 #include "llvm/IR/Operator.h"
 #include "llvm/IR/PassManager.h"
+#include "llvm/IR/Verifier.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Transforms/Utils/LowerMemIntrinsics.h" // expandMemSetAsLoop()
@@ -304,6 +306,35 @@ bool SPIRVRegularizeLLVMBase::runRegularizeLLVM(Module &Module) {
   return true;
 }
 
+// final cleanup: sort BBs according to the DT
+void sort_bbs(Function *F) {
+  // dominator fixes: reorder blocks
+  // NOTE: obviously only necessary when there are more than 2 blocks
+  if (F->getBasicBlockList().size() <= 2)
+    return;
+
+  DominatorTree DT;
+  DT.recalculate(*F);
+
+  // use the dominator tree order to sort the bbs, i.e. with the DT we already
+  // know the sorted order,
+  // we just need to physically move the blocks according to it
+  std::vector<BasicBlock *> sorted_blocks;
+  const std::function<void(const DomTreeNodeBase<BasicBlock> &)> sort_recurse =
+      [&sort_recurse, &sorted_blocks](const DomTreeNodeBase<BasicBlock> &node) {
+        sorted_blocks.emplace_back(node.getBlock());
+        for (const auto &child : node) {
+          sort_recurse(*child);
+        }
+      };
+  sort_recurse(*DT.getRootNode());
+
+  // move blocks in reverse order (not moving entry of course)
+  for (size_t i = 0, count = sorted_blocks.size(); i < count - 2; ++i) {
+    sorted_blocks[count - i - 2]->moveBefore(sorted_blocks[count - i - 1]);
+  }
+}
+
 /// Remove entities not representable by SPIR-V
 bool SPIRVRegularizeLLVMBase::regularize() {
   eraseUselessFunctions(M);
@@ -340,6 +371,15 @@ bool SPIRVRegularizeLLVMBase::regularize() {
           if (isa<PossiblyExactOperator>(BO) && BO->isExact())
             BO->setIsExact(false);
         }
+
+        // ref: https://github.com/KhronosGroup/SPIRV-LLVM-Translator/issues/1140
+        // FIXME: This is not valid handling for freeze instruction
+        if (auto FI = dyn_cast<FreezeInst>(&II)) {
+          FI->replaceAllUsesWith(FI->getOperand(0));
+          FI->dropAllReferences();
+          ToErase.push_back(FI);
+        }
+
         // Remove metadata not supported by SPIRV
         static const char *MDs[] = {
             "fpmath",
@@ -411,6 +451,18 @@ bool SPIRVRegularizeLLVMBase::regularize() {
     }
   }
 
+  // sort BBs according to DT
+  for (auto &F : *M) {
+    sort_bbs(&F);
+  }
+
+  std::string Err;
+  raw_string_ostream ErrorOS(Err);
+  if (llvm::verifyModule(*M, &ErrorOS)) {
+    SPIRVDBG(errs() << "Fails to verify module: " << ErrorOS.str();)
+    return false;
+  }
+
   if (SPIRVDbgSaveRegularizedModule)
     saveLLVMModule(M, RegularizedModuleTmpFile);
   return true;
diff --git a/lib/SPIRV/SPIRVToLLVMDbgTran.cpp b/lib/SPIRV/SPIRVToLLVMDbgTran.cpp
index 6e2dcf5..b934eb1 100644
--- a/lib/SPIRV/SPIRVToLLVMDbgTran.cpp
+++ b/lib/SPIRV/SPIRVToLLVMDbgTran.cpp
@@ -64,7 +64,9 @@ static uint64_t getDerivedSizeInBits(const DIType *Ty) {
 SPIRVToLLVMDbgTran::SPIRVToLLVMDbgTran(SPIRVModule *TBM, Module *TM,
                                        SPIRVToLLVM *Reader)
     : BM(TBM), M(TM), Builder(*M), SPIRVReader(Reader) {
-  Enable = BM->hasDebugInfo();
+  // TODO: OpLines are all over the place now -> better hasDebugInfo()
+  Enable = true; // always enable for now
+  //Enable = BM->hasDebugInfo();
 }
 
 void SPIRVToLLVMDbgTran::addDbgInfoVersion() {
diff --git a/lib/SPIRV/SPIRVUtil.cpp b/lib/SPIRV/SPIRVUtil.cpp
index 7864216..f72cefc 100644
--- a/lib/SPIRV/SPIRVUtil.cpp
+++ b/lib/SPIRV/SPIRVUtil.cpp
@@ -123,6 +123,9 @@ std::string mapLLVMTypeToOCLType(const Type *Ty, bool Signed) {
     if (!Signed)
       SignPrefix = "u";
     switch (IntTy->getIntegerBitWidth()) {
+    case 1:
+      Stem = "bool";
+      break;
     case 8:
       Stem = "char";
       break;
@@ -318,7 +321,7 @@ Function *getOrCreateFunction(Module *M, Type *RetTy, ArrayRef<Type *> ArgTypes,
     LLVM_DEBUG(dbgs() << "[getOrCreateFunction] ";
                if (F) dbgs() << *F << " => "; dbgs() << *NewF << '\n';);
     F = NewF;
-    F->setCallingConv(CallingConv::SPIR_FUNC);
+    F->setCallingConv(CallingConv::FLOOR_FUNC);
     if (Attrs)
       F->setAttributes(*Attrs);
   }
@@ -393,6 +396,9 @@ std::string getSPIRVExtFuncName(SPIRVExtInstSetKind Set, unsigned ExtOp,
   case SPIRVEIS_OpenCL:
     ExtOpName = getName(static_cast<OCLExtOpKind>(ExtOp));
     break;
+  case SPIRVEIS_GLSL:
+    ExtOpName = getName(static_cast<GLSLExtOpKind>(ExtOp));
+    break;
   }
   return prefixSPIRVName(SPIRVExtSetShortNameMap::map(Set) + '_' + ExtOpName +
                          PostFix.str());
@@ -964,6 +970,29 @@ SPIR::TypePrimitiveEnum getOCLTypePrimitiveEnum(StringRef TyName) {
       .Case("opencl.image2d_array_msaa_depth_rw_t",
             SPIR::PRIMITIVE_IMAGE2D_ARRAY_MSAA_DEPTH_RW_T)
       .Case("opencl.image3d_rw_t", SPIR::PRIMITIVE_IMAGE3D_RW_T)
+	  // --> for libfloor Vulkan/OpenCL
+      .Case("opencl.image1d_t", SPIR::PRIMITIVE_IMAGE_1D_T)
+      .Case("opencl.image1d_array_t", SPIR::PRIMITIVE_IMAGE_1D_ARRAY_T)
+      .Case("opencl.image1d_buffer_t", SPIR::PRIMITIVE_IMAGE_1D_BUFFER_T)
+      .Case("opencl.image2d_t", SPIR::PRIMITIVE_IMAGE_2D_T)
+      .Case("opencl.image2d_array_t", SPIR::PRIMITIVE_IMAGE_2D_ARRAY_T)
+      .Case("opencl.image3d_t", SPIR::PRIMITIVE_IMAGE_3D_T)
+      .Case("opencl.image2d_msaa_t", SPIR::PRIMITIVE_IMAGE_2D_MSAA_T)
+      .Case("opencl.image2d_array_msaa_t",
+            SPIR::PRIMITIVE_IMAGE_2D_ARRAY_MSAA_T)
+      .Case("opencl.image2d_msaa_depth_t",
+            SPIR::PRIMITIVE_IMAGE_2D_MSAA_DEPTH_T)
+      .Case("opencl.image2d_array_msaa_depth_t",
+            SPIR::PRIMITIVE_IMAGE_2D_ARRAY_MSAA_DEPTH_T)
+      .Case("opencl.image2d_depth_t", SPIR::PRIMITIVE_IMAGE_2D_DEPTH_T)
+      .Case("opencl.image2d_array_depth_t",
+            SPIR::PRIMITIVE_IMAGE_2D_ARRAY_DEPTH_T)
+      .Case("opencl.imagecube_t", SPIR::PRIMITIVE_IMAGE_CUBE_T)
+      .Case("opencl.imagecube_array_t", SPIR::PRIMITIVE_IMAGE_CUBE_ARRAY_T)
+      .Case("opencl.imagecube_depth_t", SPIR::PRIMITIVE_IMAGE_CUBE_DEPTH_T)
+      .Case("opencl.imagecube_array_depth_t",
+            SPIR::PRIMITIVE_IMAGE_CUBE_ARRAY_DEPTH_T)
+	  // <-- for libfloor Vulkan/OpenCL
       .Case("opencl.event_t", SPIR::PRIMITIVE_EVENT_T)
       .Case("opencl.pipe_ro_t", SPIR::PRIMITIVE_PIPE_RO_T)
       .Case("opencl.pipe_wo_t", SPIR::PRIMITIVE_PIPE_WO_T)
@@ -1279,23 +1308,6 @@ std::string getSPIRVImageSampledTypeName(SPIRVType *Ty) {
   return std::string();
 }
 
-// ToDo: Find a way to represent uint sampled type in LLVM, maybe an
-//      opaque type.
-Type *getLLVMTypeForSPIRVImageSampledTypePostfix(StringRef Postfix,
-                                                 LLVMContext &Ctx) {
-  if (Postfix == kSPIRVImageSampledTypeName::Void)
-    return Type::getVoidTy(Ctx);
-  if (Postfix == kSPIRVImageSampledTypeName::Float)
-    return Type::getFloatTy(Ctx);
-  if (Postfix == kSPIRVImageSampledTypeName::Half)
-    return Type::getHalfTy(Ctx);
-  if (Postfix == kSPIRVImageSampledTypeName::Int ||
-      Postfix == kSPIRVImageSampledTypeName::UInt)
-    return Type::getInt32Ty(Ctx);
-  llvm_unreachable("Invalid sampled type postfix");
-  return nullptr;
-}
-
 std::string getImageBaseTypeName(StringRef Name) {
 
   SmallVector<StringRef, 4> SubStrs;
@@ -1378,8 +1390,13 @@ void eraseIfNoUse(Value *V) {
 
 bool eraseUselessFunctions(Module *M) {
   bool Changed = false;
-  for (auto I = M->begin(), E = M->end(); I != E;)
-    Changed |= eraseIfNoUse(&(*I++));
+  for (auto I = M->begin(), E = M->end(); I != E;) {
+    // iterator will be invalidated if the function is erased
+    // -> need to increment before calling eraseIfNoUse
+    Function *func_ptr = &*I;
+    ++I;
+    Changed |= eraseIfNoUse(func_ptr);
+  }
   return Changed;
 }
 
@@ -1619,6 +1636,41 @@ bool checkTypeForSPIRVExtendedInstLowering(IntrinsicInst *II, SPIRVModule *BM) {
   }
   return true;
 }
+
+/// Translates GLSL image type names to SPIR-V.
+Type *getSPIRVImageTypeFromGLSL(Module *M, Type *ImageTy,
+                                const char *sample_type, const bool is_storage,
+                                const spv::ImageFormat format) {
+  assert(isOCLImageType(ImageTy) && "invalid image type");
+  auto Name = ImageTy->getPointerElementType()->getStructName();
+  assert(Name.startswith(kSPR2TypeName::ImagePrefix) && "invalid image type");
+
+  std::string BaseTy;
+  std::string Postfixes;
+  raw_string_ostream OS(Postfixes);
+  OS << kSPIRVTypeName::PostfixDelim;
+
+  SmallVector<StringRef, 4> SubStrs;
+  const char Delims[] = {kSPR2TypeName::Delimiter, 0};
+  Name.split(SubStrs, Delims);
+  std::string ImageTyName = SubStrs[1].str();
+  if (hasAccessQualifiedName(Name))
+    ImageTyName.erase(ImageTyName.size() - 5, 3);
+  auto Desc = map<SPIRVTypeImageDescriptor>(ImageTyName);
+  Desc.Sampled = (is_storage ? 2 : 1);
+  Desc.Format = format;
+  LLVM_DEBUG(dbgs() << "[trans image type] " << SubStrs[1] << " => "
+               << "(" << (unsigned)Desc.Dim << ", " << Desc.Depth << ", "
+               << Desc.Arrayed << ", " << Desc.MS << ", " << Desc.Sampled
+               << ", " << Desc.Format << ")\n");
+
+  BaseTy = kSPIRVTypeName::Image;
+  OS << getSPIRVImageTypePostfixes(sample_type, Desc, spv::AccessQualifierNone);
+  auto spirv_type_name = getSPIRVTypeName(BaseTy, OS.str());
+
+  return getOrCreateOpaquePtrType(M, spirv_type_name);
+}
+
 } // namespace SPIRV
 
 namespace {
@@ -1748,6 +1800,31 @@ private:
   OCLExtOpKind ExtOpId;
   ArrayRef<Type *> ArgTys;
 };
+class GLSLToSPIRVFriendlyIRMangleInfo : public BuiltinFuncMangleInfo {
+public:
+  GLSLToSPIRVFriendlyIRMangleInfo(GLSLExtOpKind ExtOpId_,
+                                  ArrayRef<Type *> ArgTys, Type *RetTy)
+      : ExtOpId(ExtOpId_), ArgTys(ArgTys) {
+
+    std::string Postfix = "";
+    if (needRetTypePostfix())
+      Postfix = kSPIRVPostfix::Divider + getPostfixForReturnType(RetTy, true);
+
+    UnmangledName = getSPIRVExtFuncName(SPIRVEIS_GLSL, ExtOpId, Postfix);
+  }
+
+  bool needRetTypePostfix() {
+    return false;
+  }
+
+  void init(StringRef) override {
+    // nop
+  }
+
+private:
+  GLSLExtOpKind ExtOpId;
+  ArrayRef<Type *> ArgTys;
+};
 } // namespace
 
 namespace SPIRV {
@@ -1758,6 +1835,13 @@ std::string getSPIRVFriendlyIRFunctionName(OCLExtOpKind ExtOpId,
   return mangleBuiltin(MangleInfo.getUnmangledName(), ArgTys, &MangleInfo);
 }
 
+std::string getSPIRVFriendlyIRFunctionName(GLSLExtOpKind ExtOpId,
+                                           ArrayRef<Type *> ArgTys,
+                                           Type *RetTy) {
+  GLSLToSPIRVFriendlyIRMangleInfo MangleInfo(ExtOpId, ArgTys, RetTy);
+  return mangleBuiltin(MangleInfo.getUnmangledName(), ArgTys, &MangleInfo);
+}
+
 std::string getSPIRVFriendlyIRFunctionName(const std::string &UniqName,
                                            spv::Op OC,
                                            ArrayRef<Type *> ArgTys) {
diff --git a/lib/SPIRV/SPIRVWriter.cpp b/lib/SPIRV/SPIRVWriter.cpp
index 2c3bc15..d2159c8 100644
--- a/lib/SPIRV/SPIRVWriter.cpp
+++ b/lib/SPIRV/SPIRVWriter.cpp
@@ -6,6 +6,7 @@
 // License. See LICENSE.TXT for details.
 //
 // Copyright (c) 2014 Advanced Micro Devices, Inc. All rights reserved.
+// Copyright (c) 2016 - 2021 Florian Ziesche Vulkan/SPIR-V support
 //
 // Permission is hereby granted, free of charge, to any person obtaining a
 // copy of this software and associated documentation files (the "Software"),
@@ -61,6 +62,8 @@
 #include "llvm/ADT/StringSwitch.h"
 #include "llvm/ADT/Triple.h"
 #include "llvm/Analysis/ValueTracking.h"
+#include "llvm/Bitcode/BitcodeReader.h"
+#include "llvm/Bitcode/BitcodeWriter.h"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DerivedTypes.h"
 #include "llvm/IR/Function.h"
@@ -71,10 +74,12 @@
 #include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/Operator.h"
+#include "llvm/IR/PatternMatch.h"
 #include "llvm/Pass.h"
 #include "llvm/Support/Casting.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
+#include "llvm/Transforms/LibFloor/VulkanSampling.h"
 #include "llvm/Transforms/Utils.h" // loop-simplify pass
 
 #include <cstdlib>
@@ -147,12 +152,30 @@ SPIRVValue *LLVMToSPIRVBase::getTranslatedValue(const Value *V) const {
   return nullptr;
 }
 
-bool LLVMToSPIRVBase::isKernel(Function *F) {
-  if (F->getCallingConv() == CallingConv::SPIR_KERNEL)
+bool LLVMToSPIRVBase::isEntryPoint(Function *F) {
+  if (F->getCallingConv() == CallingConv::FLOOR_KERNEL||
+      F->getCallingConv() == CallingConv::FLOOR_VERTEX ||
+      F->getCallingConv() == CallingConv::FLOOR_FRAGMENT)
     return true;
   return false;
 }
 
+spv::ExecutionModel LLVMToSPIRVBase::getEntryPointType(Function *F,
+                                                       unsigned int SrcLang) {
+  switch (F->getCallingConv()) {
+  case CallingConv::FLOOR_KERNEL:
+    return (SrcLang == spv::SourceLanguageGLSL
+                ? spv::ExecutionModel::ExecutionModelGLCompute
+                : spv::ExecutionModel::ExecutionModelKernel);
+  case CallingConv::FLOOR_VERTEX:
+    return spv::ExecutionModel::ExecutionModelVertex;
+  case CallingConv::FLOOR_FRAGMENT:
+    return spv::ExecutionModel::ExecutionModelFragment;
+  default:
+    return spv::ExecutionModel::ExecutionModelInvalid;
+  }
+}
+
 bool LLVMToSPIRVBase::isBuiltinTransToInst(Function *F) {
   StringRef DemangledName;
   if (!oclIsBuiltin(F->getName(), DemangledName) &&
@@ -180,19 +203,34 @@ bool LLVMToSPIRVBase::isBuiltinTransToExtInst(
   SPIRVExtInstSetKind Set = SPIRVEIS_Count;
   if (!SPIRVExtSetShortNameMap::rfind(ExtSetName.str(), &Set))
     return false;
-  assert((Set == SPIRVEIS_OpenCL || Set == BM->getDebugInfoEIS()) &&
+  assert((Set == SPIRVEIS_OpenCL || Set == BM->getDebugInfoEIS() ||
+          Set == SPIRVEIS_GLSL) &&
          "Unsupported extended instruction set");
 
   auto ExtOpName = S.substr(Loc + 1);
   auto Splited = ExtOpName.split(kSPIRVPostfix::ExtDivider);
-  OCLExtOpKind EOC;
-  if (!OCLExtOpMap::rfind(Splited.first.str(), &EOC))
-    return false;
+  if (Set == SPIRVEIS_OpenCL) {
+    OCLExtOpKind EOC;
+    if (!OCLExtOpMap::rfind(Splited.first.str(), &EOC))
+      return false;
+
+    if (ExtSet)
+      *ExtSet = Set;
+    if (ExtOp)
+      *ExtOp = EOC;
+  } else if (Set == SPIRVEIS_GLSL) {
+    GLSLExtOpKind EGLSL;
+    if (!GLSLExtOpMap::rfind(Splited.first.str(), &EGLSL))
+      return false;
+
+    if (ExtSet)
+      *ExtSet = Set;
+    if (ExtOp)
+      *ExtOp = EGLSL;
+  } else {
+    llvm_unreachable("unhandled instruction set");
+  }
 
-  if (ExtSet)
-    *ExtSet = Set;
-  if (ExtOp)
-    *ExtOp = EOC;
   if (Dec) {
     SmallVector<StringRef, 2> P;
     Splited.second.split(P, kSPIRVPostfix::Divider);
@@ -278,15 +316,33 @@ SPIRVType *LLVMToSPIRVBase::transType(Type *T) {
 
   if (T->isIntegerTy()) {
     unsigned BitWidth = T->getIntegerBitWidth();
-    // SPIR-V 2.16.1. Universal Validation Rules: Scalar integer types can be
-    // parameterized only as 32 bit, plus any additional sizes enabled by
-    // capabilities.
-    if (BM->isAllowedToUseExtension(
-            ExtensionID::SPV_INTEL_arbitrary_precision_integers) ||
-        BM->getErrorLog().checkError(
-            BitWidth == 8 || BitWidth == 16 || BitWidth == 32 || BitWidth == 64,
-            SPIRVEC_InvalidBitWidth, std::to_string(BitWidth))) {
-      return mapType(T, BM->addIntegerType(T->getIntegerBitWidth()));
+    if (SrcLang == spv::SourceLanguageGLSL) {
+      // legalize int width
+      if (BitWidth <= 8) {
+        BitWidth = 8;
+      } else if (BitWidth <= 16) {
+        BitWidth = 16;
+      } else if (BitWidth <= 32) {
+        BitWidth = 32;
+      } else if (BitWidth <= 64) {
+        BitWidth = 64;
+      } else {
+        assert(false && "bit-width is not supported (too large)");
+      }
+      // always signed (by default)
+      return mapType(T, BM->addIntegerType(BitWidth, true));
+    } else { // OpenCL, or others
+      // SPIR-V 2.16.1. Universal Validation Rules: Scalar integer types can be
+      // parameterized only as 32 bit, plus any additional sizes enabled by
+      // capabilities.
+      if (BM->isAllowedToUseExtension(
+              ExtensionID::SPV_INTEL_arbitrary_precision_integers) ||
+          BM->getErrorLog().checkError(
+              BitWidth == 8 || BitWidth == 16 || BitWidth == 32 || BitWidth == 64,
+              SPIRVEC_InvalidBitWidth, std::to_string(BitWidth))) {
+        // always unsigned
+        return mapType(T, BM->addIntegerType(BitWidth, false));
+      }
     }
   }
 
@@ -341,9 +397,14 @@ SPIRVType *LLVMToSPIRVBase::transType(Type *T) {
         return mapType(T, PipeT);
       }
       if (STName.startswith(kSPR2TypeName::ImagePrefix)) {
-        assert(AddrSpc == SPIRAS_Global);
-        auto SPIRVImageTy = getSPIRVImageTypeFromOCL(M, T);
-        return mapType(T, transType(SPIRVImageTy));
+        if (SrcLang != SourceLanguageGLSL) {
+          assert(AddrSpc == SPIRAS_Global);
+          auto SPIRVImageTy = getSPIRVImageTypeFromOCL(M, T);
+          return mapType(T, transType(SPIRVImageTy));
+        } else {
+          errs() << "invalid trans type: " << *T << "\n";
+          assert(false && "should not be here");
+        }
       }
       if (STName == kSPR2TypeName::Sampler)
         return mapType(T, transType(getSamplerType(M)));
@@ -500,8 +561,13 @@ SPIRVType *LLVMToSPIRVBase::transType(Type *T) {
     return mapType(T, BM->addFunctionType(RT, PT));
   }
 
+  if (T->isLabelTy()) {
+    assert(false && "labels can't be mapped as types - handle this earlier!");
+    return nullptr;
+  }
+
   llvm_unreachable("Not implemented!");
-  return 0;
+  return nullptr;
 }
 
 SPIRVType *LLVMToSPIRVBase::transSPIRVOpaqueType(Type *T) {
@@ -510,7 +576,7 @@ SPIRVType *LLVMToSPIRVBase::transSPIRVOpaqueType(Type *T) {
   auto STName = ST->getStructName();
   assert(STName.startswith(kSPIRVTypeName::PrefixAndDelim) &&
          "Invalid SPIR-V opaque type name");
-  SmallVector<std::string, 8> Postfixes;
+  SmallVector<std::string, 9> Postfixes;
   auto TN = decodeSPIRVTypeName(STName, Postfixes);
   if (TN == kSPIRVTypeName::Pipe) {
     assert(T->getPointerAddressSpace() == SPIRAS_Global);
@@ -521,18 +587,33 @@ SPIRVType *LLVMToSPIRVBase::transSPIRVOpaqueType(Type *T) {
     return mapType(T, PipeT);
   } else if (TN == kSPIRVTypeName::Image) {
     assert(T->getPointerAddressSpace() == SPIRAS_Global);
-    // The sampled type needs to be translated through LLVM type to guarantee
-    // uniqueness.
-    auto SampledT = transType(
-        getLLVMTypeForSPIRVImageSampledTypePostfix(Postfixes[0], *Ctx));
+
+    SPIRVType *SampledT = nullptr;
+    if (Postfixes[1] == kSPIRVImageSampledTypeName::Void) {
+      SampledT = BM->addVoidType();
+    } else if (Postfixes[1] == kSPIRVImageSampledTypeName::Float) {
+      SampledT = BM->addFloatType(32);
+    } else if (Postfixes[1] == kSPIRVImageSampledTypeName::Half) {
+      SampledT = BM->addFloatType(16);
+    } else if (Postfixes[1] == kSPIRVImageSampledTypeName::UInt) {
+      SampledT = BM->addIntegerType(32, false);
+    } else if (Postfixes[1] == kSPIRVImageSampledTypeName::Int) {
+      SampledT = BM->addIntegerType(32, true);
+    } else {
+      assert(false && "Invalid sampled type postfix");
+    }
+      
     SmallVector<int, 7> Ops;
-    for (unsigned I = 1; I < 8; ++I)
+    for (unsigned I = 2; I < 9; ++I)
       Ops.push_back(atoi(Postfixes[I].c_str()));
     SPIRVTypeImageDescriptor Desc(static_cast<SPIRVImageDimKind>(Ops[0]),
                                   Ops[1], Ops[2], Ops[3], Ops[4], Ops[5]);
-    return mapType(T,
-                   BM->addImageType(SampledT, Desc,
-                                    static_cast<spv::AccessQualifier>(Ops[6])));
+    auto spirv_image_type =
+        (static_cast<spv::AccessQualifier>(Ops[6]) != spv::AccessQualifierNone
+             ? BM->addImageType(SampledT, Desc,
+                                static_cast<spv::AccessQualifier>(Ops[6]))
+             : BM->addImageType(SampledT, Desc));
+    return mapType(T, spirv_image_type);
   } else if (TN == kSPIRVTypeName::SampledImg) {
     return mapType(
         T, BM->addSampledImageType(static_cast<SPIRVTypeImage *>(
@@ -559,99 +640,163 @@ SPIRVType *LLVMToSPIRVBase::transSPIRVOpaqueType(Type *T) {
                    BM->addOpaqueGenericType(SPIRVOpaqueTypeOpCodeMap::map(TN)));
 }
 
+SPIRVType *LLVMToSPIRVBase::addSignPreservingLLVMType(llvm::Type *type,
+                                                      const bool is_signed) {
+  const auto add_scalar_uint_type = [this](llvm::Type *scalar_type) {
+    assert(scalar_type->isIntegerTy());
+    return BM->addIntegerType(cast<IntegerType>(scalar_type)->getBitWidth(),
+                              false);
+  };
+
+  if (type->isVectorTy()) {
+    const auto vec_type = dyn_cast<llvm::FixedVectorType>(type);
+    auto elem_type = vec_type->getElementType();
+    auto elem_count = vec_type->getNumElements();
+    if (is_signed) {
+      return BM->addVectorType(transType(type), elem_count);
+    } else {
+      auto scalar_uint_type = add_scalar_uint_type(elem_type);
+      return BM->addVectorType(scalar_uint_type, elem_count);
+    }
+  } else {
+    assert(type->isFloatTy() || type->isIntegerTy());
+    if (is_signed) {
+      return transType(type);
+    } else {
+      return add_scalar_uint_type(type);
+    }
+  }
+}
+
 SPIRVFunction *LLVMToSPIRVBase::transFunctionDecl(Function *F) {
+  // don't translate/emit entry point declarations when the function only is a
+  // declaration, not a definition
+  if (F->isDeclaration() && F->getCallingConv() != CallingConv::FLOOR_FUNC)
+    return nullptr;
+
+  // skip any floor.* functions, these shouldn't be here
+  if (F->getName().startswith("floor."))
+    return nullptr;
+
+  // ignore any non-entry-point functions in shader mode
+  if (SrcLang == spv::SourceLanguageGLSL &&
+      F->getCallingConv() == CallingConv::FLOOR_FUNC)
+    return nullptr;
+
+  // return already translated value
   if (auto BF = getTranslatedValue(F))
     return static_cast<SPIRVFunction *>(BF);
 
-  if (F->isIntrinsic() && (!BM->isSPIRVAllowUnknownIntrinsicsEnabled() ||
-                           isKnownIntrinsic(F->getIntrinsicID()))) {
-    // We should not translate LLVM intrinsics as a function
-    assert(none_of(F->users(),
-                   [this](User *U) { return getTranslatedValue(U); }) &&
-           "LLVM intrinsics shouldn't be called in SPIRV");
-    return nullptr;
-  }
+  // all shader/glsl entry points need special handling compared to normal and
+  // kernel functions
+  const auto entry_point_type = getEntryPointType(F, SrcLang);
+  SPIRVFunction *BF = nullptr;
+  if (entry_point_type == spv::ExecutionModel::ExecutionModelKernel ||
+      entry_point_type == spv::ExecutionModel::ExecutionModelInvalid) {
+    if (F->isIntrinsic() && (!BM->isSPIRVAllowUnknownIntrinsicsEnabled() ||
+                             isKnownIntrinsic(F->getIntrinsicID()))) {
+      // We should not translate LLVM intrinsics as a function
+      assert(none_of(F->users(),
+                     [this](User *U) { return getTranslatedValue(U); }) &&
+             "LLVM intrinsics shouldn't be called in SPIRV");
+      return nullptr;
+    }
 
-  SPIRVTypeFunction *BFT = static_cast<SPIRVTypeFunction *>(
-      transType(OCLTypeToSPIRVPtr->getAdaptedType(F)));
-  SPIRVFunction *BF =
-      static_cast<SPIRVFunction *>(mapValue(F, BM->addFunction(BFT)));
-  BF->setFunctionControlMask(transFunctionControlMask(F));
-  if (F->hasName())
-    BM->setName(BF, F->getName().str());
-  if (isKernel(F))
-    BM->addEntryPoint(ExecutionModelKernel, BF->getId());
-  else if (F->getLinkage() != GlobalValue::InternalLinkage)
-    BF->setLinkageType(transLinkageType(F));
+    SPIRVTypeFunction *BFT = static_cast<SPIRVTypeFunction *>(
+        transType(OCLTypeToSPIRVPtr->getAdaptedType(F)));
+    BF =
+        static_cast<SPIRVFunction *>(mapValue(F, BM->addFunction(BFT)));
+    BF->setFunctionControlMask(transFunctionControlMask(F));
+    if (F->hasName())
+      BM->setName(BF, F->getName().str());
+    if (entry_point_type != spv::ExecutionModel::ExecutionModelInvalid)
+      BM->addEntryPoint(ExecutionModelKernel, BF->getId());
+    else if (F->getLinkage() != GlobalValue::InternalLinkage)
+      BF->setLinkageType(transLinkageType(F));
+
+    // Translate OpenCL/SYCL buffer_location metadata if it's attached to the
+    // translated function declaration
+    MDNode *BufferLocation = nullptr;
+    if (BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_fpga_buffer_location))
+      BufferLocation = ((*F).getMetadata("kernel_arg_buffer_location"));
+
+    auto Attrs = F->getAttributes();
+
+    for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;
+         ++I) {
+      auto ArgNo = I->getArgNo();
+      SPIRVFunctionParameter *BA = BF->getArgument(ArgNo);
+      if (I->hasName())
+        BM->setName(BA, I->getName().str());
+      if (I->hasByValAttr())
+        BA->addAttr(FunctionParameterAttributeByVal);
+      if (I->hasNoAliasAttr())
+        BA->addAttr(FunctionParameterAttributeNoAlias);
+      if (I->hasNoCaptureAttr())
+        BA->addAttr(FunctionParameterAttributeNoCapture);
+      if (I->hasStructRetAttr())
+        BA->addAttr(FunctionParameterAttributeSret);
+      if (I->onlyReadsMemory())
+        BA->addAttr(FunctionParameterAttributeNoWrite);
+      if (Attrs.hasAttribute(ArgNo + 1, Attribute::ZExt))
+        BA->addAttr(FunctionParameterAttributeZext);
+      if (Attrs.hasAttribute(ArgNo + 1, Attribute::SExt))
+        BA->addAttr(FunctionParameterAttributeSext);
+      if (BM->isAllowedToUseVersion(VersionNumber::SPIRV_1_1) &&
+          Attrs.hasAttribute(ArgNo + 1, Attribute::Dereferenceable))
+        BA->addDecorate(DecorationMaxByteOffset,
+                        Attrs.getAttribute(ArgNo + 1, Attribute::Dereferenceable)
+                            .getDereferenceableBytes());
+      if (BufferLocation && I->getType()->isPointerTy()) {
+        // Order of integer numbers in MD node follows the order of function
+        // parameters on which we shall attach the appropriate decoration. Add
+        // decoration only if MD value is not negative.
+        int LocID = -1;
+        if (!isa<MDString>(BufferLocation->getOperand(ArgNo)) &&
+            !isa<MDNode>(BufferLocation->getOperand(ArgNo)))
+          LocID = getMDOperandAsInt(BufferLocation, ArgNo);
+        if (LocID >= 0)
+          BA->addDecorate(DecorationBufferLocationINTEL, LocID);
+      }
+    }
+    if (Attrs.hasAttribute(AttributeList::ReturnIndex, Attribute::ZExt))
+      BF->addDecorate(DecorationFuncParamAttr, FunctionParameterAttributeZext);
+    if (Attrs.hasAttribute(AttributeList::ReturnIndex, Attribute::SExt))
+      BF->addDecorate(DecorationFuncParamAttr, FunctionParameterAttributeSext);
+    if (Attrs.hasFnAttribute("referenced-indirectly")) {
+      assert(!isEntryPoint(F) &&
+             "kernel function was marked as referenced-indirectly");
+      BF->addDecorate(DecorationReferencedIndirectlyINTEL);
+    }
 
-  // Translate OpenCL/SYCL buffer_location metadata if it's attached to the
-  // translated function declaration
-  MDNode *BufferLocation = nullptr;
-  if (BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_fpga_buffer_location))
-    BufferLocation = ((*F).getMetadata("kernel_arg_buffer_location"));
+    if (Attrs.hasFnAttribute(kVCMetadata::VCCallable) &&
+        BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_fast_composite)) {
+      BF->addDecorate(internal::DecorationCallableFunctionINTEL);
+    }
 
-  auto Attrs = F->getAttributes();
+    if (BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_vector_compute))
+      transVectorComputeMetadata(F);
 
-  for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;
-       ++I) {
-    auto ArgNo = I->getArgNo();
-    SPIRVFunctionParameter *BA = BF->getArgument(ArgNo);
-    if (I->hasName())
-      BM->setName(BA, I->getName().str());
-    if (I->hasByValAttr())
-      BA->addAttr(FunctionParameterAttributeByVal);
-    if (I->hasNoAliasAttr())
-      BA->addAttr(FunctionParameterAttributeNoAlias);
-    if (I->hasNoCaptureAttr())
-      BA->addAttr(FunctionParameterAttributeNoCapture);
-    if (I->hasStructRetAttr())
-      BA->addAttr(FunctionParameterAttributeSret);
-    if (I->onlyReadsMemory())
-      BA->addAttr(FunctionParameterAttributeNoWrite);
-    if (Attrs.hasAttribute(ArgNo + 1, Attribute::ZExt))
-      BA->addAttr(FunctionParameterAttributeZext);
-    if (Attrs.hasAttribute(ArgNo + 1, Attribute::SExt))
-      BA->addAttr(FunctionParameterAttributeSext);
-    if (BM->isAllowedToUseVersion(VersionNumber::SPIRV_1_1) &&
-        Attrs.hasAttribute(ArgNo + 1, Attribute::Dereferenceable))
-      BA->addDecorate(DecorationMaxByteOffset,
-                      Attrs.getAttribute(ArgNo + 1, Attribute::Dereferenceable)
-                          .getDereferenceableBytes());
-    if (BufferLocation && I->getType()->isPointerTy()) {
-      // Order of integer numbers in MD node follows the order of function
-      // parameters on which we shall attach the appropriate decoration. Add
-      // decoration only if MD value is not negative.
-      int LocID = -1;
-      if (!isa<MDString>(BufferLocation->getOperand(ArgNo)) &&
-          !isa<MDNode>(BufferLocation->getOperand(ArgNo)))
-        LocID = getMDOperandAsInt(BufferLocation, ArgNo);
-      if (LocID >= 0)
-        BA->addDecorate(DecorationBufferLocationINTEL, LocID);
-    }
-  }
-  if (Attrs.hasAttribute(AttributeList::ReturnIndex, Attribute::ZExt))
-    BF->addDecorate(DecorationFuncParamAttr, FunctionParameterAttributeZext);
-  if (Attrs.hasAttribute(AttributeList::ReturnIndex, Attribute::SExt))
-    BF->addDecorate(DecorationFuncParamAttr, FunctionParameterAttributeSext);
-  if (Attrs.hasFnAttribute("referenced-indirectly")) {
-    assert(!isKernel(F) &&
-           "kernel function was marked as referenced-indirectly");
-    BF->addDecorate(DecorationReferencedIndirectlyINTEL);
-  }
-
-  if (Attrs.hasFnAttribute(kVCMetadata::VCCallable) &&
-      BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_fast_composite)) {
-    BF->addDecorate(internal::DecorationCallableFunctionINTEL);
-  }
-
-  if (BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_vector_compute))
-    transVectorComputeMetadata(F);
-
-  transFPGAFunctionMetadata(BF, F);
-
-  SPIRVDBG(dbgs() << "[transFunction] " << *F << " => ";
-           spvdbgs() << *BF << '\n';)
-  return BF;
+    transFPGAFunctionMetadata(BF, F);
+
+    SPIRVDBG(dbgs() << "[transFunction (kernel)] " << *F << " => ";
+             spvdbgs() << *BF << '\n';)
+    return BF;
+  } else {
+    // shader function is always "void func_name()"
+    const auto shader_func_type =
+        llvm::FunctionType::get(llvm::Type::getVoidTy(*Ctx), false);
+    SPIRVTypeFunction *BFT =
+        static_cast<SPIRVTypeFunction *>(transType(shader_func_type));
+    BF = static_cast<SPIRVFunction *>(mapValue(F, BM->addFunction(BFT)));
+    assert(F->hasName() && "entry point function must have a name");
+    BM->setName(BF, F->getName().str());
+    BM->addEntryPoint(entry_point_type, BF->getId());
+    // NOTE: not handling/adding function parameters here
+    SPIRVDBG(dbgs() << "[transFunction (shader)] " << *F << " => ";
+             spvdbgs() << *BF << '\n';)
+    return BF;
+  }
 }
 
 void LLVMToSPIRVBase::transVectorComputeMetadata(Function *F) {
@@ -707,7 +852,7 @@ void LLVMToSPIRVBase::transVectorComputeMetadata(Function *F) {
       BA->addDecorate(DecorationSingleElementVectorINTEL);
     }
   }
-  if (!isKernel(F) &&
+  if (!isEntryPoint(F) &&
       BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_float_controls2) &&
       Attrs.hasFnAttribute(kVCMetadata::VCFloatControl)) {
 
@@ -894,7 +1039,13 @@ SPIRVValue *LLVMToSPIRVBase::transConstant(Value *V) {
   }
 
   if (isa<UndefValue>(V)) {
-    return BM->addUndef(transType(V->getType()));
+    // TODO/NOTE: don't allow global undef constants in Vulkan/GLSL until
+    // drivers (AMD) catch up
+    if (SrcLang == spv::SourceLanguageGLSL) {
+      return nullptr;
+    } else {
+      return BM->addUndef(transType(V->getType()));
+    }
   }
 
   return nullptr;
@@ -926,18 +1077,62 @@ SPIRVValue *LLVMToSPIRVBase::transValue(Value *V, SPIRVBasicBlock *BB,
 
 SPIRVInstruction *LLVMToSPIRVBase::transBinaryInst(BinaryOperator *B,
                                                    SPIRVBasicBlock *BB) {
+  // in LLVM (fneg x) is represented as (fsub +/-0 x) -> special case this to
+  // produce OpFNegate instead
+  Value *fneg_val;
+  if (PatternMatch::match(B, PatternMatch::m_FNeg(PatternMatch::m_Value(
+                                 fneg_val)))) {
+    return BM->addUnaryInst(spv::OpFNegate, transType(B->getType()),
+                            transValue(B->getOperand(1), BB), BB);
+  }
+
   unsigned LLVMOC = B->getOpcode();
+  Op BOC = OpCodeMap::map(LLVMOC);
   auto Op0 = transValue(B->getOperand(0), BB);
+
+  // take care of signed/unsigned type conversion mismatches,
+  // TODO: as with unary instructions, we need to do this properly at some point
+  const auto type = transType(B->getType());
+  const auto is_int = type->isTypeInt();
+  const auto is_sint = (is_int ? ((SPIRVTypeInt *)type)->isSigned() : false);
+  const auto is_uint = (is_int ? !((SPIRVTypeInt *)type)->isSigned() : false);
+  switch (BOC) {
+  case spv::OpUMod:
+    if (is_sint) {
+      BOC = OpSMod;
+    }
+    break;
+  case spv::OpSMod:
+    if (is_uint) {
+      BOC = OpUMod;
+    }
+    break;
+  case spv::OpUDiv:
+    if (is_sint) {
+      BOC = OpSDiv;
+    }
+    break;
+  case spv::OpSDiv:
+    if (is_uint) {
+      BOC = OpUDiv;
+    }
+    break;
+  default:
+    break;
+  }
+
   SPIRVInstruction *BI = BM->addBinaryInst(
-      transBoolOpCode(Op0, OpCodeMap::map(LLVMOC)), transType(B->getType()),
+      transBoolOpCode(Op0, BOC), type,
       Op0, transValue(B->getOperand(1), BB), BB);
 
+#if 0 // this is stupid
   if (isUnfusedMulAdd(B)) {
     Function *F = B->getFunction();
     SPIRVDBG(dbgs() << "[fp-contract] disabled for " << F->getName()
                     << ": possible fma candidate " << *B << '\n');
     joinFPContract(F, FPContract::DISABLED);
   }
+#endif
 
   return BI;
 }
@@ -963,6 +1158,7 @@ SPIRVInstruction *LLVMToSPIRVBase::transCmpInst(CmpInst *Cmp,
 
 SPIRV::SPIRVInstruction *LLVMToSPIRVBase::transUnaryInst(UnaryInstruction *U,
                                                          SPIRVBasicBlock *BB) {
+  // TODO: properly handle int/uint conversions and type handling
   Op BOC = OpNop;
   if (auto Cast = dyn_cast<AddrSpaceCastInst>(U)) {
     const auto SrcAddrSpace = Cast->getSrcTy()->getPointerAddressSpace();
@@ -1026,8 +1222,39 @@ SPIRV::SPIRVInstruction *LLVMToSPIRVBase::transUnaryInst(UnaryInstruction *U,
   }
 
   auto Op = transValue(U->getOperand(0), BB, true, FuncTransMode::Pointer);
-  return BM->addUnaryInst(transBoolOpCode(Op, BOC), transType(U->getType()), Op,
-                          BB);
+
+  // take care of signed/unsigned type conversion mismatches,
+  // as stated above this should be done properly at some point
+  // -> fixup superficial stuff caused by unary int conversion translation
+  const auto type = transType(U->getType());
+  const auto is_int = type->isTypeInt();
+  const auto is_sint = (is_int ? ((SPIRVTypeInt *)type)->isSigned() : false);
+  const auto is_uint = (is_int ? !((SPIRVTypeInt *)type)->isSigned() : false);
+  switch (BOC) {
+  case spv::OpUConvert:
+    if (is_sint) {
+      BOC = OpSConvert;
+    }
+    break;
+  case spv::OpSConvert:
+    if (is_uint) {
+      BOC = OpUConvert;
+    }
+    break;
+  case spv::OpConvertFToU:
+    if (is_sint) {
+      BOC = OpConvertFToS;
+    }
+    break;
+  case spv::OpConvertFToS:
+    if (is_uint) {
+      BOC = OpConvertFToU;
+    }
+    break;
+  default:
+    break;
+  }
+  return BM->addUnaryInst(transBoolOpCode(Op, BOC), type, Op, BB);
 }
 
 /// This helper class encapsulates information extraction from
@@ -1103,7 +1330,8 @@ private:
 spv::LoopControlMask
 LLVMToSPIRVBase::getLoopControl(const BranchInst *Branch,
                                 std::vector<SPIRVWord> &Parameters) {
-  if (!Branch)
+  // do not allow this for Vulkan at all
+  if (!Branch || SrcLang == spv::SourceLanguageGLSL)
     return spv::LoopControlMaskNone;
   MDNode *LoopMD = Branch->getMetadata("llvm.loop");
   if (!LoopMD)
@@ -1346,12 +1574,46 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
 
   if (auto GV = dyn_cast<GlobalVariable>(V)) {
     llvm::PointerType *Ty = GV->getType();
+
+    if (GV->hasName() && GV->getName().find(".vulkan") != std::string::npos) {
+      // special global variables are handled/added in transFunction
+      // (note: should only be output vars here)
+      return nullptr;
+    }
+
     // Though variables with common linkage type are initialized by 0,
     // they can be represented in SPIR-V as uninitialized variables with
     // 'Export' linkage type, just as tentative definitions look in C
     llvm::Value *Init = GV->hasInitializer() && !GV->hasCommonLinkage()
                             ? GV->getInitializer()
                             : nullptr;
+
+    SPIRVStorageClassKind StorageClass;
+    auto AddressSpace = static_cast<SPIRAddressSpace>(Ty->getAddressSpace());
+    bool IsVectorCompute =
+        BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_vector_compute) &&
+        GV->hasAttribute(kVCMetadata::VCGlobalVariable);
+    if (IsVectorCompute)
+      StorageClass =
+          VectorComputeUtil::getVCGlobalVarStorageClass(AddressSpace);
+    else {
+      // Lower global_device and global_host address spaces that were added in
+      // SYCL as part of SYCL_INTEL_usm_address_spaces extension to just global
+      // address space if device doesn't support SPV_INTEL_usm_storage_classes
+      // extension
+      if ((AddressSpace == SPIRAS_GlobalDevice ||
+           AddressSpace == SPIRAS_GlobalHost) &&
+          !BM->isAllowedToUseExtension(
+              ExtensionID::SPV_INTEL_usm_storage_classes))
+        AddressSpace = SPIRAS_Global;
+      StorageClass = SPIRSPIRVAddrSpaceMap::map(AddressSpace);
+      assert(((StorageClass == spv::StorageClassFunction && BB != nullptr) ||
+              StorageClass != spv::StorageClassFunction) &&
+             "invalid GV/BB");
+    }
+
+    // for Vulkan, we will remove invalid initializers (zero or undef needs to
+    // be present in LLVM,  but not in SPIR-V)
     SPIRVValue *BVarInit = nullptr;
     StructType *ST = Init ? dyn_cast<StructType>(Init->getType()) : nullptr;
     if (ST && ST->hasName() && isSPIRVConstantName(ST->getName())) {
@@ -1366,19 +1628,22 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
       }
       Inst->dropAllReferences();
       UnboundInst.push_back(Inst);
-      BVarInit = transValue(Init, nullptr);
+      BVarInit = (StorageClass == StorageClassWorkgroup || Init == nullptr ? nullptr : transValue(Init, nullptr));
     } else if (ST && isa<UndefValue>(Init)) {
       // Undef initializer for LLVM structure be can translated to
       // OpConstantComposite with OpUndef constituents.
-      auto I = ValueMap.find(Init);
-      if (I == ValueMap.end()) {
-        std::vector<SPIRVValue *> Elements;
-        for (Type *E : ST->elements())
-          Elements.push_back(transValue(UndefValue::get(E), nullptr));
-        BVarInit = BM->addCompositeConstant(transType(ST), Elements);
-        ValueMap[Init] = BVarInit;
-      } else
-        BVarInit = I->second;
+      if (SrcLang == spv::SourceLanguageGLSL) {
+        auto I = ValueMap.find(Init);
+        if (I == ValueMap.end()) {
+          std::vector<SPIRVValue *> Elements;
+          for (Type *E : ST->elements())
+            Elements.push_back(transValue(UndefValue::get(E), nullptr));
+          BVarInit = BM->addCompositeConstant(transType(ST), Elements);
+          ValueMap[Init] = BVarInit;
+        } else {
+          BVarInit = I->second;
+        }
+      }
     } else if (Init && !isa<UndefValue>(Init)) {
       if (!BM->isAllowedToUseExtension(
               ExtensionID::SPV_INTEL_long_constant_composite)) {
@@ -1400,33 +1665,23 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
           }
         }
       }
-      BVarInit = transValue(Init, nullptr);
+      BVarInit = (StorageClass == StorageClassWorkgroup || Init == nullptr ? nullptr : transValue(Init, nullptr));
     }
 
-    SPIRVStorageClassKind StorageClass;
-    auto AddressSpace = static_cast<SPIRAddressSpace>(Ty->getAddressSpace());
-    bool IsVectorCompute =
-        BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_vector_compute) &&
-        GV->hasAttribute(kVCMetadata::VCGlobalVariable);
-    if (IsVectorCompute)
-      StorageClass =
-          VectorComputeUtil::getVCGlobalVarStorageClass(AddressSpace);
-    else {
-      // Lower global_device and global_host address spaces that were added in
-      // SYCL as part of SYCL_INTEL_usm_address_spaces extension to just global
-      // address space if device doesn't support SPV_INTEL_usm_storage_classes
-      // extension
-      if ((AddressSpace == SPIRAS_GlobalDevice ||
-           AddressSpace == SPIRAS_GlobalHost) &&
-          !BM->isAllowedToUseExtension(
-              ExtensionID::SPV_INTEL_usm_storage_classes))
-        AddressSpace = SPIRAS_Global;
-      StorageClass = SPIRSPIRVAddrSpaceMap::map(AddressSpace);
-    }
+    // Vulkan/GLSL doesn't do linkage
+    auto linkage =
+        (SrcLang != spv::SourceLanguageGLSL ? transLinkageType(GV)
+                                            : spv::internal::LinkageTypeInternal);
 
+    // vars with Function storage must be added to the entry block
+    SPIRVBasicBlock* var_bb = nullptr;
+    if (StorageClass == spv::StorageClassFunction) {
+      var_bb = BB->getParent()->getBasicBlock(0);
+    }
     auto BVar = static_cast<SPIRVVariable *>(
-        BM->addVariable(transType(Ty), GV->isConstant(), transLinkageType(GV),
-                        BVarInit, GV->getName().str(), StorageClass, nullptr));
+        BM->addVariable(transType(Ty), GV->isConstant(), linkage,
+                        BVarInit, GV->getName().str(), StorageClass,
+                        var_bb));
 
     if (IsVectorCompute) {
       BVar->addDecorate(DecorationVectorComputeVariableINTEL);
@@ -1442,6 +1697,11 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
     }
 
     mapValue(V, BVar);
+    if (Ty->isPointerTy()) {
+      auto elem_type = Ty->getPointerElementType();
+      auto spirv_elem_type = transType(elem_type);
+      decorateComposite(elem_type, spirv_elem_type);
+    }
     spv::BuiltIn Builtin = spv::BuiltInPosition;
     if (!GV->hasName() || !getSPIRVBuiltin(GV->getName().str(), Builtin))
       return BVar;
@@ -1449,6 +1709,16 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
     return BVar;
   }
 
+  // always create a new undef variable for vulkan/glsl to workaround driver
+  // issues
+  if (isa<UndefValue>(V) && SrcLang == spv::SourceLanguageGLSL) {
+    if (BB != nullptr) {
+      return BM->addUndefInst(transType(V->getType()), BB);
+    }
+    // if this isn't inside a BB (e.g. inside a constant), just use 0
+    return BM->addConstant(transType(V->getType()), 0);
+  }
+
   if (isa<Constant>(V)) {
     auto BV = transConstant(V);
     assert(BV);
@@ -1490,11 +1760,38 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
     if (MemoryAccess.front() == 0)
       MemoryAccess.clear();
 
-    return mapValue(V,
-                    BM->addStoreInst(transValue(ST->getPointerOperand(), BB),
-                                     transValue(ST->getValueOperand(), BB, true,
-                                                FuncTransMode::Pointer),
-                                     MemoryAccess, BB));
+    // check if we need to do int <-> uint casting
+    auto dst = transValue(ST->getPointerOperand(), BB);
+    auto src = transValue(ST->getValueOperand(), BB, true, FuncTransMode::Pointer);
+    assert(dst->getType()->isTypePointer());
+    auto dst_elem_type =
+        ((SPIRVTypePointer *)dst->getType())->getPointerElementType();
+    auto src_elem_type = src->getType();
+    if (dst_elem_type != src_elem_type) {
+      bool emit_bitcast = false;
+      if (dst_elem_type->isTypeInt()) {
+        assert(src_elem_type->isTypeInt());
+        if (((SPIRVTypeInt *)dst_elem_type)->isSigned() !=
+            ((SPIRVTypeInt *)src_elem_type)->isSigned()) {
+          emit_bitcast = true;
+        }
+      } else if (dst_elem_type->isTypeVectorInt()) {
+        assert(src_elem_type->isTypeVectorInt());
+        if (((SPIRVTypeInt *)((SPIRVTypeVector *)dst_elem_type)
+                 ->getComponentType())
+                ->isSigned() !=
+            ((SPIRVTypeInt *)((SPIRVTypeVector *)src_elem_type)
+                 ->getComponentType())
+                ->isSigned()) {
+          emit_bitcast = true;
+        }
+      }
+      if (emit_bitcast) {
+        src = BM->addUnaryInst(spv::OpBitcast, dst_elem_type, src, BB);
+      }
+    }
+
+    return mapValue(V, BM->addStoreInst(dst, src, MemoryAccess, BB));
   }
 
   if (LoadInst *LD = dyn_cast<LoadInst>(V)) {
@@ -1530,8 +1827,14 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
     return mapValue(V, BI);
   }
 
-  if (dyn_cast<UnreachableInst>(V))
+  if (dyn_cast<UnreachableInst>(V)) {
+    // TODO: fix this be either creating a llvm OpKill instruction or metadata
+    if (ignore_next_unreachable) {
+      ignore_next_unreachable = false;
+      return nullptr;
+    }
     return mapValue(V, BM->addUnreachableInst(BB));
+  }
 
   if (auto RI = dyn_cast<ReturnInst>(V)) {
     if (auto RV = RI->getReturnValue())
@@ -1655,9 +1958,18 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
   }
 
   if (auto Phi = dyn_cast<PHINode>(V)) {
+    // NOTE: LLVM has the tendency to allow duplicate predecessors and PHI incoming blocks
+    // -> ensure we only add incoming values for unique predecessors
     std::vector<SPIRVValue *> IncomingPairs;
+    std::unordered_set<BasicBlock*> unique_bbs;
 
     for (size_t I = 0, E = Phi->getNumIncomingValues(); I != E; ++I) {
+      auto in_bb = Phi->getIncomingBlock(I);
+      if (unique_bbs.count(in_bb) > 0) {
+        continue;
+      }
+      unique_bbs.emplace(in_bb);
+
       IncomingPairs.push_back(transValue(Phi->getIncomingValue(I), BB, true,
                                          FuncTransMode::Pointer));
       IncomingPairs.push_back(transValue(Phi->getIncomingBlock(I), nullptr));
@@ -1691,57 +2003,97 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
     std::vector<SPIRVValue *> Indices;
     for (unsigned I = 0, E = GEP->getNumIndices(); I != E; ++I)
       Indices.push_back(transValue(GEP->getOperand(I + 1), BB));
-    auto *PointerOperand = GEP->getPointerOperand();
-    auto *TransPointerOperand = transValue(PointerOperand, BB);
-
-    // Certain array-related optimization hints can be expressed via
-    // LLVM metadata. For the purpose of linking this metadata with
-    // the accessed array variables, our GEP may have been marked into
-    // a so-called index group, an MDNode by itself.
-    if (MDNode *IndexGroup = GEP->getMetadata("llvm.index.group")) {
-      SPIRVValue *ActualMemoryPtr = TransPointerOperand;
-      if (auto *Load = dyn_cast<LoadInst>(PointerOperand)) {
-        ActualMemoryPtr = transValue(Load->getPointerOperand(), BB);
+    if (SrcLang != spv::SourceLanguageGLSL) {
+      auto *PointerOperand = GEP->getPointerOperand();
+      auto *TransPointerOperand = transValue(PointerOperand, BB);
+
+      // Certain array-related optimization hints can be expressed via
+      // LLVM metadata. For the purpose of linking this metadata with
+      // the accessed array variables, our GEP may have been marked into
+      // a so-called index group, an MDNode by itself.
+      if (MDNode *IndexGroup = GEP->getMetadata("llvm.index.group")) {
+        SPIRVValue *ActualMemoryPtr = TransPointerOperand;
+        if (auto *Load = dyn_cast<LoadInst>(PointerOperand)) {
+          ActualMemoryPtr = transValue(Load->getPointerOperand(), BB);
+        }
+        SPIRVId AccessedArrayId = ActualMemoryPtr->getId();
+        unsigned NumOperands = IndexGroup->getNumOperands();
+        // When we're working with embedded loops, it's natural that
+        // the outer loop's hints apply to all code contained within.
+        // The inner loop's specific hints, however, should stay private
+        // to the inner loop's scope.
+        // Consequently, the following division of the index group metadata
+        // nodes emerges:
+
+        // 1) The metadata node has no operands. It will be directly referenced
+        //    from within the optimization hint metadata.
+        if (NumOperands == 0)
+          IndexGroupArrayMap[IndexGroup].insert(AccessedArrayId);
+        // 2) The metadata node has several operands. It serves to link an index
+        //    group specific to some embedded loop with other index groups that
+        //    mark the same array variable for the outer loop(s).
+        for (unsigned I = 0; I < NumOperands; ++I) {
+          auto *ContainedIndexGroup = getMDOperandAsMDNode(IndexGroup, I);
+          IndexGroupArrayMap[ContainedIndexGroup].insert(AccessedArrayId);
+        }
       }
-      SPIRVId AccessedArrayId = ActualMemoryPtr->getId();
-      unsigned NumOperands = IndexGroup->getNumOperands();
-      // When we're working with embedded loops, it's natural that
-      // the outer loop's hints apply to all code contained within.
-      // The inner loop's specific hints, however, should stay private
-      // to the inner loop's scope.
-      // Consequently, the following division of the index group metadata
-      // nodes emerges:
-
-      // 1) The metadata node has no operands. It will be directly referenced
-      //    from within the optimization hint metadata.
-      if (NumOperands == 0)
-        IndexGroupArrayMap[IndexGroup].insert(AccessedArrayId);
-      // 2) The metadata node has several operands. It serves to link an index
-      //    group specific to some embedded loop with other index groups that
-      //    mark the same array variable for the outer loop(s).
-      for (unsigned I = 0; I < NumOperands; ++I) {
-        auto *ContainedIndexGroup = getMDOperandAsMDNode(IndexGroup, I);
-        IndexGroupArrayMap[ContainedIndexGroup].insert(AccessedArrayId);
+
+      return mapValue(V, BM->addPtrAccessChainInst(transType(GEP->getType()),
+                                                   TransPointerOperand, Indices,
+                                                   BB, GEP->isInBounds()));
+    } else {
+      // with variable pointers we can now use PtrAccessChain instead of the simple AccessChain (for SSBOs, local memory and physical SSBOs)
+      auto gep_type = transType(GEP->getType());
+      auto gep_value = transValue(GEP->getPointerOperand(), BB);
+      auto gep_value_type = gep_value->getType();
+      const auto storage_class = gep_value_type->getPointerStorageClass();
+      if (storage_class == spv::StorageClassWorkgroup ||
+          storage_class == spv::StorageClassPhysicalStorageBuffer ||
+          storage_class == spv::StorageClassStorageBuffer) {
+        // must still treat access to SSBO runtime arrays specially by adding two additional 0 indices
+        if (storage_class == spv::StorageClassStorageBuffer) {
+          auto gep_value_elem_type = gep_value_type->getPointerElementType();
+          if (gep_value_elem_type->isTypeStruct()) {
+            auto gep_struct_type = (SPIRV::SPIRVTypeStruct*)gep_value_elem_type;
+            if (gep_struct_type->getMemberCount() > 0 && gep_struct_type->getMemberType(0)->isTypeRuntimeArray()) {
+              auto zero_const = transValue(llvm::ConstantInt::get(llvm::Type::getInt32Ty(*Ctx), 0), BB);
+              Indices.insert(Indices.begin(), zero_const);
+              Indices.insert(Indices.begin(), zero_const);
+            }
+          }
+        }
+        return mapValue(
+            V, BM->addPtrAccessChainInst(gep_type, gep_value,
+                                         Indices, BB, false /* never emit inbounds */));
+      } else {
+        // for all other storage classes: fall back to (Inbounds)AccessChain
+        return mapValue(
+            V, BM->addAccessChainInst(transType(GEP->getType()),
+                                      transValue(GEP->getPointerOperand(), BB),
+                                      Indices, BB, GEP->isInBounds()));
       }
     }
-
-    return mapValue(V, BM->addPtrAccessChainInst(transType(GEP->getType()),
-                                                 TransPointerOperand, Indices,
-                                                 BB, GEP->isInBounds()));
   }
 
   if (auto Ext = dyn_cast<ExtractElementInst>(V)) {
     auto Index = Ext->getIndexOperand();
-    if (auto Const = dyn_cast<ConstantInt>(Index))
-      return mapValue(V, BM->addCompositeExtractInst(
-                             transType(Ext->getType()),
-                             transValue(Ext->getVectorOperand(), BB),
+    if (auto Const = dyn_cast<ConstantInt>(Index)) {
+      auto val = transValue(Ext->getVectorOperand(), BB);
+      SPIRVType *type = nullptr;
+      if (val->getType()->isTypeVector()) {
+        // assume component type that we've already mapped
+        type = val->getType()->getVectorComponentType();
+      } else {
+        type = transType(Ext->getType());
+      }
+      return mapValue(V, BM->addCompositeExtractInst(type, val,
                              std::vector<SPIRVWord>(1, Const->getZExtValue()),
                              BB));
-    else
+    } else {
       return mapValue(V, BM->addVectorExtractDynamicInst(
                              transValue(Ext->getVectorOperand(), BB),
                              transValue(Index, BB), BB));
+    }
   }
 
   if (auto Ins = dyn_cast<InsertElementInst>(V)) {
@@ -1821,6 +2173,7 @@ LLVMToSPIRVBase::transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
     BM->SPIRVCK(false, InvalidInstruction, toString(Inst));
   }
 
+  errs() << "not implemented: " << *V << "\n";
   llvm_unreachable("Not implemented");
   return nullptr;
 }
@@ -1835,7 +2188,7 @@ SPIRVType *LLVMToSPIRVBase::mapType(Type *T, SPIRVType *BT) {
   return BT;
 }
 
-SPIRVValue *LLVMToSPIRVBase::mapValue(Value *V, SPIRVValue *BV) {
+SPIRVValue *LLVMToSPIRVBase::mapValue(const Value *V, SPIRVValue *BV) {
   auto Loc = ValueMap.find(V);
   if (Loc != ValueMap.end()) {
     if (Loc->second == BV)
@@ -1866,7 +2219,7 @@ bool LLVMToSPIRVBase::transDecoration(Value *V, SPIRVValue *BV) {
     }
   }
 
-  if (auto BVF = dyn_cast_or_null<FPMathOperator>(V)) {
+  if (auto BVF = dyn_cast_or_null<FPMathOperator>(V); BVF && SrcLang != spv::SourceLanguageGLSL) {
     auto Opcode = BVF->getOpcode();
     if (Opcode == Instruction::FAdd || Opcode == Instruction::FSub ||
         Opcode == Instruction::FMul || Opcode == Instruction::FDiv ||
@@ -1915,6 +2268,11 @@ bool LLVMToSPIRVBase::transDecoration(Value *V, SPIRVValue *BV) {
 }
 
 bool LLVMToSPIRVBase::transAlign(Value *V, SPIRVValue *BV) {
+  // shader doesn't have the alignment decoration -> just return
+  if (SrcLang == spv::SourceLanguageGLSL) {
+    return true;
+  }
+
   if (auto AL = dyn_cast<AllocaInst>(V)) {
     BM->setAlignment(BV, AL->getAlignment());
     return true;
@@ -1962,9 +2320,19 @@ void LLVMToSPIRVBase::transMemAliasingINTELDecorations(Value *V,
 
 /// Do this after source language is set.
 bool LLVMToSPIRVBase::transBuiltinSet() {
+  SPIRVWord Ver = 0;
+  SourceLanguage Kind = BM->getSourceLanguage(&Ver);
+  assert((Kind == SourceLanguageOpenCL_C || Kind == SourceLanguageOpenCL_CPP ||
+          Kind == SourceLanguageGLSL) && "not supported");
+
   SPIRVId EISId;
-  if (!BM->importBuiltinSet("OpenCL.std", &EISId))
-    return false;
+  if (Kind != SourceLanguageGLSL) {
+    if (!BM->importBuiltinSet("OpenCL.std", &EISId))
+      return false;
+  } else {
+    if (!BM->importBuiltinSet("GLSL.std.450", &EISId))
+      return false;
+  }
   if (SPIRVMDWalker(*M).getNamedMD("llvm.dbg.cu")) {
     if (!BM->importBuiltinSet(
             SPIRVBuiltinSetNameMap::map(BM->getDebugInfoEIS()), &EISId))
@@ -2344,7 +2712,68 @@ LLVMToSPIRVBase::applyRoundingModeConstraint(Value *V, SPIRVInstruction *I) {
   return I;
 }
 
-static SPIRVWord getBuiltinIdForIntrinsic(Intrinsic::ID IID) {
+static SPIRVWord getBuiltinIdForIntrinsicGLSL(Intrinsic::ID IID) {
+  switch (IID) {
+  case Intrinsic::ceil:
+    return GLSLLIB::Ceil;
+  case Intrinsic::cos:
+    return GLSLLIB::Cos;
+  case Intrinsic::exp:
+    return GLSLLIB::Exp;
+  case Intrinsic::exp2:
+    return GLSLLIB::Exp2;
+  case Intrinsic::fabs:
+    return GLSLLIB::FAbs;
+  case Intrinsic::floor:
+    return GLSLLIB::Floor;
+  case Intrinsic::fma:
+    return GLSLLIB::Fma;
+  case Intrinsic::log:
+    return GLSLLIB::Log;
+  case Intrinsic::log2:
+    return GLSLLIB::Log2;
+  case Intrinsic::maximum:
+    return GLSLLIB::FMax;
+  case Intrinsic::maxnum:
+    return GLSLLIB::FMax;
+  case Intrinsic::minimum:
+    return GLSLLIB::FMin;
+  case Intrinsic::minnum:
+    return GLSLLIB::FMin;
+  case Intrinsic::nearbyint:
+    return GLSLLIB::RoundEven;
+  case Intrinsic::pow:
+    return GLSLLIB::Pow;
+  case Intrinsic::rint:
+    return GLSLLIB::RoundEven;
+  case Intrinsic::round:
+    return GLSLLIB::Round;
+  case Intrinsic::roundeven:
+    return GLSLLIB::RoundEven;
+  case Intrinsic::sin:
+    return GLSLLIB::Sin;
+  case Intrinsic::sqrt:
+    return GLSLLIB::Sqrt;
+  case Intrinsic::trunc:
+    return GLSLLIB::Trunc;
+  case Intrinsic::abs:
+    return GLSLLIB::SAbs;
+  case Intrinsic::ctlz:
+  case Intrinsic::cttz:
+    assert(false && "ctz/clz are not supported with GLSL/Vulkan - use libfloor wrappers instead");
+    return 0;
+  case Intrinsic::copysign:
+  case Intrinsic::log10:
+  case Intrinsic::powi:
+    assert(false && "intrinsic not supported with GLSL/Vulkan!");
+    return 0;
+  default:
+    assert(false && "Builtin ID requested for Unhandled intrinsic!");
+    return 0;
+  }
+}
+
+static SPIRVWord getBuiltinIdForIntrinsicOpenCL(Intrinsic::ID IID) {
   switch (IID) {
   // Note: In some cases the semantics of the OpenCL builtin are not identical
   //       to the semantics of the corresponding LLVM IR intrinsic. The LLVM
@@ -2401,12 +2830,25 @@ static SPIRVWord getBuiltinIdForIntrinsic(Intrinsic::ID IID) {
     return OpenCLLIB::Sqrt;
   case Intrinsic::trunc:
     return OpenCLLIB::Trunc;
+  case Intrinsic::abs:
+    return OpenCLLIB::SAbs;
+  case Intrinsic::ctlz:
+    return OpenCLLIB::Clz;
+  case Intrinsic::cttz:
+    return OpenCLLIB::Ctz;
   default:
     assert(false && "Builtin ID requested for Unhandled intrinsic!");
     return 0;
   }
 }
 
+static SPIRVWord getBuiltinIdForIntrinsic(Intrinsic::ID IID, SPIRVWord src_lang) {
+  if ((spv::SourceLanguage)src_lang == spv::SourceLanguage::SourceLanguageGLSL) {
+    return getBuiltinIdForIntrinsicGLSL(IID);
+  }
+  return getBuiltinIdForIntrinsicOpenCL(IID);
+}
+
 SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
                                                 SPIRVBasicBlock *BB) {
   auto GetMemoryAccess = [](MemIntrinsic *MI) -> std::vector<SPIRVWord> {
@@ -2431,6 +2873,7 @@ SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
   // LLVM intrinsics with known translation to SPIR-V are handled here. They
   // also must be registered at isKnownIntrinsic function in order to make
   // -spirv-allow-unknown-intrinsics work correctly.
+  const auto ext_set = (SrcLang == SourceLanguageGLSL ? SPIRVEIS_GLSL : SPIRVEIS_OpenCL);
   switch (II->getIntrinsicID()) {
   case Intrinsic::assume: {
     // llvm.assume translation is currently supported only within
@@ -2468,10 +2911,10 @@ SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
   case Intrinsic::trunc: {
     if (!checkTypeForSPIRVExtendedInstLowering(II, BM))
       break;
-    SPIRVWord ExtOp = getBuiltinIdForIntrinsic(II->getIntrinsicID());
+    SPIRVWord ExtOp = getBuiltinIdForIntrinsic(II->getIntrinsicID(), SrcLang);
     SPIRVType *STy = transType(II->getType());
     std::vector<SPIRVValue *> Ops(1, transValue(II->getArgOperand(0), BB));
-    return BM->addExtInst(STy, BM->getExtInstSetId(SPIRVEIS_OpenCL), ExtOp, Ops,
+    return BM->addExtInst(STy, BM->getExtInstSetId(ext_set), ExtOp, Ops,
                           BB);
   }
   // Binary FP intrinsics
@@ -2484,11 +2927,11 @@ SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
   case Intrinsic::minnum: {
     if (!checkTypeForSPIRVExtendedInstLowering(II, BM))
       break;
-    SPIRVWord ExtOp = getBuiltinIdForIntrinsic(II->getIntrinsicID());
+    SPIRVWord ExtOp = getBuiltinIdForIntrinsic(II->getIntrinsicID(), SrcLang);
     SPIRVType *STy = transType(II->getType());
     std::vector<SPIRVValue *> Ops{transValue(II->getArgOperand(0), BB),
                                   transValue(II->getArgOperand(1), BB)};
-    return BM->addExtInst(STy, BM->getExtInstSetId(SPIRVEIS_OpenCL), ExtOp, Ops,
+    return BM->addExtInst(STy, BM->getExtInstSetId(ext_set), ExtOp, Ops,
                           BB);
   }
   case Intrinsic::umin:
@@ -2515,12 +2958,12 @@ SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
   case Intrinsic::fma: {
     if (!checkTypeForSPIRVExtendedInstLowering(II, BM))
       break;
-    SPIRVWord ExtOp = OpenCLLIB::Fma;
+    SPIRVWord ExtOp = getBuiltinIdForIntrinsic(II->getIntrinsicID(), SrcLang);
     SPIRVType *STy = transType(II->getType());
     std::vector<SPIRVValue *> Ops{transValue(II->getArgOperand(0), BB),
                                   transValue(II->getArgOperand(1), BB),
                                   transValue(II->getArgOperand(2), BB)};
-    return BM->addExtInst(STy, BM->getExtInstSetId(SPIRVEIS_OpenCL), ExtOp, Ops,
+    return BM->addExtInst(STy, BM->getExtInstSetId(ext_set), ExtOp, Ops,
                           BB);
   }
   case Intrinsic::abs: {
@@ -2528,10 +2971,10 @@ SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
       break;
     // LLVM has only one version of abs and it is only for signed integers. We
     // unconditionally choose SAbs here
-    SPIRVWord ExtOp = OpenCLLIB::SAbs;
+    SPIRVWord ExtOp = getBuiltinIdForIntrinsic(II->getIntrinsicID(), SrcLang);
     SPIRVType *STy = transType(II->getType());
     std::vector<SPIRVValue *> Ops(1, transValue(II->getArgOperand(0), BB));
-    return BM->addExtInst(STy, BM->getExtInstSetId(SPIRVEIS_OpenCL), ExtOp, Ops,
+    return BM->addExtInst(STy, BM->getExtInstSetId(ext_set), ExtOp, Ops,
                           BB);
   }
   case Intrinsic::ctpop: {
@@ -2540,11 +2983,10 @@ SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
   }
   case Intrinsic::ctlz:
   case Intrinsic::cttz: {
-    SPIRVWord ExtOp = II->getIntrinsicID() == Intrinsic::ctlz ? OpenCLLIB::Clz
-                                                              : OpenCLLIB::Ctz;
+    SPIRVWord ExtOp = getBuiltinIdForIntrinsic(II->getIntrinsicID(), SrcLang);
     SPIRVType *Ty = transType(II->getType());
     std::vector<SPIRVValue *> Ops(1, transValue(II->getArgOperand(0), BB));
-    return BM->addExtInst(Ty, BM->getExtInstSetId(SPIRVEIS_OpenCL), ExtOp, Ops,
+    return BM->addExtInst(Ty, BM->getExtInstSetId(ext_set), ExtOp, Ops,
                           BB);
   }
   case Intrinsic::expect: {
@@ -2665,7 +3107,7 @@ SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
     // If allowed, let's replace llvm.fmuladd.* with mad from OpenCL extended
     // instruction set, as it has the same semantic for FULL_PROFILE OpenCL
     // devices (implementation-defined for EMBEDDED_PROFILE).
-    if (BM->shouldReplaceLLVMFmulAddWithOpenCLMad()) {
+    if (BM->shouldReplaceLLVMFmulAddWithOpenCLMad() && ext_set == SPIRVEIS_OpenCL) {
       std::vector<SPIRVValue *> Ops{transValue(II->getArgOperand(0), BB),
                                     transValue(II->getArgOperand(1), BB),
                                     transValue(II->getArgOperand(2), BB)};
@@ -2738,14 +3180,43 @@ SPIRVValue *LLVMToSPIRVBase::transIntrinsicInst(IntrinsicInst *II,
         transType(PointerType::get(Val->getType(), SPIRV::SPIRAS_Constant));
     SPIRVValue *Source = BM->addUnaryInst(OpBitcast, SourceTy, Var, BB);
     SPIRVValue *Target = transValue(MSI->getRawDest(), BB);
+    assert(SrcLang != spv::SourceLanguageGLSL && "unhandled memset during Vulkan/SPIR-V emission");
     return BM->addCopyMemorySizedInst(Target, Source, CompositeTy->getLength(),
                                       GetMemoryAccess(MSI), BB);
   } break;
-  case Intrinsic::memcpy:
-    return BM->addCopyMemorySizedInst(
-        transValue(II->getOperand(0), BB), transValue(II->getOperand(1), BB),
-        transValue(II->getOperand(2), BB),
-        GetMemoryAccess(cast<MemIntrinsic>(II)), BB);
+  case Intrinsic::memcpy: {
+    auto dst = II->getOperand(0);
+    auto src = II->getOperand(1);
+    if (SrcLang == spv::SourceLanguageGLSL) {
+      // OpCopyMemory has the requirement that we copy to/from the actual underlying type, not i8*
+      // -> remove bitcasts
+      do {
+        auto bitcast = dyn_cast_or_null<BitCastInst>(dst);
+        if (!bitcast) {
+          break;
+        }
+        dst = bitcast->getOperand(0);
+      } while(true);
+      do {
+        auto bitcast = dyn_cast_or_null<BitCastInst>(src);
+        if (!bitcast) {
+          break;
+        }
+        src = bitcast->getOperand(0);
+      } while(true);
+      assert(dst->getType()->isPointerTy());
+      assert(src->getType()->isPointerTy());
+      // -> assert we're actually copying data of the same type
+      assert(dst->getType()->getPointerElementType() ==
+             src->getType()->getPointerElementType());
+      return BM->addCopyMemoryInst(transValue(dst, BB), transValue(src, BB),
+          GetMemoryAccess(cast<MemIntrinsic>(II)), BB);
+    } else {
+      return BM->addCopyMemorySizedInst(transValue(dst, BB),
+          transValue(src, BB), transValue(II->getOperand(2), BB),
+          GetMemoryAccess(cast<MemIntrinsic>(II)), BB);
+    }
+  }
   case Intrinsic::lifetime_start:
   case Intrinsic::lifetime_end: {
     Op OC = (II->getIntrinsicID() == Intrinsic::lifetime_start)
@@ -3001,7 +3472,7 @@ SPIRVValue *LLVMToSPIRVBase::transDirectCallInst(CallInst *CI,
 
   SmallVector<std::string, 2> Dec;
   if (isBuiltinTransToExtInst(CI->getCalledFunction(), &ExtSetKind, &ExtOp,
-                              &Dec))
+                &Dec)) {
     return addDecorations(
         BM->addExtInst(
             transType(CI->getType()), BM->getExtInstSetId(ExtSetKind), ExtOp,
@@ -3009,29 +3480,226 @@ SPIRVValue *LLVMToSPIRVBase::transDirectCallInst(CallInst *CI,
                            SPIRVEntry::createUnique(ExtSetKind, ExtOp).get()),
             BB),
         Dec);
-
-  Function *Callee = CI->getCalledFunction();
-  if (Callee->isDeclaration()) {
-    SPIRVDBG(dbgs() << "[fp-contract] disabled for " << F->getName().str()
-                    << ": call to an undefined function " << *CI << '\n');
-    joinFPContract(CI->getFunction(), FPContract::DISABLED);
-  } else {
-    FPContract CalleeFPC = getFPContract(Callee);
-    joinFPContract(CI->getFunction(), CalleeFPC);
-    if (CalleeFPC == FPContract::DISABLED) {
-      SPIRVDBG(dbgs() << "[fp-contract] disabled for " << F->getName().str()
-                      << ": call to a function with disabled contraction: "
-                      << *CI << '\n');
-    }
   }
 
-  return BM->addCallInst(
-      transFunctionDecl(Callee),
-      transArguments(CI, BB, SPIRVEntry::createUnique(OpFunctionCall).get()),
-      BB);
-}
+  // helper functions to force an integer value to be unsigned or signed
+  const auto force_uint_value = [&BB, this](SPIRVValue *val) -> SPIRVValue * {
+    auto type = val->getType();
+    if (!type->isTypeInt()) {
+      assert(false && "expected an integer type");
+      return val;
+    }
+    if (((SPIRVTypeInt *)type)->isSigned()) {
+      // bitcast to unsigned
+      return BM->addUnaryInst(spv::OpBitcast,
+                              ((SPIRVTypeInt *)type)->getUnsigned(), val, BB);
+    }
+    // already unsigned
+    return val;
+  };
+  const auto force_int_value = [&BB, this](SPIRVValue *val) -> SPIRVValue * {
+    auto type = val->getType();
+    if (!type->isTypeInt()) {
+      assert(false && "expected an integer type");
+      return val;
+    }
+    if (!((SPIRVTypeInt *)type)->isSigned()) {
+      // bitcast to signed
+      return BM->addUnaryInst(spv::OpBitcast,
+                              ((SPIRVTypeInt *)type)->getSigned(), val, BB);
+    }
+    // already signed
+    return val;
+  };
 
-SPIRVValue *LLVMToSPIRVBase::transIndirectCallInst(CallInst *CI,
+  // TODO: put this into an extra function + use lut
+  if (MangledName.startswith("floor.")) {
+    if (MangledName.startswith("floor.composite_construct.")) {
+      std::vector<SPIRVWord> Constituents;
+      for (const auto &elem : CI->arg_operands()) {
+        Constituents.emplace_back(transValue(elem, BB)->getId());
+      }
+      return BM->addCompositeConstructInst(transType(CI->getType()),
+                                           Constituents, BB);
+    } else if (MangledName == "floor.dfdx.f32" ||
+               MangledName == "floor.dfdy.f32" ||
+               MangledName == "floor.fwidth.f32") {
+      auto OC = spv::OpDPdx;
+      if (MangledName == "floor.dfdy.f32")
+        OC = spv::OpDPdy;
+      if (MangledName == "floor.fwidth.f32")
+        OC = spv::OpFwidth;
+      assert(CI->getArgOperand(0)->getType() == CI->getType() &&
+             "invalid derivative type");
+      return BM->addDerivativeInst(OC, transValue(CI->getArgOperand(0), BB),
+                                   BB);
+    } else if (MangledName == "floor.discard_fragment") {
+      // since "discard" can't be modelled as a single noreturn +
+      // unreachable-after-call instruction right now, but must add an
+      // "additional" unreachable instead, we need to get rid of (ignore) the
+      // next unreachable (this isn't particularly nice, but we can't do this on
+      // the llvm side, b/c it would badly break things)
+      ignore_next_unreachable = true;
+      return BM->addKillInst(BB);
+    } else if (MangledName.startswith("floor.find_int_lsb.")) {
+      auto arg = transValue(CI->getArgOperand(0), BB);
+      if (MangledName.startswith("floor.find_int_lsb.u")) {
+        // force uint eval
+        arg = force_uint_value(arg);
+      }
+      return BM->addExtInst(
+          ((SPIRVTypeInt *)arg->getType())->getSigned() /* force signed */,
+          BM->getExtInstSetId(SPIRVEIS_GLSL), GLSLLIB::FindILsb, getVec(arg), BB);
+    } else if (MangledName.startswith("floor.find_int_msb.")) {
+      auto arg = transValue(CI->getArgOperand(0), BB);
+      bool is_uint = false;
+      if (MangledName.startswith("floor.find_int_msb.u")) {
+        // force uint eval
+        arg = force_uint_value(arg);
+        is_uint = true;
+      } else if (MangledName.startswith("floor.find_int_msb.s")) {
+        // force int eval
+        arg = force_int_value(arg);
+      }
+      return BM->addExtInst(
+          ((SPIRVTypeInt *)arg->getType())->getSigned() /* force signed */,
+          BM->getExtInstSetId(SPIRVEIS_GLSL), (is_uint ? GLSLLIB::FindUMsb : GLSLLIB::FindSMsb),
+          getVec(arg), BB);
+    } else if (MangledName.startswith("floor.bit_reverse.")) {
+      auto arg = transValue(CI->getArgOperand(0), BB);
+      if (MangledName.startswith("floor.bit_reverse.u")) {
+        // force uint eval
+        arg = force_uint_value(arg);
+      }
+      return BM->addBitReverseInst(arg->getType(), arg, BB);
+    } else if (MangledName.startswith("floor.bit_count.")) {
+      auto arg = transValue(CI->getArgOperand(0), BB);
+      if (MangledName.startswith("floor.bit_count.u")) {
+        // force uint eval
+        arg = force_uint_value(arg);
+      }
+      return BM->addBitCountInst(arg->getType(), arg, BB);
+    } else if (MangledName.startswith("floor.image_array_load.")) {
+      auto img = CI->getOperand(0);
+      const auto img_type_iter = image_type_map.find(img);
+      assert(img_type_iter != image_type_map.end() && "unknown image");
+
+      auto img_ptr_type = BM->addPointerType(spv::StorageClassUniformConstant,
+                                             img_type_iter->second);
+
+      auto img_array = transValue(CI->getOperand(0), BB);
+      const std::vector<SPIRVValue *> indices{
+          transValue(CI->getOperand(1), BB)};
+      auto gep =
+          BM->addAccessChainInst(img_ptr_type, img_array, indices, BB, true);
+      return BM->addLoadInst(gep, {}, BB);
+    } else if (MangledName == "floor.loop_merge") {
+      auto merge_bb = transValue(CI->getArgOperand(0), nullptr);
+      auto continue_bb = transValue(CI->getArgOperand(1), nullptr);
+      // NOTE: not allowing any control hints, b/c LLVM will have already optimized everything
+      return BM->addLoopMergeInst(merge_bb->getId(), continue_bb->getId(), spv::LoopControlMaskNone, {}, BB);
+    } else if (MangledName == "floor.selection_merge") {
+      auto merge_bb = (SPIRVBasicBlock *)transValue(CI->getArgOperand(0), nullptr);
+      // NOTE: not allowing any control hints, b/c LLVM will have already optimized
+      // everything - except for structured CFG insanity that we needed to create
+      // -> always mark as flatten and (hopefully) let vendor compilers deal with this
+      return BM->addSelectionMergeInst(merge_bb->getId(), spv::SelectionControlFlattenMask, BB);
+    } else if (MangledName.startswith("floor.pack_") ||
+               MangledName.startswith("floor.unpack_")) {
+      static const std::unordered_map<std::string, GLSLExtOpKind> pack_lut{
+          {"floor.pack_snorm_4x8", GLSLLIB::PackSnorm4x8},
+          {"floor.pack_unorm_4x8", GLSLLIB::PackUnorm4x8},
+          {"floor.pack_snorm_2x16", GLSLLIB::PackSnorm2x16},
+          {"floor.pack_unorm_2x16", GLSLLIB::PackUnorm2x16},
+          {"floor.pack_half_2x16", GLSLLIB::PackHalf2x16},
+          {"floor.pack_double_2x32", GLSLLIB::PackDouble2x32},
+          {"floor.unpack_snorm_4x8", GLSLLIB::UnpackSnorm4x8},
+          {"floor.unpack_unorm_4x8", GLSLLIB::UnpackUnorm4x8},
+          {"floor.unpack_snorm_2x16", GLSLLIB::UnpackSnorm2x16},
+          {"floor.unpack_unorm_2x16", GLSLLIB::UnpackUnorm2x16},
+          {"floor.unpack_half_2x16", GLSLLIB::UnpackHalf2x16},
+          {"floor.unpack_double_2x32", GLSLLIB::UnpackDouble2x32},
+      };
+      const auto ext_op = pack_lut.find(MangledName.str());
+      if (ext_op == pack_lut.end()) {
+        errs() << "unknown pack/unpack call: " << MangledName << "\n";
+        return nullptr;
+      }
+
+      SPIRVType *ret_type = nullptr;
+      if (MangledName.startswith("floor.pack_") &&
+          MangledName != "floor.pack_double_2x32") {
+        // enforce 32-bit unsigned integer return type
+        ret_type = BM->addIntegerType(32, false);
+      } else {
+        // otherwise, simply translate the return type
+        ret_type = transType(CI->getType());
+      }
+
+      auto args = transValue(getArguments(CI), BB);
+      if (args.size() != 1) {
+        errs() << "invalid arg count for pack/unpack call: " << MangledName
+               << "\n";
+        return nullptr;
+      }
+
+      // enforce 32-bit unsigned integer arg type
+      if (MangledName.startswith("floor.unpack_") &&
+          MangledName != "floor.unpack_double_2x32") {
+        if (((SPIRVTypeInt *)args[0]->getType())->isSigned()) {
+          args[0] = BM->addUnaryInst(
+              spv::OpBitcast, BM->addIntegerType(32, false), args[0], BB);
+        }
+      }
+
+      return BM->addExtInst(ret_type, BM->getExtInstSetId(SPIRVEIS_GLSL), ext_op->second, args, BB);
+    } else if (MangledName.startswith("floor.bitcast.")) {
+      auto args = transValue(getArguments(CI), BB);
+      if (args.size() != 1) {
+        errs() << "invalid arg count for bitcast call: " << MangledName << "\n";
+        return nullptr;
+      }
+      transType(CI->getType());
+      if (MangledName == "floor.bitcast.f32.i32") {
+        return BM->addUnaryInst(spv::OpBitcast, BM->addIntegerType(32, true),
+                                args[0], BB);
+      } else if (MangledName == "floor.bitcast.f32.u32") {
+        return BM->addUnaryInst(spv::OpBitcast, BM->addIntegerType(32, false),
+                                args[0], BB);
+      } else if (MangledName == "floor.bitcast.i32.f32") {
+        return BM->addUnaryInst(spv::OpBitcast, BM->addFloatType(32), args[0],
+                                BB);
+      } else if (MangledName == "floor.bitcast.u32.f32") {
+        return BM->addUnaryInst(spv::OpBitcast, BM->addFloatType(32), args[0],
+                                BB);
+      }
+      // else: fallthrough
+    }
+    errs() << "unhandled floor func: " << MangledName << "\n";
+  }
+
+  Function *Callee = CI->getCalledFunction();
+  if (Callee->isDeclaration()) {
+    SPIRVDBG(dbgs() << "[fp-contract] disabled for " << F->getName().str()
+                    << ": call to an undefined function " << *CI << '\n');
+    joinFPContract(CI->getFunction(), FPContract::DISABLED);
+  } else {
+    FPContract CalleeFPC = getFPContract(Callee);
+    joinFPContract(CI->getFunction(), CalleeFPC);
+    if (CalleeFPC == FPContract::DISABLED) {
+      SPIRVDBG(dbgs() << "[fp-contract] disabled for " << F->getName().str()
+                      << ": call to a function with disabled contraction: "
+                      << *CI << '\n');
+    }
+  }
+
+  return BM->addCallInst(
+      transFunctionDecl(Callee),
+      transArguments(CI, BB, SPIRVEntry::createUnique(OpFunctionCall).get()),
+      BB);
+}
+
+SPIRVValue *LLVMToSPIRVBase::transIndirectCallInst(CallInst *CI,
                                                    SPIRVBasicBlock *BB) {
   if (!BM->checkExtension(ExtensionID::SPV_INTEL_function_pointers,
                           SPIRVEC_FunctionPointers, toString(CI)))
@@ -3073,12 +3741,31 @@ SPIRVValue *LLVMToSPIRVBase::transAsmCallINTEL(CallInst *CI,
 bool LLVMToSPIRVBase::transAddressingMode() {
   Triple TargetTriple(M->getTargetTriple());
 
-  if (TargetTriple.isArch32Bit())
-    BM->setAddressingModel(AddressingModelPhysical32);
-  else
-    BM->setAddressingModel(AddressingModelPhysical64);
-  // Physical addressing model requires Addresses capability
-  BM->addCapability(CapabilityAddresses);
+  if (TargetTriple.getEnvironment() != llvm::Triple::EnvironmentType::Vulkan) {
+    if (TargetTriple.isArch32Bit())
+      BM->setAddressingModel(AddressingModelPhysical32);
+    else
+      BM->setAddressingModel(AddressingModelPhysical64);
+    // Physical addressing model requires Addresses capability
+    BM->addCapability(CapabilityAddresses);
+    // OpenCL memory model requires Kernel capability
+    BM->setMemoryModel(MemoryModelOpenCL);
+  } else {
+    BM->setAddressingModel(AddressingModelPhysicalStorageBuffer64);
+    BM->setMemoryModel(MemoryModelVulkan);
+
+    // always add these
+    BM->addCapability(CapabilityShader);
+    BM->addCapability(CapabilityVulkanMemoryModel);
+    BM->addCapability(CapabilityVulkanMemoryModelDeviceScope);
+    BM->addCapability(CapabilityPhysicalStorageBufferAddresses);
+    BM->addCapability(CapabilityVariablePointersStorageBuffer);
+    BM->addCapability(CapabilityVariablePointers);
+    BM->addCapability(CapabilityUniformBufferArrayDynamicIndexing);
+    BM->addCapability(CapabilityStorageBufferArrayDynamicIndexing);
+    BM->addCapability(CapabilitySampledImageArrayDynamicIndexing);
+    BM->addCapability(CapabilityStorageImageArrayDynamicIndexing);
+  }
   return true;
 }
 std::vector<SPIRVValue *>
@@ -3172,7 +3859,42 @@ void LLVMToSPIRVBase::transGlobalIOPipeStorage(GlobalVariable *V, MDNode *IO) {
 }
 
 bool LLVMToSPIRVBase::transGlobalVariables() {
+  // add global fixed/immutable samplers array that is always present
+  if (SrcLang == spv::SourceLanguageGLSL) {
+    auto samplers_type = BM->addPointerType(
+        spv::StorageClassUniformConstant,
+        BM->addArrayType(BM->addSamplerType(),
+                         BM->getLiteralAsConstant(32, false)));
+    immutable_samplers = static_cast<SPIRVVariable *>(
+        BM->addVariable(samplers_type, true, spv::internal::LinkageTypeInternal, nullptr,
+                        "vulkan.immutable_samplers",
+                        spv::StorageClassUniformConstant, nullptr));
+    BM->setName(immutable_samplers, "vulkan.immutable_samplers");
+    immutable_samplers->addDecorate(
+        new SPIRVDecorate(DecorationDescriptorSet, immutable_samplers, 0));
+    immutable_samplers->addDecorate(
+        new SPIRVDecorate(DecorationBinding, immutable_samplers, 0));
+  }
+
   for (auto I = M->global_begin(), E = M->global_end(); I != E; ++I) {
+    // ignore any special vulkan globals used by functions (these will be
+    // handled when translating the functions)
+    if ((*I).hasName() && (*I).getName().find(".vulkan") != std::string::npos)
+      continue;
+
+    // ignore any globals that need to be put into functions (map to function
+    // storage class), these are handled later
+    if (SPIRSPIRVAddrSpaceMap::map(static_cast<SPIRAddressSpace>(
+            (*I).getType()->getAddressSpace())) == spv::StorageClassFunction)
+      continue;
+
+    // ignore external globals
+    if ((*I).getLinkage() == GlobalValue::ExternalLinkage ||
+        (*I).getLinkage() == GlobalValue::AvailableExternallyLinkage ||
+        (*I).getLinkage() == GlobalValue::PrivateLinkage ||
+        (*I).getLinkage() == GlobalValue::ExternalWeakLinkage)
+      continue;
+
     if ((*I).getName() == "llvm.global.annotations")
       transGlobalAnnotation(&(*I));
     else if ((I->getName() == "llvm.global_ctors" ||
@@ -3327,13 +4049,1154 @@ void LLVMToSPIRVBase::fpContractUpdateRecursive(Function *F, FPContract FPC) {
   }
 }
 
-void LLVMToSPIRVBase::transFunction(Function *I) {
-  SPIRVFunction *BF = transFunctionDecl(I);
-  // Creating all basic blocks before creating any instruction.
-  for (auto &FI : *I) {
-    transValue(&FI, nullptr);
+// TODO: move this to a proper place
+enum class VULKAN_STAGE : uint32_t {
+  NONE = 0u,
+  VERTEX = (1u << 0u),
+  TESSELLATION_CONTROL = (1u << 1u),
+  TESSELLATION_EVALUATION = (1u << 2u),
+  GEOMETRY = (1u << 3u),
+  FRAGMENT = (1u << 4u),
+  KERNEL = (1u << 5u),
+};
+static const char *vulkan_stage_to_string(const VULKAN_STAGE &stage) {
+  switch (stage) {
+  case VULKAN_STAGE::VERTEX:
+    return "vertex";
+  case VULKAN_STAGE::TESSELLATION_CONTROL:
+    return "tessellation-control";
+  case VULKAN_STAGE::TESSELLATION_EVALUATION:
+    return "tesselation-evaluation";
+  case VULKAN_STAGE::GEOMETRY:
+    return "geometry";
+  case VULKAN_STAGE::FRAGMENT:
+    return "fragment";
+  case VULKAN_STAGE::KERNEL:
+    return "kernel";
+  default:
+    break;
+  }
+  return "";
+}
+constexpr VULKAN_STAGE operator|(const VULKAN_STAGE &e0,
+                                 const VULKAN_STAGE &e1) {
+  return (VULKAN_STAGE)((typename std::underlying_type<VULKAN_STAGE>::type)e0 |
+                        (typename std::underlying_type<VULKAN_STAGE>::type)e1);
+}
+constexpr VULKAN_STAGE &operator|=(VULKAN_STAGE &e0, const VULKAN_STAGE &e1) {
+  e0 = e0 | e1;
+  return e0;
+}
+constexpr VULKAN_STAGE operator&(const VULKAN_STAGE &e0,
+                                 const VULKAN_STAGE &e1) {
+  return (VULKAN_STAGE)((typename std::underlying_type<VULKAN_STAGE>::type)e0 &
+                        (typename std::underlying_type<VULKAN_STAGE>::type)e1);
+}
+constexpr VULKAN_STAGE &operator&=(VULKAN_STAGE &e0, const VULKAN_STAGE &e1) {
+  e0 = e0 & e1;
+  return e0;
+}
+
+void LLVMToSPIRVBase::decorateComposite(llvm::Type *llvm_type,
+                                    SPIRVType *spirv_type) {
+  if (SrcLang != SourceLanguageGLSL)
+    return;
+  // TODO: this doesn't respect padding/alignment yet, fix it (might already
+  // need to dump this info on the clang/llvm side)
+  const auto &DL = M->getDataLayout();
+  if (auto struct_type = dyn_cast<llvm::StructType>(llvm_type)) {
+    uint32_t member_idx = 0, offset = 0;
+    for (const auto &elem_type : struct_type->elements()) {
+      auto spirv_elem_type =
+          ((SPIRVTypeStruct *)spirv_type)->getMemberType(member_idx);
+
+      const auto this_member_idx = member_idx++;
+      const auto &member_decs = spirv_type->getMemberDecorates();
+      const auto iter =
+          member_decs.find({this_member_idx, spv::DecorationOffset});
+      if (iter == member_decs.end()) {
+        spirv_type->addMemberDecorate(this_member_idx, spv::DecorationOffset,
+                                      offset);
+      } else {
+        // shouldn't occur as far as I can tell, but better check it to be
+        // certain
+        assert(iter->second->getMemberNumber() == this_member_idx &&
+               iter->second->getLiteral(0) == offset &&
+               "existing member decoration differs from this one");
+      }
+      offset += DL.getTypeStoreSize(elem_type);
+
+      // recurse
+      decorateComposite(elem_type, spirv_elem_type);
+    }
+  } else if (auto array_type = dyn_cast<llvm::ArrayType>(llvm_type)) {
+    spirv_type->addDecorate(spv::DecorationArrayStride,
+                            DL.getTypeStoreSize(array_type->getElementType()));
+    auto spirv_elem_type =
+        (spirv_type->isTypeRuntimeArray()
+             ? ((SPIRVTypeRuntimeArray *)spirv_type)->getElementType()
+             : ((SPIRVTypeArray *)spirv_type)->getElementType());
+
+    // recurse
+    decorateComposite(array_type->getElementType(), spirv_elem_type);
+  }
+}
+
+SPIRVVariable *LLVMToSPIRVBase::emitShaderSPIRVGlobal(
+    SPIRVFunction *spirv_func, const GlobalVariable &GV,
+    const std::string &var_name, uint32_t address_space,
+    const spirv_global_io_type global_type, const std::string &md_info,
+    spv::BuiltIn builtin) {
+  spv::StorageClass storage_class = spv::StorageClassUniform;
+  if (global_type.is_builtin) {
+    storage_class = (global_type.is_input ? spv::StorageClassInput
+                                          : spv::StorageClassOutput);
+  } else if (global_type.is_input) {
+    storage_class = spv::StorageClassInput;
+  } else if (global_type.is_image) {
+    storage_class = spv::StorageClassUniformConstant;
+  } else if (global_type.is_uniform) {
+    storage_class = spv::StorageClassUniform;
+    if ((!global_type.is_constant ||
+         (global_type.is_constant && !global_type.is_iub))) {
+      storage_class = spv::StorageClassStorageBuffer;
+    }
+  } else {
+    storage_class = spv::StorageClassOutput;
+  }
+
+  SPIRVType *mapped_type = nullptr;
+  uint32_t fbo_location = 0;
+  if (global_type.is_uniform) {
+    assert(GV.getType()->isPointerTy() && "uniform must be a pointer type");
+    auto elem_type = GV.getType()->getPointerElementType();
+
+    // -> SSBOs or IUBs
+    if (!global_type.is_image) {
+      auto spirv_elem_type = transType(elem_type);
+      if (!global_type.is_iub) {
+        if (!global_type.is_constant) {
+          // this is a SSBO with an unknown size, switch out the top pointer
+          // type with a runtime array type
+          auto rtarr_type = BM->addRuntimeArrayType(spirv_elem_type);
+          std::string enclosing_type_name = "enclose.";
+          if (elem_type->isStructTy()) {
+            enclosing_type_name += elem_type->getStructName().str();
+          } else {
+            std::string type_str = "";
+            llvm::raw_string_ostream type_stream(type_str);
+            elem_type->print(type_stream, false, true);
+            enclosing_type_name += type_stream.str();
+          }
+          auto enclosing_type = BM->openStructType(1, enclosing_type_name);
+          enclosing_type->setMemberType(0, rtarr_type);
+          BM->closeStructType(enclosing_type, false);
+          mapped_type = BM->addPointerType(storage_class, enclosing_type);
+        
+          // add required deco
+          enclosing_type->addDecorate(new SPIRVDecorate(DecorationBlock, enclosing_type));
+          enclosing_type->addMemberDecorate(0, spv::DecorationOffset, 0);
+          rtarr_type->addDecorate(spv::DecorationArrayStride,
+                    M->getDataLayout().getTypeStoreSize(elem_type));
+        } else {
+          // we need to use the storage buffer storage class
+          assert(elem_type->isStructTy() && "SSBO must be a struct");
+          auto ssbo_ptr_type = llvm::PointerType::get(GV.getType()->getPointerElementType(), SPIRAS_StorageBuffer);
+          mapped_type = transType(ssbo_ptr_type);
+          spirv_elem_type->addDecorate(new SPIRVDecorate(DecorationBlock, spirv_elem_type));
+        }
+      } else {
+        assert(elem_type->isStructTy() && "uniform type must be a struct");
+        // we need to use the uniform buffer storage class
+        auto uniform_ptr_type = llvm::PointerType::get(GV.getType()->getPointerElementType(), SPIRAS_Uniform);
+        mapped_type = transType(uniform_ptr_type);
+        spirv_elem_type->addDecorate(new SPIRVDecorate(DecorationBlock, spirv_elem_type));
+      }
+      decorateComposite(elem_type, spirv_elem_type);
+    }
+    // -> images
+    else {
+      const auto access_split_pos = md_info.find(':');
+      const auto array_or_scalar_split_pos =
+          md_info.find(':', access_split_pos + 1);
+      const auto elem_count_split_pos =
+          md_info.find(':', array_or_scalar_split_pos + 1);
+
+      const auto access_type = md_info.substr(0, access_split_pos);
+      const auto array_or_scalar_str =
+          md_info.substr(access_split_pos + 1,
+                         array_or_scalar_split_pos - access_split_pos - 1);
+      const auto elem_count_str =
+          md_info.substr(array_or_scalar_split_pos + 1,
+                         elem_count_split_pos - array_or_scalar_split_pos - 1);
+      const auto sample_type = md_info.substr(elem_count_split_pos + 1);
+
+      const bool is_array = (array_or_scalar_str == "array");
+      const bool is_write = (access_type == "write");
+
+      if (is_write) {
+        // TODO: handle storage images with format
+        BM->addCapability(spv::CapabilityStorageImageWriteWithoutFormat);
+      }
+
+      //
+      const auto elem_count = (uint32_t)std::stoull(elem_count_str);
+      llvm::Type *img_type = GV.getType();
+      if (is_array) {
+        // image array
+        assert(isa<PointerType>(img_type) && "must be a pointer type");
+        const auto img_array_type =
+            dyn_cast<ArrayType>(img_type->getPointerElementType());
+        assert(img_array_type != nullptr && "image type must be an array type");
+        assert(img_array_type->getNumElements() == elem_count &&
+               "invalid image array element count");
+        img_type = img_array_type->getArrayElementType();
+      }
+      //
+      auto SPIRVImageTy = getSPIRVImageTypeFromGLSL(
+          M, img_type, sample_type.c_str(), is_write, spv::ImageFormatUnknown);
+      auto transSPIRVImageTy = transSPIRVOpaqueType(SPIRVImageTy);
+
+      // cache it
+      image_type_map.emplace(&GV, transSPIRVImageTy);
+
+      //
+      auto ptr_img_type = transSPIRVImageTy;
+      if (is_array) {
+        ptr_img_type = BM->addArrayType(
+            transSPIRVImageTy, BM->getLiteralAsConstant(elem_count, false));
+      }
+
+      mapped_type =
+          BM->addPointerType(spv::StorageClassUniformConstant, ptr_img_type);
+    }
+  } else if (global_type.is_fbo_color) {
+    // extract location idx
+    const auto location_pos = md_info.rfind(':');
+    assert(location_pos != std::string::npos);
+    const auto location_str = md_info.substr(location_pos + 1);
+    fbo_location = (uint32_t)strtoull(location_str.c_str(), nullptr, 10);
+
+    // extract data type
+    const auto data_type_pos = md_info.rfind(':', location_pos - 1);
+    assert(data_type_pos != std::string::npos);
+    const auto data_type_str =
+        md_info.substr(data_type_pos + 1, location_pos - data_type_pos - 1);
+
+    // float and (signed) int can always be translated directly, unsigned int
+    // needs special treatment, b/c llvm doesn't differentiate ints and uints
+    if (data_type_str == "uint") {
+      assert(GV.getType()->isPointerTy());
+      mapped_type = BM->addPointerType(
+          storage_class, addSignPreservingLLVMType(
+                             GV.getType()->getPointerElementType(), false));
+    } else {
+      mapped_type = transType(GV.getType());
+    }
+
+  } else if (global_type.is_fbo_depth) {
+    // extract depth qualifier
+    const auto depth_qual_pos = md_info.rfind(':');
+    assert(depth_qual_pos != std::string::npos);
+    const auto depth_qual = md_info.substr(depth_qual_pos + 1);
+
+    // add execution mode for "less" and "greater"
+    if (depth_qual == "less") {
+      spirv_func->addExecutionMode(
+          new SPIRVExecutionMode(spirv_func, ExecutionModeDepthLess));
+    } else if (depth_qual == "greater") {
+      spirv_func->addExecutionMode(
+          new SPIRVExecutionMode(spirv_func, ExecutionModeDepthGreater));
+    }
+    // else: "any"/default, keep as-is
+
+    mapped_type = transType(GV.getType());
+
+  } else {
+    mapped_type = transType(GV.getType());
+  }
+
+  auto BVar = static_cast<SPIRVVariable *>(
+      BM->addVariable(mapped_type, false, spv::internal::LinkageTypeInternal, nullptr,
+                      GV.getName().str(), storage_class, nullptr));
+  BM->setName(BVar, GV.getName().str());
+  mapValue((const Value *)&GV, BVar);
+
+  if (global_type.is_builtin) {
+    BVar->setBuiltin(builtin);
+  }
+
+  BM->addEntryPointIO(spirv_func->getId(), BVar);
+
+  // set non-readable/-writable deco on SSBOs
+  if (global_type.is_uniform && !global_type.is_image) {
+    if (global_type.is_read_only || global_type.is_constant) {
+      BVar->addDecorate(new SPIRVDecorate(DecorationNonWritable, BVar));
+#if 0 // NOTE: the NVIDIA driver/compiler can't deal with this if we're using a
+      // SSBO -> disable for now
+      if (global_type.is_constant) {
+        BVar->addDecorate(new SPIRVDecorate(DecorationUniform, BVar));
+      }
+#endif
+      // IUB is always uniform
+      if (global_type.is_constant && global_type.is_iub) {
+        BVar->addDecorate(new SPIRVDecorate(DecorationUniform, BVar));
+      }
+    } else if (global_type.is_write_only) {
+      BVar->addDecorate(new SPIRVDecorate(DecorationNonReadable, BVar));
+    }
+  }
+
+  // handle decoration
+  if (global_type.is_fbo_color) {
+    BVar->addDecorate(
+        new SPIRVDecorate(DecorationLocation, BVar, fbo_location));
+  } else if ((storage_class == spv::StorageClassOutput ||
+              storage_class == spv::StorageClassInput) &&
+             global_type.set_location) {
+    BVar->addDecorate(
+        new SPIRVDecorate(DecorationLocation, BVar, global_type.location));
+  }
+
+  // automatically add the "flat" decoration on types that need it
+  // NOTE: vulkan requires that this is only set on input variables
+  if (storage_class == spv::StorageClassInput && !global_type.is_fbo_color &&
+      !global_type.is_fbo_depth && !global_type.is_builtin) {
+    // I/O should always be a pointer type
+    if (GV.getType()->isPointerTy()) {
+      auto elem_type = GV.getType()->getPointerElementType();
+      auto elem_vec_type = dyn_cast_or_null<FixedVectorType>(elem_type);
+      if (elem_type->isIntegerTy() ||
+          (elem_vec_type && elem_vec_type->getElementType()->isIntegerTy())) {
+        BVar->addDecorate(new SPIRVDecorate(DecorationFlat, BVar));
+      }
+    }
+  }
+
+  return BVar;
+}
+
+GlobalVariable *LLVMToSPIRVBase::emitShaderGlobal(
+    const Function &F, SPIRVFunction *spirv_func, const std::string &var_name,
+    llvm::Type *llvm_type, uint32_t address_space,
+    const spirv_global_io_type global_type, const std::string &md_info,
+    SPIRVVariable **created_spirv_var, spv::BuiltIn builtin) {
+  std::string name_type = ".";
+  if (global_type.is_builtin) {
+    name_type = (global_type.is_input ? ".vulkan_builtin_input."
+                                      : ".vulkan_builtin_output.");
+  } else if (global_type.is_input) {
+    name_type = ".vulkan_input.";
+  } else if (global_type.is_uniform) {
+    name_type = ".vulkan_uniform.";
+  }
+
+  auto GV =
+      new GlobalVariable(*M, llvm_type, false, GlobalVariable::InternalLinkage,
+                         nullptr, F.getName().str() + name_type + var_name,
+                         nullptr, GlobalValue::NotThreadLocal, address_space);
+
+  // also add the SPIR-V global
+  auto spirv_var = emitShaderSPIRVGlobal(
+      spirv_func, *GV, var_name, address_space, global_type, md_info, builtin);
+  if (created_spirv_var != nullptr) {
+    *created_spirv_var = spirv_var;
+  }
+
+  return GV;
+}
+
+// helper function to figure out if a SSBO argument is only being written to
+// TODO/NOTE: since WriteOnly is a fairly new attribute, the FunctionAttrs pass
+// can't handle it yet (like it does for readonly/readnone) -> once it can infer
+// the WriteOnly attribute, use that instead
+static bool is_write_only_arg(Function &F, Argument &arg) {
+  // since Vulkan/SPIR-V is very restrictive on pointer usage, that makes this
+  // rather simple. however, we still bail out if we find something that we
+  // can't handle.
+  const std::function<bool(Value *)> user_recurse =
+      [&user_recurse](Value *val) {
+        for (User *user : val->users()) {
+          // is read from -> bail
+          if (isa<LoadInst>(user)) {
+            return false;
+          }
+          // is written to -> continue
+          else if (isa<StoreInst>(user)) {
+            continue;
+          }
+          // recurse for GEPs
+          else if (isa<GetElementPtrInst>(user)) {
+            // bail if GEP is used for loads
+            if (!user_recurse(user)) {
+              return false;
+            }
+          }
+          // calls are somewhat tricky
+          else if (CallInst *CI = dyn_cast<CallInst>(user)) {
+            // does read -> bail
+            if (!CI->doesNotReadMemory()) {
+              return false;
+            }
+            // we don't know what the call is doing exactly, but if it does
+            // return a pointer, assume it's us
+            if (CI->getType()->isPointerTy()) {
+              if (!user_recurse(user)) {
+                return false;
+              }
+            }
+          }
+          // NOTE: Vulkan/SPIR-V doesn't allow pointer usage in
+          // select/phi/bitcast, so we're good here
+          // unknown usage -> assume it's being read
+          else {
+            return false;
+          }
+        }
+        // didn't find any loads -> write-only
+        return true;
+      };
+  return user_recurse(&arg);
+}
+
+void LLVMToSPIRVBase::transFunction(Function *F) {
+  // again, ignore any floor.* functions
+  if (F->getName().startswith("floor."))
+    return;
+
+  // ignore any non-entry-point functions
+  if (F->getCallingConv() == CallingConv::FLOOR_FUNC)
+    return;
+
+  SPIRVFunction *BF = transFunctionDecl(F);
+
+  // we're only interested in shader entry points here
+  // TODO: cleanup + move to functions
+  if (SrcLang == SourceLanguageGLSL &&
+      (F->getCallingConv() == llvm::CallingConv::FLOOR_KERNEL ||
+       F->getCallingConv() == llvm::CallingConv::FLOOR_VERTEX ||
+       F->getCallingConv() == llvm::CallingConv::FLOOR_FRAGMENT)) {
+    VULKAN_STAGE stage;
+    switch (F->getCallingConv()) {
+    case llvm::CallingConv::FLOOR_VERTEX:
+      stage = VULKAN_STAGE::VERTEX;
+      break;
+    case llvm::CallingConv::FLOOR_FRAGMENT:
+      stage = VULKAN_STAGE::FRAGMENT;
+      break;
+    case llvm::CallingConv::FLOOR_KERNEL:
+      stage = VULKAN_STAGE::KERNEL;
+      break;
+    default:
+      return;
+    }
+
+    // always add this
+    if (stage == VULKAN_STAGE::FRAGMENT) {
+      BF->addExecutionMode(
+          new SPIRVExecutionMode(BF, ExecutionModeOriginUpperLeft));
+    }
+
+    const std::string func_name = F->getName().str();
+    std::vector<std::string> md_data_input, md_data_output;
+    auto vulkan_io_md = M->getNamedMetadata("vulkan.stage_io");
+    assert(vulkan_io_md != nullptr && "vulkan.io metadata doesn't exist");
+    for (const auto &op : vulkan_io_md->operands()) {
+      assert(op->getNumOperands() > 0 &&
+             "invalid op count in vulkan.io metadata");
+      if (auto md_func_name = dyn_cast<llvm::MDString>(op->getOperand(0))) {
+        if (md_func_name->getString() == func_name) {
+          // found our function, dump metadata strings to an easier to use
+          // vector<string>
+          bool at_input = false, at_output = false;
+          for (uint32_t i = 1; i < op->getNumOperands(); ++i) {
+            const auto md_op_str =
+                dyn_cast<llvm::MDString>(op->getOperand(i))->getString();
+
+            if (md_op_str == "stage_input") {
+              at_input = true;
+              at_output = false;
+              continue;
+            } else if (md_op_str == "stage_output") {
+              at_input = false;
+              at_output = true;
+              continue;
+            }
+
+            if (at_input)
+              md_data_input.emplace_back(md_op_str.str());
+            else if (at_output)
+              md_data_output.emplace_back(md_op_str.str());
+          }
+          break;
+        }
+      }
+    }
+
+    const auto get_builtin =
+        [](const std::string &str) -> std::pair<spv::BuiltIn, bool> {
+      static const std::unordered_map<std::string, spv::BuiltIn> builtin_lut{
+          {"position", spv::BuiltInPosition},
+          {"point_size", spv::BuiltInPointSize},
+          {"clip_distance", spv::BuiltInClipDistance},
+          {"cull_distance", spv::BuiltInCullDistance},
+          //{ "vertex_id", spv::BuiltInVertexId }, // unsupported in vulkan
+          //{ "instance_id", spv::BuiltInInstanceId }, // unsupported in vulkan
+          {"primitive_id", spv::BuiltInPrimitiveId},
+          {"invocation_id", spv::BuiltInInvocationId},
+          {"layer", spv::BuiltInLayer},
+          {"viewport_index", spv::BuiltInViewportIndex},
+          {"tess_level_outer", spv::BuiltInTessLevelOuter},
+          {"tess_level_inner", spv::BuiltInTessLevelInner},
+          {"tess_coord", spv::BuiltInTessCoord},
+          {"patch_vertices", spv::BuiltInPatchVertices},
+          {"frag_coord", spv::BuiltInFragCoord},
+          {"point_coord", spv::BuiltInPointCoord},
+          {"front_facing", spv::BuiltInFrontFacing},
+          {"sample_id", spv::BuiltInSampleId},
+          {"sample_position", spv::BuiltInSamplePosition},
+          {"sample_mask", spv::BuiltInSampleMask},
+          {"frag_depth", spv::BuiltInFragDepth},
+          {"helper_invocation", spv::BuiltInHelperInvocation},
+          {"num_workgroups", spv::BuiltInNumWorkgroups},
+          //{ "workgroup_size", spv::BuiltInWorkgroupSize }, // NOTE: must be a
+          // constant or spec constant
+          {"workgroup_id", spv::BuiltInWorkgroupId},
+          {"local_invocation_id", spv::BuiltInLocalInvocationId},
+          {"global_invocation_id", spv::BuiltInGlobalInvocationId},
+          // OpenCL-only:
+          //{ "local_invocation_index", spv::BuiltInLocalInvocationIndex },
+          //{ "work_dim", spv::BuiltInWorkDim },
+          //{ "global_size", spv::BuiltInGlobalSize },
+          //{ "enqueued_workgroup_size", spv::BuiltInEnqueuedWorkgroupSize },
+          //{ "global_offset", spv::BuiltInGlobalOffset },
+          //{ "global_linear_id", spv::BuiltInGlobalLinearId },
+          //{ "subgroup_size", spv::BuiltInSubgroupSize },
+          //{ "subgroup_max_size", spv::BuiltInSubgroupMaxSize },
+          //{ "num_subgroups", spv::BuiltInNumSubgroups },
+          //{ "num_enqueued_subgroups", spv::BuiltInNumEnqueuedSubgroups },
+          //{ "subgroup_id", spv::BuiltInSubgroupId },
+          //{ "subgroup_local_invocation_id",
+          // spv::BuiltInSubgroupLocalInvocationId },
+          {"vertex_index", spv::BuiltInVertexIndex},
+          {"instance_index", spv::BuiltInInstanceIndex},
+          {"view_index", spv::BuiltInViewIndex},
+      };
+      const auto iter = builtin_lut.find(str);
+      if (iter == builtin_lut.end()) {
+        return {spv::BuiltInPosition, false};
+      }
+      return {iter->second, true};
+    };
+    const auto is_builtin_valid_in_stage = [](const spv::BuiltIn &builtin,
+                                              const VULKAN_STAGE &stage,
+                                              const bool is_input) {
+      // NOTE: the non-listed/commented ones are unsupported in vulkan
+      static const std::unordered_map<spv::BuiltIn, VULKAN_STAGE>
+          builtin_validity_input_lut{
+              {spv::BuiltInPosition, (VULKAN_STAGE::TESSELLATION_CONTROL |
+                                      VULKAN_STAGE::TESSELLATION_EVALUATION |
+                                      VULKAN_STAGE::GEOMETRY)},
+              {spv::BuiltInPointSize, (VULKAN_STAGE::TESSELLATION_CONTROL |
+                                       VULKAN_STAGE::TESSELLATION_EVALUATION |
+                                       VULKAN_STAGE::GEOMETRY)},
+              {spv::BuiltInClipDistance,
+               (VULKAN_STAGE::FRAGMENT | VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION |
+                VULKAN_STAGE::GEOMETRY)},
+              {spv::BuiltInCullDistance,
+               (VULKAN_STAGE::FRAGMENT | VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION |
+                VULKAN_STAGE::GEOMETRY)},
+              //{ spv::BuiltInVertexId, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInInstanceId, VULKAN_STAGE::NONE },
+              {spv::BuiltInPrimitiveId, VULKAN_STAGE::GEOMETRY},
+              {spv::BuiltInInvocationId,
+               (VULKAN_STAGE::TESSELLATION_CONTROL | VULKAN_STAGE::GEOMETRY)},
+              {spv::BuiltInLayer, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInViewportIndex, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInTessLevelOuter,
+               VULKAN_STAGE::TESSELLATION_EVALUATION},
+              {spv::BuiltInTessLevelInner,
+               VULKAN_STAGE::TESSELLATION_EVALUATION},
+              {spv::BuiltInTessCoord, VULKAN_STAGE::TESSELLATION_EVALUATION},
+              {spv::BuiltInPatchVertices,
+               (VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION)},
+              {spv::BuiltInFragCoord, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInPointCoord, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInFrontFacing, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInSampleId, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInSamplePosition, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInSampleMask, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInFragDepth, VULKAN_STAGE::NONE},
+              {spv::BuiltInHelperInvocation, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInNumWorkgroups, VULKAN_STAGE::KERNEL},
+              {spv::BuiltInWorkgroupSize,
+               VULKAN_STAGE::NONE}, // NOTE: must be a constant or spec constant
+              {spv::BuiltInWorkgroupId, VULKAN_STAGE::KERNEL},
+              {spv::BuiltInLocalInvocationId, VULKAN_STAGE::KERNEL},
+              {spv::BuiltInGlobalInvocationId, VULKAN_STAGE::KERNEL},
+              //{ spv::BuiltInLocalInvocationIndex, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInWorkDim, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInGlobalSize, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInEnqueuedWorkgroupSize, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInGlobalOffset, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInGlobalLinearId, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInSubgroupSize, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInSubgroupMaxSize, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInNumSubgroups, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInNumEnqueuedSubgroups, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInSubgroupId, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInSubgroupLocalInvocationId, VULKAN_STAGE::NONE },
+              {spv::BuiltInVertexIndex, VULKAN_STAGE::VERTEX},
+              {spv::BuiltInInstanceIndex, VULKAN_STAGE::VERTEX},
+              {spv::BuiltInViewIndex,
+               (VULKAN_STAGE::VERTEX | VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION | VULKAN_STAGE::GEOMETRY |
+                VULKAN_STAGE::FRAGMENT)},
+          };
+      static const std::unordered_map<spv::BuiltIn, VULKAN_STAGE>
+          builtin_validity_output_lut{
+              {spv::BuiltInPosition,
+               (VULKAN_STAGE::VERTEX | VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION |
+                VULKAN_STAGE::GEOMETRY)},
+              {spv::BuiltInPointSize,
+               (VULKAN_STAGE::VERTEX | VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION |
+                VULKAN_STAGE::GEOMETRY)},
+              {spv::BuiltInClipDistance,
+               (VULKAN_STAGE::VERTEX | VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION |
+                VULKAN_STAGE::GEOMETRY)},
+              {spv::BuiltInCullDistance,
+               (VULKAN_STAGE::VERTEX | VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION |
+                VULKAN_STAGE::GEOMETRY)},
+              //{ spv::BuiltInVertexId, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInInstanceId, VULKAN_STAGE::NONE },
+              {spv::BuiltInPrimitiveId,
+               (VULKAN_STAGE::FRAGMENT | VULKAN_STAGE::TESSELLATION_CONTROL |
+                VULKAN_STAGE::TESSELLATION_EVALUATION |
+                VULKAN_STAGE::GEOMETRY)},
+              {spv::BuiltInInvocationId, VULKAN_STAGE::NONE},
+              {spv::BuiltInLayer, VULKAN_STAGE::GEOMETRY},
+              {spv::BuiltInViewportIndex, VULKAN_STAGE::GEOMETRY},
+              {spv::BuiltInTessLevelOuter, VULKAN_STAGE::TESSELLATION_CONTROL},
+              {spv::BuiltInTessLevelInner, VULKAN_STAGE::TESSELLATION_CONTROL},
+              {spv::BuiltInTessCoord, VULKAN_STAGE::NONE},
+              {spv::BuiltInPatchVertices, VULKAN_STAGE::NONE},
+              {spv::BuiltInFragCoord, VULKAN_STAGE::NONE},
+              {spv::BuiltInPointCoord, VULKAN_STAGE::NONE},
+              {spv::BuiltInFrontFacing, VULKAN_STAGE::NONE},
+              {spv::BuiltInSampleId, VULKAN_STAGE::NONE},
+              {spv::BuiltInSamplePosition, VULKAN_STAGE::NONE},
+              {spv::BuiltInSampleMask, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInFragDepth, VULKAN_STAGE::FRAGMENT},
+              {spv::BuiltInHelperInvocation, VULKAN_STAGE::NONE},
+              {spv::BuiltInNumWorkgroups, VULKAN_STAGE::NONE},
+              {spv::BuiltInWorkgroupSize, VULKAN_STAGE::NONE},
+              {spv::BuiltInWorkgroupId, VULKAN_STAGE::NONE},
+              {spv::BuiltInLocalInvocationId, VULKAN_STAGE::NONE},
+              {spv::BuiltInGlobalInvocationId, VULKAN_STAGE::NONE},
+              //{ spv::BuiltInLocalInvocationIndex, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInWorkDim, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInGlobalSize, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInEnqueuedWorkgroupSize, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInGlobalOffset, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInGlobalLinearId, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInSubgroupSize, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInSubgroupMaxSize, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInNumSubgroups, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInNumEnqueuedSubgroups, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInSubgroupId, VULKAN_STAGE::NONE },
+              //{ spv::BuiltInSubgroupLocalInvocationId, VULKAN_STAGE::NONE },
+              {spv::BuiltInVertexIndex, VULKAN_STAGE::NONE},
+              {spv::BuiltInInstanceIndex, VULKAN_STAGE::NONE},
+              {spv::BuiltInViewIndex, VULKAN_STAGE::NONE},
+          };
+
+      if (is_input) {
+        const auto iter = builtin_validity_input_lut.find(builtin);
+        if (iter == builtin_validity_input_lut.end()) {
+          return false;
+        }
+        return (iter->second & stage) != VULKAN_STAGE::NONE;
+      } else {
+        const auto iter = builtin_validity_output_lut.find(builtin);
+        if (iter == builtin_validity_output_lut.end()) {
+          return false;
+        }
+        return (iter->second & stage) != VULKAN_STAGE::NONE;
+      }
+    };
+
+    // handle parameters (input or globals)
+    // TODO: proper input/output location handling: 1x - 4x 32-bit values can be
+    // packed into a single location, anything larger needs to be distributed
+    // over multiple locations
+    uint32_t input_arg_idx = 0, uniform_arg_idx = 0;
+    uint32_t input_location = 0;
+    uint32_t desc_set = 0;
+    switch (stage) { // put each stage into a different set
+    case VULKAN_STAGE::KERNEL:
+    case VULKAN_STAGE::VERTEX:
+      desc_set = 1;
+      break;
+    case VULKAN_STAGE::FRAGMENT:
+      desc_set = 2;
+      break;
+    case VULKAN_STAGE::GEOMETRY:
+      desc_set = 3;
+      break;
+    case VULKAN_STAGE::TESSELLATION_CONTROL:
+      desc_set = 4;
+      break;
+    case VULKAN_STAGE::TESSELLATION_EVALUATION:
+      desc_set = 5;
+      break;
+    default:
+      llvm_unreachable("invalid stage");
+    }
+    for (Argument &arg : F->args()) {
+      llvm::Type *arg_type = arg.getType();
+      const auto arg_name = arg.getName();
+
+      const auto md_prefix_split_pos = md_data_input[input_arg_idx].find(':');
+      const std::string md_prefix =
+          (md_prefix_split_pos != std::string::npos
+               ? md_data_input[input_arg_idx].substr(0, md_prefix_split_pos)
+               : "");
+      const std::string md_info =
+          (md_prefix_split_pos != std::string::npos
+               ? md_data_input[input_arg_idx].substr(md_prefix_split_pos + 1)
+               : md_data_input[input_arg_idx]);
+
+      if (arg_type->isPointerTy() &&
+          arg_type->getPointerAddressSpace() != SPIRAS_Input) {
+        llvm::Type *elem_type = arg_type->getPointerElementType();
+
+        // -> globals
+        SPIRVVariable *uniform_var = nullptr;
+        const auto ptr_as = arg_type->getPointerAddressSpace();
+        if (arg.onlyReadsMemory() &&
+            (arg.hasAttribute(Attribute::Dereferenceable) ||
+             arg.hasAttribute(Attribute::DereferenceableOrNull))) {
+          // -> uniform, use static/fixed SSBO
+          // NOTE: this could be made a Block variable, but that would have
+          // insane alignment/offset requirements, so always make it a SSBO,
+          // which has less restrictions
+          // (TODO: could also make this a push constant later on)
+          spirv_global_io_type global_type;
+          global_type.is_constant = true;
+          global_type.is_uniform = true;
+          global_type.is_read_only = true;
+          auto storage_class = SPIRAS_StorageBuffer;
+          if (md_prefix == "iub") {
+            global_type.is_iub = true;
+            storage_class = SPIRAS_Uniform;
+          }
+          auto GV = emitShaderGlobal(*F, BF, arg_name.str(), elem_type,
+                                     storage_class, global_type, md_info,
+                                     &uniform_var);
+          arg.replaceAllUsesWith(GV, true);
+        } else if (ptr_as == SPIRAS_Uniform || ptr_as == SPIRAS_StorageBuffer) {
+          // all image types are opaque/unsized
+          if (!elem_type->isSized()) {
+            // -> image
+            assert(ptr_as == SPIRAS_Uniform);
+            spirv_global_io_type global_type;
+            global_type.is_image = true;
+            global_type.is_constant = true;
+            global_type.is_uniform = true;
+            auto GV = emitShaderGlobal(*F, BF, arg_name.str(),
+                                       elem_type, SPIRAS_Uniform, global_type,
+                                       md_info, &uniform_var);
+            arg.replaceAllUsesWith(GV);
+          } else {
+            // -> BufferBlock uniform (SSBO)
+            spirv_global_io_type global_type;
+            global_type.is_uniform = true;
+            global_type.is_read_only = arg.onlyReadsMemory();
+            global_type.is_write_only =
+                (!global_type.is_read_only ? is_write_only_arg(*F, arg)
+                                           : false);
+            const auto storage_class = SPIRAS_StorageBuffer;
+            auto GV = emitShaderGlobal(*F, BF, arg_name.str(),
+                                       elem_type, storage_class, global_type,
+                                       md_info, &uniform_var);
+            // any GEPs can be directly replaced with the new GV, all others can
+            // no longer access it directly, but must go through a new "GEP #0"
+            // access
+            while (!arg.user_empty()) {
+              auto user = *arg.user_begin();
+              // simple GEP ptr replacement
+              if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(user)) {
+                GEP->setOperand(0, GV);
+                continue;
+              }
+              // direct access
+              if (Instruction *instr = dyn_cast<Instruction>(user)) {
+                // create GEP to the first element
+                llvm::Value *idx_list[]{
+                    llvm::ConstantInt::get(llvm::Type::getInt32Ty(*Ctx), 0),
+                };
+                auto zero_gep =
+                    GetElementPtrInst::CreateInBounds(GV, idx_list, "", instr);
+                zero_gep->setDebugLoc(instr->getDebugLoc());
+
+                // replace all uses in the instruction
+                for (uint32_t op_idx = 0; op_idx < instr->getNumOperands();
+                     ++op_idx) {
+                  auto op = instr->getOperand(op_idx);
+                  if (op == &arg) {
+                    instr->setOperand(op_idx, zero_gep);
+                  }
+                }
+                continue;
+              }
+              assert(false && "should not be here - unknown arg user");
+            }
+          }
+        } else if (arg_type->getPointerAddressSpace() == SPIRAS_Private &&
+                   arg_type->getPointerElementType()->isArrayTy()) {
+          auto array_type = cast<ArrayType>(arg_type->getPointerElementType());
+
+          auto img_ptr_type = array_type->getArrayElementType();
+          assert(img_ptr_type->isPointerTy() && "expected image pointer type");
+          auto img_type = img_ptr_type->getPointerElementType();
+          assert(img_type->isStructTy() && "expected image struct type");
+          auto st_img_type = cast<StructType>(img_type);
+          assert(st_img_type->getStructName().startswith("opencl.image") &&
+                 "expected image type");
+
+          // -> image array
+          spirv_global_io_type global_type;
+          global_type.is_image = true;
+          global_type.is_constant = true;
+          global_type.is_uniform = true;
+          auto GV = emitShaderGlobal(*F, BF, arg_name.str(), array_type,
+                                     SPIRAS_Uniform, global_type, md_info,
+                                     &uniform_var);
+          // replace with address space change (private to uniform)
+          arg.replaceAllUsesWith(GV, true);
+        } else if (arg_type->getPointerAddressSpace() == SPIRAS_Local) {
+          // -> local memory (TODO: implement this)
+          llvm_unreachable("local memory parameters are not yet implemented");
+        } else if (arg_type->getPointerAddressSpace() == SPIRAS_Generic) {
+          // -> unknown generic
+          llvm_unreachable("generic parameters are not supported");
+        } else
+          llvm_unreachable("unknown parameter address space");
+
+        //
+        uniform_var->addDecorate(
+            new SPIRVDecorate(DecorationDescriptorSet, uniform_var, desc_set));
+        uniform_var->addDecorate(
+            new SPIRVDecorate(DecorationBinding, uniform_var, uniform_arg_idx));
+        ++uniform_arg_idx;
+      } else {
+        if (md_prefix == "builtin") {
+          // -> special input variable
+          // transform function parameter to in-function alloca + input
+          // annotation
+          const auto builtin = get_builtin(md_info);
+          if (!builtin.second) {
+            errs() << "unknown builtin: " << md_info << "\n";
+          }
+
+          const auto is_valid =
+              is_builtin_valid_in_stage(builtin.first, stage, true /* input */);
+          if (is_valid) {
+            llvm::Type *elem_type = arg_type->getPointerElementType();
+            spirv_global_io_type global_type;
+            global_type.is_input = true;
+            global_type.is_builtin = true;
+            auto repl_var = emitShaderGlobal(
+                *F, BF, arg_name.str(), elem_type, SPIRAS_Input, global_type,
+                md_info, nullptr, builtin.first);
+            arg.replaceAllUsesWith(repl_var);
+          } else {
+            // TODO: should catch this earlier
+            if (arg.getNumUses() > 0) {
+              errs() << "input builtin \"" << md_info
+                     << "\" can not be used in stage \""
+                     << vulkan_stage_to_string(stage) << "\"\n";
+            }
+          }
+        } else if (md_prefix == "stage" || md_prefix == "") {
+          // -> stage input
+          spirv_global_io_type global_type;
+          global_type.is_input = true;
+          global_type.is_read_only = true;
+          if (md_prefix != "stage") {
+            // only emit this input if it is an actual input (not a builtin)
+            global_type.set_location = true;
+            global_type.location = input_location++;
+
+            auto repl_var =
+                emitShaderGlobal(*F, BF, arg_name.str(), arg_type,
+                                 SPIRAS_Input, global_type, md_info);
+            // only emit load if there actually is a user
+            if (arg.getNumUses() > 0) {
+              LoadInst *load_repl_var = new LoadInst(arg_type, repl_var, arg_name, false,
+                                                     &*(F->front().begin()));
+              arg.replaceAllUsesWith(load_repl_var);
+            }
+          } else {
+            // builtin input -> must be ignored
+            if (arg.getNumUses() != 0) {
+              errs() << "stage input should not have any users (must use "
+                        "built-ins)\n";
+              assert(
+                  false &&
+                  "stage input should not have any users (must use built-ins)");
+            }
+          }
+        } else {
+          assert(false && "unknown or unhandled input");
+        }
+      }
+
+      // used by all arg types
+      ++input_arg_idx;
+    }
+
+    // handle return value / output
+    // TODO: more metadata + handling
+    // NOTE: inputs, builtins and uniforms are handled on the SPIRVLib side
+    // above, outputs are however already handled on the LLVM side (VulkanFinal
+    // pass) and thus have no SPIRVVariable mapping yet and have not been added
+    // to the entry point i/o set yet
+    // -> create SPIRVVariable for outputs + add them to the entry point i/o set
+    // in here
+    const std::string output_var_name_stub = func_name + ".vulkan_output.";
+    uint32_t output_arg_idx = 0, output_location = 0;
+    for (const auto &GV : M->globals()) {
+      if (GV.hasName() &&
+          GV.getName().find(output_var_name_stub) != std::string::npos) {
+        auto output_name = GV.getName().split(".vulkan_output.").second;
+
+        assert(output_arg_idx < md_data_output.size() &&
+               "invalid/incomplete output metadata");
+        const auto md_prefix_split_pos =
+            md_data_output[output_arg_idx].find(':');
+        const std::string md_prefix =
+            (md_prefix_split_pos != std::string::npos
+                 ? md_data_output[output_arg_idx].substr(0, md_prefix_split_pos)
+                 : "");
+        const std::string md_info =
+            (md_prefix_split_pos != std::string::npos
+                 ? md_data_output[output_arg_idx].substr(md_prefix_split_pos +
+                                                         1)
+                 : md_data_output[output_arg_idx]);
+
+        if (md_prefix != "") {
+          // -> fbo color
+          if (md_prefix == "stage" &&
+              md_info.find("fbo_output:") != std::string::npos) {
+            spirv_global_io_type global_type;
+            global_type.is_write_only = true;
+            global_type.is_fbo_color = true;
+            emitShaderSPIRVGlobal(BF, GV, output_name.str(), SPIRAS_Output,
+                                  global_type, md_info);
+          }
+          // -> fbo depth
+          else if (md_prefix == "stage" &&
+                   md_info.find("fbo_depth:") != std::string::npos) {
+            spirv_global_io_type global_type;
+            global_type.is_write_only = true;
+            global_type.is_fbo_depth = true;
+            global_type.is_builtin = true;
+            emitShaderSPIRVGlobal(BF, GV, output_name.str(), SPIRAS_Output,
+                                  global_type, md_info, spv::BuiltInFragDepth);
+            // since we explicitly write depth, flag the function as
+            // "DepthReplacing"
+            BF->addExecutionMode(new SPIRVExecutionMode(
+                BF, ExecutionModeDepthReplacing));
+          }
+          // -> builtin
+          else if (md_prefix == "builtin" || md_prefix == "stage") {
+            const auto builtin = get_builtin(md_info);
+            if (!builtin.second) {
+              errs() << "unknown builtin: " << md_info << "\n";
+            }
+
+            const auto is_valid = is_builtin_valid_in_stage(
+                builtin.first, stage, false /* output */);
+            if (is_valid) {
+              spirv_global_io_type global_type;
+              global_type.is_builtin = true;
+              global_type.is_write_only = true;
+              emitShaderSPIRVGlobal(BF, GV, output_name.str(), SPIRAS_Output,
+                                    global_type, md_info, builtin.first);
+            } else {
+              // TODO: should catch this earlier
+              errs() << "output builtin \"" << md_info
+                     << "\" can not be used in stage \""
+                     << vulkan_stage_to_string(stage) << "\"\n";
+            }
+          }
+          // -> unknown or unhandled yet
+          else {
+            assert(false && "unknown or unhandled output");
+          }
+        }
+        // -> normal output
+        else {
+          spirv_global_io_type global_type;
+          global_type.is_write_only = true;
+          global_type.set_location = true;
+          global_type.location = output_location++;
+          emitShaderSPIRVGlobal(BF, GV, output_name.str(), SPIRAS_Output,
+                                global_type, md_info);
+        }
+        ++output_arg_idx;
+      }
+    }
+
+    // add immutable samples to the interface
+    if (immutable_samplers) {
+      BM->addEntryPointIO(BF->getId(), immutable_samplers);
+    }
+
+    // Create all basic blocks before creating any instruction.
+    for (Function::iterator FI = F->begin(), FE = F->end(); FI != FE; ++FI) {
+      transValue(&*FI, nullptr);
+    }
+
+    // set compute shader constant work-group size
+    if (F->getCallingConv() == llvm::CallingConv::FLOOR_KERNEL) {
+      const auto global_name = func_name + ".vulkan_constant.workgroup_size";
+      auto gv_wg_size = M->getNamedGlobal(global_name);
+
+      // NOTE: 128 is the minimum value that has to be supported for x
+      const uint32_t default_wg_size_vals[3]{128, 1, 1};
+      auto uint_type = BM->addIntegerType(32, false);
+      auto uint3_type = BM->addVectorType(uint_type, 3);
+      std::vector<SPIRVValue *> wg_size_vals{
+          BM->addSpecIntegerConstant(uint_type, default_wg_size_vals[0]),
+          BM->addSpecIntegerConstant(uint_type, default_wg_size_vals[1]),
+          BM->addSpecIntegerConstant(uint_type, default_wg_size_vals[2]),
+      };
+      auto wg_size = BM->addSpecCompositeConstant(uint3_type, wg_size_vals);
+      wg_size->addDecorate(spv::DecorationBuiltIn, spv::BuiltInWorkgroupSize);
+      BM->setName(wg_size, global_name);
+      BF->addExecutionMode(new SPIRVExecutionMode(
+          BF, spv::ExecutionModeLocalSize, default_wg_size_vals[0],
+          default_wg_size_vals[1], default_wg_size_vals[2]));
+
+      // set work-group size (x, y, z) spec ids to 1, 2 and 3
+      // NOTE: we're starting this at 1 instead of 0, b/c of nvidia driver bugs
+      for (uint32_t i = 0; i < 3; ++i) {
+        wg_size_vals[i]->addDecorate(spv::DecorationSpecId, i + 1);
+      }
+
+      // preempt loads of the "<i32 x 3>*" work-group size constant
+      // -> this has to be a constant composite in SPIR-V, not a variable
+      // -> replace (map) all loads with the constant
+      std::vector<User *> users;
+      for (auto user : gv_wg_size->users()) {
+        users.emplace_back(user);
+      }
+
+      if (!users.empty()) {
+        // bitcast uint3 -> int3 for all users
+        // NOTE/TODO: ideally, this should stay a uint3, but this would incur
+        // type mismatch problems later on (would need to do int type inference
+        // over the whole function to fix this properly)
+        auto int_type = BM->addIntegerType(32, true);
+        auto int3_type = BM->addVectorType(int_type, 3);
+        auto entry_bb = (SPIRVBasicBlock *)transValue(&*F->begin(), nullptr);
+        auto wg_size_int3 =
+            BM->addUnaryInst(spv::OpBitcast, int3_type, wg_size, entry_bb);
+
+        for (auto user : users) {
+          if (const auto instr = dyn_cast<LoadInst>(user)) {
+            mapValue((const Value *)instr, wg_size_int3);
+          }
+        }
+      }
+    }
+  } else if (SrcLang != SourceLanguageGLSL) {
+    // Creating all basic blocks before creating any instruction.
+    for (auto &FI : *F) {
+      transValue(&FI, nullptr);
+    }
   }
-  for (auto &FI : *I) {
+
+  // handle global constant variables, these need to be lowered to
+  // function-scope (duplicate per function)
+  // SPIR-V 1.4+: also handle local buffers (add to interface)
+  // NOTE: needs to be done after basic blocks have been created (to add
+  // OpVariables), but before being used when adding the instructions
+  std::unordered_set<GlobalVariable *> added_globals;
+  for (auto &GV : M->globals()) {
+    // don't want to handle the globals that we added in here
+    if (added_globals.count(&GV) > 0)
+      continue;
+
+    // ignore external globals
+    if (GV.getLinkage() == GlobalValue::ExternalLinkage ||
+        GV.getLinkage() == GlobalValue::AvailableExternallyLinkage ||
+        GV.getLinkage() == GlobalValue::PrivateLinkage ||
+        GV.getLinkage() == GlobalValue::ExternalWeakLinkage)
+      continue;
+
+    const auto gv_as = GV.getType()->getAddressSpace();
+    if (SPIRSPIRVAddrSpaceMap::map(static_cast<SPIRAddressSpace>(gv_as)) ==
+        spv::StorageClassFunction) {
+      bool is_used_in_function = false;
+      for (const auto &user : GV.users()) {
+        if (const auto instr = dyn_cast<Instruction>(user)) {
+          if (instr->getParent()->getParent() == F) {
+            is_used_in_function = true;
+            break;
+          }
+        }
+      }
+      if (!is_used_in_function)
+        continue;
+
+      // duplicate the global + replace all uses of it in this function with the
+      // duplicate
+      auto dup = new GlobalVariable(
+          *M, GV.getType()->getPointerElementType(), GV.isConstant(),
+          GlobalVariable::InternalLinkage,
+          (GV.hasInitializer() ? GV.getInitializer() : nullptr),
+          GV.getName() + "." + F->getName(), nullptr,
+          GlobalValue::NotThreadLocal, GV.getType()->getAddressSpace());
+      added_globals.emplace(dup);
+
+      // need to copy all uses beforehand due iter invalidation
+      std::vector<Use *> uses;
+      uses.reserve(GV.getNumUses());
+      for (auto &use : GV.uses()) {
+        uses.emplace_back(&use);
+      }
+
+      for (auto &use : uses) {
+        if (const auto instr = dyn_cast<Instruction>(use->getUser())) {
+          if (instr->getParent()->getParent() == F) {
+            use->set(dup);
+          }
+        }
+      }
+
+      // translate value/duplicate at the beginning of the entry BB of this
+      // function
+      auto BB = (SPIRVBasicBlock *)transValue(&F->getEntryBlock(), nullptr);
+      transValue(dup, BB);
+    } else if (SPIRSPIRVAddrSpaceMap::map(static_cast<SPIRAddressSpace>(
+                   gv_as)) == spv::StorageClassWorkgroup) {
+      BM->addEntryPointIO(BF->getId(),
+                          (SPIRVVariable *)transValue(&GV, nullptr));
+    }
+  }
+
+  // create all instructions
+  for (auto &FI : *F) {
     SPIRVBasicBlock *BB =
         static_cast<SPIRVBasicBlock *>(transValue(&FI, nullptr));
     for (auto &BI : FI) {
@@ -3341,14 +5204,74 @@ void LLVMToSPIRVBase::transFunction(Function *I) {
     }
   }
   // Enable FP contraction unless proven otherwise
-  joinFPContract(I, FPContract::ENABLED);
-  fpContractUpdateRecursive(I, getFPContract(I));
+  joinFPContract(F, FPContract::ENABLED);
+  fpContractUpdateRecursive(F, getFPContract(F));
+
+  if (isEntryPoint(F) && SrcLang != SourceLanguageGLSL /* already handled */) {
+    collectInputOutputVariables(BF, F);
+  }
+}
+
+bool LLVMToSPIRVBase::transVulkanVersion() {
+  SrcLang = std::get<0>(getSPIRVSource(M));
+  if (SrcLang != SourceLanguageGLSL) {
+    return true;
+  }
 
-  bool IsKernelEntryPoint = isKernel(I);
+  const llvm::NamedMDNode *VulkanVersion =
+      M->getNamedMetadata("vulkan.version");
+  if (VulkanVersion == nullptr || VulkanVersion->getNumOperands() != 1) {
+    return false;
+  }
+
+  const MDNode *vulkan_version_md = VulkanVersion->getOperand(0);
+  if (vulkan_version_md->getNumOperands() < 2) {
+    return false;
+  }
+
+  uint64_t version_major = 0, version_minor = 0;
+
+  const MDOperand &version_major_op = vulkan_version_md->getOperand(0);
+  if (const ConstantAsMetadata *version_major_md =
+          dyn_cast_or_null<ConstantAsMetadata>(version_major_op.get())) {
+    if (const ConstantInt *version_major_int =
+            dyn_cast_or_null<ConstantInt>(version_major_md->getValue())) {
+      version_major = version_major_int->getZExtValue();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
 
-  if (IsKernelEntryPoint) {
-    collectInputOutputVariables(BF, I);
+  const MDOperand &version_minor_op = vulkan_version_md->getOperand(1);
+  if (const ConstantAsMetadata *version_minor_md =
+          dyn_cast_or_null<ConstantAsMetadata>(version_minor_op.get())) {
+    if (const ConstantInt *version_minor_int =
+            dyn_cast_or_null<ConstantInt>(version_minor_md->getValue())) {
+      version_minor = version_minor_int->getZExtValue();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
   }
+
+  switch (version_major) {
+  case 1:
+    switch (version_minor) {
+    case 2:
+      BM->setSPIRVVersion(static_cast<uint32_t>(VersionNumber::SPIRV_1_5));
+      break;
+    default:
+      return false;
+    }
+    break;
+  default:
+    return false;
+  }
+
+  return true;
 }
 
 bool isEmptyLLVMModule(Module *M) {
@@ -3362,6 +5285,8 @@ bool LLVMToSPIRVBase::translate() {
   if (isEmptyLLVMModule(M))
     BM->addCapability(CapabilityLinkage);
 
+  if (!transVulkanVersion())
+    return false;
   if (!transSourceLanguage())
     return false;
   if (!transExtension())
@@ -3460,37 +5385,55 @@ SPIRVInstruction *LLVMToSPIRVBase::transBuiltinToInst(StringRef DemangledName,
                                                       CallInst *CI,
                                                       SPIRVBasicBlock *BB) {
   SmallVector<std::string, 2> Dec;
-  auto OC = getSPIRVFuncOC(DemangledName, &Dec);
+  Op OC = OpNop;
+  SPIRVInstruction *Inst = nullptr;
+
+  // special handling for Vulkan/SPIR-V image read/write
+  if (SrcLang == spv::SourceLanguageGLSL &&
+      (DemangledName.find(kOCLBuiltinName::ReadImage) == 0 ||
+       DemangledName.find(kOCLBuiltinName::WriteImage) == 0 ||
+       DemangledName.find(std::string(kSPIRVName::Prefix) +
+                          kSPIRVName::ImageQuerySize) ==
+           0 /* matches both LOD and non-LOD */)) {
+    auto inst_op = transVulkanImageFunction(CI, BB, DemangledName.str());
+    assert(inst_op.first != nullptr && inst_op.second != OpNop &&
+           "failed to translate image read/write function");
+    Inst = inst_op.first;
+    OC = inst_op.second;
+  } else {
+    OC = getSPIRVFuncOC(DemangledName, &Dec);
 
-  if (OC == OpNop)
-    return nullptr;
+    if (OC == OpNop)
+      return nullptr;
 
-  if (OpReadPipeBlockingINTEL <= OC && OC <= OpWritePipeBlockingINTEL &&
-      !BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_blocking_pipes))
-    return nullptr;
+    if (OpReadPipeBlockingINTEL <= OC && OC <= OpWritePipeBlockingINTEL &&
+        !BM->isAllowedToUseExtension(ExtensionID::SPV_INTEL_blocking_pipes))
+      return nullptr;
+
+    if (OpFixedSqrtINTEL <= OC && OC <= OpFixedExpINTEL)
+      BM->getErrorLog().checkError(
+          BM->isAllowedToUseExtension(
+              ExtensionID::SPV_INTEL_arbitrary_precision_fixed_point),
+          SPIRVEC_InvalidInstruction,
+          CI->getCalledOperand()->getName().str() +
+              "\nFixed point instructions can't be translated correctly without "
+              "enabled SPV_INTEL_arbitrary_precision_fixed_point extension!\n");
+
+    if ((OpArbitraryFloatSinCosPiINTEL <= OC &&
+         OC <= OpArbitraryFloatCastToIntINTEL) ||
+        (OpArbitraryFloatAddINTEL <= OC && OC <= OpArbitraryFloatPowNINTEL))
+      BM->getErrorLog().checkError(
+          BM->isAllowedToUseExtension(
+              ExtensionID::SPV_INTEL_arbitrary_precision_floating_point),
+          SPIRVEC_InvalidInstruction,
+          CI->getCalledOperand()->getName().str() +
+              "\nFloating point instructions can't be translated correctly "
+              "without enabled SPV_INTEL_arbitrary_precision_floating_point "
+              "extension!\n");
+
+    Inst = transBuiltinToInstWithoutDecoration(OC, CI, BB);
+  }
 
-  if (OpFixedSqrtINTEL <= OC && OC <= OpFixedExpINTEL)
-    BM->getErrorLog().checkError(
-        BM->isAllowedToUseExtension(
-            ExtensionID::SPV_INTEL_arbitrary_precision_fixed_point),
-        SPIRVEC_InvalidInstruction,
-        CI->getCalledOperand()->getName().str() +
-            "\nFixed point instructions can't be translated correctly without "
-            "enabled SPV_INTEL_arbitrary_precision_fixed_point extension!\n");
-
-  if ((OpArbitraryFloatSinCosPiINTEL <= OC &&
-       OC <= OpArbitraryFloatCastToIntINTEL) ||
-      (OpArbitraryFloatAddINTEL <= OC && OC <= OpArbitraryFloatPowNINTEL))
-    BM->getErrorLog().checkError(
-        BM->isAllowedToUseExtension(
-            ExtensionID::SPV_INTEL_arbitrary_precision_floating_point),
-        SPIRVEC_InvalidInstruction,
-        CI->getCalledOperand()->getName().str() +
-            "\nFloating point instructions can't be translated correctly "
-            "without enabled SPV_INTEL_arbitrary_precision_floating_point "
-            "extension!\n");
-
-  auto Inst = transBuiltinToInstWithoutDecoration(OC, CI, BB);
   addDecorations(Inst, Dec);
   return Inst;
 }
@@ -3510,8 +5453,10 @@ bool LLVMToSPIRVBase::transExecutionMode() {
 
       switch (EMode) {
       case spv::ExecutionModeContractionOff:
-        BF->addExecutionMode(BM->add(
-            new SPIRVExecutionMode(BF, static_cast<ExecutionMode>(EMode))));
+        if (SrcLang != spv::SourceLanguageGLSL) {
+          BF->addExecutionMode(BM->add(
+              new SPIRVExecutionMode(BF, static_cast<ExecutionMode>(EMode))));
+        }
         break;
       case spv::ExecutionModeInitializer:
       case spv::ExecutionModeFinalizer:
@@ -3628,9 +5573,9 @@ void LLVMToSPIRVBase::transFPContract() {
     }
     SPIRVFunction *BF = static_cast<SPIRVFunction *>(TranslatedF);
 
-    bool IsKernelEntryPoint =
+    bool IsEntryPoint =
         BF->getModule()->isEntryPoint(spv::ExecutionModelKernel, BF->getId());
-    if (!IsKernelEntryPoint)
+    if (!IsEntryPoint)
       continue;
 
     FPContract FPC = getFPContract(&F);
@@ -3649,7 +5594,7 @@ void LLVMToSPIRVBase::transFPContract() {
       break;
     }
 
-    if (DisableContraction) {
+    if (DisableContraction && SrcLang != spv::SourceLanguageGLSL) {
       BF->addExecutionMode(BF->getModule()->add(
           new SPIRVExecutionMode(BF, spv::ExecutionModeContractionOff)));
     }
@@ -3668,8 +5613,13 @@ bool LLVMToSPIRVBase::transMetadata() {
 }
 
 bool LLVMToSPIRVBase::transOCLMetadata() {
+  // TODO: do shaders need to be handled in here?
+  if (SrcLang == spv::SourceLanguageGLSL) {
+    return true;
+  }
+
   for (auto &F : *M) {
-    if (F.getCallingConv() != CallingConv::SPIR_KERNEL)
+    if (F.getCallingConv() != CallingConv::FLOOR_KERNEL)
       continue;
 
     SPIRVFunction *BF = static_cast<SPIRVFunction *>(getTranslatedValue(&F));
@@ -3713,6 +5663,10 @@ bool LLVMToSPIRVBase::transSourceLanguage() {
   auto Src = getSPIRVSource(M);
   SrcLang = std::get<0>(Src);
   SrcLangVer = std::get<1>(Src);
+  if (SrcLang == SourceLanguageGLSL) {
+    // "GLSL" is compiled as OpenCL 2.0 -> switch out the version number
+    SrcLangVer = 450;
+  }
   BM->setSourceLanguage(static_cast<SourceLanguage>(SrcLang), SrcLangVer);
   return true;
 }
@@ -3754,9 +5708,283 @@ Op LLVMToSPIRVBase::transBoolOpCode(SPIRVValue *Opn, Op OC) {
   return OC;
 }
 
+std::pair<SPIRVInstruction *, Op>
+LLVMToSPIRVBase::transVulkanImageFunction(CallInst *CI, SPIRVBasicBlock *BB,
+                                          const std::string &DemangledName) {
+  // NOTE: argument validity checking has already been done in VulkanImage
+  //
+  // read(image, sampler_idx, coord_with_layer,
+  //      lod_type, [lod_arg_0], [lod_arg_1],
+  //      bool is_offset, [offset],
+  //      [sample_idx],
+  //      [compare_val])
+  //
+  // write(image, coord_with_layer, data,
+  //       // NOTE: only explicit lod or no lod
+  //       lod_type, [lod_arg_0])
+  //
+  // query(image, lod)
+  //
+
+  // TODO: try to "cache" these things (image loads and sampler stuff)
+
+  auto args = getArguments(CI);
+  auto img_arg = args[0];
+  auto spirv_img = getSPIRVValue(img_arg);
+  assert(spirv_img != nullptr && "invalid image");
+
+  SPIRVValue *loaded_img = nullptr;
+  if (!isa<CallInst>(img_arg)) {
+    // load the image (image function argument)
+    loaded_img = BM->addLoadInst(spirv_img, {}, BB);
+  } else {
+    // special call, image has already been loaded (e.g. image array load)
+    loaded_img = spirv_img;
+  }
+  auto spirv_img_type = (SPIRVTypeImage *)loaded_img->getType();
+
+  std::vector<SPIRVWord> image_operands;
+  uint32_t operands_mask = spv::ImageOperandsMaskNone;
+
+  if (DemangledName.find("read_image") == 0) {
+    // retrieve the sampler idx + load the sampler
+    auto sampler_idx_arg = dyn_cast<ConstantInt>(args[1]);
+    assert(sampler_idx_arg != nullptr && "sampler must be a constant int");
+    const vulkan_sampling::sampler sampler_val{
+        (uint32_t)sampler_idx_arg->getZExtValue()};
+    const bool is_fetch =
+        ((sampler_val.value &
+          vulkan_sampling::sampler::COORD_MODE::__COORD_MODE_MASK) ==
+         vulkan_sampling::sampler::COORD_MODE::PIXEL);
+
+    // only load the sampler + create the sampled image if necessary
+    SPIRVValue *loaded_sampler = nullptr;
+    SPIRVValue *img = loaded_img;
+    if (!is_fetch) {
+      std::vector<SPIRVValue *> indices{
+          BM->getLiteralAsConstant(sampler_val.value, false)};
+
+      auto sampler_ptr = BM->addAccessChainInst(
+          BM->addPointerType(spv::StorageClassUniformConstant,
+                             BM->addSamplerType()),
+          immutable_samplers, indices, BB, true);
+      loaded_sampler = BM->addLoadInst(sampler_ptr, {}, BB);
+
+      // create the sampled image
+      std::vector<SPIRVWord> sampled_img_ops{
+          loaded_img->getId(),
+          loaded_sampler->getId(),
+      };
+      img = BM->addInstTemplate(OpSampledImage, sampled_img_ops, BB,
+                                BM->addSampledImageType(spirv_img_type));
+    }
+
+    std::vector<SPIRVWord> read_operands{img->getId()};
+    spv::Op read_opcode = spv::OpNop;
+
+    // coords
+    auto coords_arg = transValue(args[2], BB);
+    read_operands.emplace_back(coords_arg->getId());
+
+    // lod type and args
+    auto lod_type_arg = dyn_cast<ConstantInt>(args[3]);
+    uint32_t arg_idx = 4; // from here on: arg count and indices are variable
+    assert(lod_type_arg != nullptr && "lod type must be a constant int");
+    auto lod_type = (vulkan_sampling::LOD_TYPE)lod_type_arg->getZExtValue();
+    assert(lod_type <= vulkan_sampling::LOD_TYPE::__MAX_LOD_TYPE &&
+           "invalid lod type");
+    switch (lod_type) {
+    case vulkan_sampling::LOD_TYPE::NO_LOD:
+      read_opcode = spv::OpImageFetch;
+      break;
+    case vulkan_sampling::LOD_TYPE::IMPLICIT_LOD:
+      read_opcode = spv::OpImageSampleImplicitLod;
+      break;
+    case vulkan_sampling::LOD_TYPE::IMPLICIT_LOD_WITH_BIAS:
+      read_opcode = spv::OpImageSampleImplicitLod;
+      operands_mask |= spv::ImageOperandsBiasMask;
+      image_operands.emplace_back(transValue(args[arg_idx++], BB)->getId());
+      break;
+    case vulkan_sampling::LOD_TYPE::EXPLICIT_LOD:
+      read_opcode =
+          (!is_fetch ? spv::OpImageSampleExplicitLod : spv::OpImageFetch);
+      operands_mask |= spv::ImageOperandsLodMask;
+      image_operands.emplace_back(transValue(args[arg_idx++], BB)->getId());
+      break;
+    case vulkan_sampling::LOD_TYPE::GRADIENT:
+      read_opcode =
+          (!is_fetch ? spv::OpImageSampleExplicitLod : spv::OpImageFetch);
+      operands_mask |= spv::ImageOperandsGradMask;
+      image_operands.emplace_back(transValue(args[arg_idx++], BB)->getId());
+      image_operands.emplace_back(transValue(args[arg_idx++], BB)->getId());
+      break;
+    default:
+      llvm_unreachable("invalid lod type");
+    }
+
+    // offset
+    auto is_offset_arg = dyn_cast<ConstantInt>(args[arg_idx++]);
+    assert(is_offset_arg != nullptr && "is_offset flag must be a constant int");
+    if (!is_offset_arg->isZero()) {
+      auto offset_arg = args[arg_idx++];
+      if (isa<Constant>(offset_arg)) {
+        operands_mask |= spv::ImageOperandsConstOffsetMask;
+      } else {
+        operands_mask |= spv::ImageOperandsOffsetMask;
+        BM->addCapability(spv::CapabilityImageGatherExtended);
+      }
+      image_operands.emplace_back(transValue(offset_arg, BB)->getId());
+    }
+
+    // sample idx
+    if (DemangledName.find("msaa") != std::string::npos) {
+      auto sample_idx_arg = args[arg_idx++];
+      operands_mask |= spv::ImageOperandsSampleMask;
+      image_operands.emplace_back(transValue(sample_idx_arg, BB)->getId());
+    }
+
+    // depth compare
+    bool is_depth_compare = false;
+    if (arg_idx < args.size()) {
+      is_depth_compare = true;
+      auto compare_arg = args[arg_idx++];
+
+      // must switch out the opcode
+      assert((read_opcode == spv::OpImageSampleImplicitLod ||
+              read_opcode == spv::OpImageSampleExplicitLod) &&
+             "invalid read opcode");
+      read_opcode =
+          (spv::OpImageSampleImplicitLod ? spv::OpImageSampleDrefImplicitLod
+                                         : spv::OpImageSampleDrefExplicitLod);
+      read_operands.emplace_back(transValue(compare_arg, BB)->getId());
+    }
+
+    // sanity check
+    assert(arg_idx == args.size() && "unhandled args");
+
+    // create the image read
+    if (operands_mask != spv::ImageOperandsMaskNone) {
+      // must only be emitted if mask != None + operands are ordered
+      read_operands.emplace_back(operands_mask);
+      for (const auto &id : image_operands) {
+        read_operands.emplace_back(id);
+      }
+    }
+
+    SPIRVType *scalar_ret_type = nullptr;
+    if (DemangledName.find("read_imageui") == 0) {
+      scalar_ret_type = BM->addIntegerType(32, false);
+    } else if (DemangledName.find("read_imagei") == 0) {
+      scalar_ret_type = BM->addIntegerType(32, true);
+    } else if (DemangledName.find("read_imagef") == 0) {
+      scalar_ret_type = BM->addFloatType(32);
+    } else {
+      assert(false && "invalid image read function");
+    }
+
+    SPIRVType *ret_type = scalar_ret_type; // only depth compare is scalar
+    if (!is_depth_compare) {
+      ret_type = BM->addVectorType(scalar_ret_type, 4);
+    }
+
+    auto read_sample =
+        BM->addInstTemplate(read_opcode, read_operands, BB, ret_type);
+    return {read_sample, read_sample->getOpCode()};
+  } else if (DemangledName.find("write_image") == 0) {
+    std::vector<SPIRVWord> write_operands{loaded_img->getId()};
+
+    // coords
+    auto coords_arg = transValue(args[1], BB);
+    write_operands.emplace_back(coords_arg->getId());
+
+    // data
+    // TODO: proper uint/int data type?
+    auto data_arg = transValue(args[2], BB);
+    write_operands.emplace_back(data_arg->getId());
+
+    // lod type and args
+    auto lod_type_arg = dyn_cast<ConstantInt>(args[3]);
+    uint32_t arg_idx = 4; // from here on: arg count and indices are variable
+    assert(lod_type_arg != nullptr && "lod type must be a constant int");
+    auto lod_type = (vulkan_sampling::LOD_TYPE)lod_type_arg->getZExtValue();
+    assert(lod_type <= vulkan_sampling::LOD_TYPE::__MAX_LOD_TYPE &&
+           "invalid lod type");
+    switch (lod_type) {
+    case vulkan_sampling::LOD_TYPE::NO_LOD:
+      // nop
+      break;
+    case vulkan_sampling::LOD_TYPE::EXPLICIT_LOD:
+      // NOTE: SPIR-V supports this, but Vulkan doesn't
+      //       -> this is dealt with elsewhere
+      // operands_mask |= spv::ImageOperandsLodMask;
+      // image_operands.emplace_back(transValue(args[arg_idx++], BB)->getId());
+      ++arg_idx;
+      break;
+    case vulkan_sampling::LOD_TYPE::IMPLICIT_LOD:
+    case vulkan_sampling::LOD_TYPE::IMPLICIT_LOD_WITH_BIAS:
+    case vulkan_sampling::LOD_TYPE::GRADIENT:
+    default:
+      llvm_unreachable("invalid lod type");
+    }
+
+    // sample idx
+    if (DemangledName.find("msaa") != std::string::npos) {
+      // TODO: !
+      // auto sample_idx_arg = args[arg_idx++];
+      // operands_mask |= spv::ImageOperandsSampleMask;
+      // image_operands.emplace_back(transValue(sample_idx_arg, BB)->getId());
+    }
+
+    // sanity check
+    assert(arg_idx == args.size() && "unhandled args");
+
+    // create the image write
+    if (operands_mask != spv::ImageOperandsMaskNone) {
+      // must only be emitted if mask != None + operands are ordered
+      write_operands.emplace_back(operands_mask);
+      for (const auto &id : image_operands) {
+        write_operands.emplace_back(id);
+      }
+    }
+    auto write_sample =
+        BM->addInstTemplate(spv::OpImageWrite, write_operands, BB, nullptr);
+    return {write_sample, write_sample->getOpCode()};
+  } else if (DemangledName.find(kSPIRVName::ImageQuerySize) !=
+             std::string::npos) {
+    std::vector<SPIRVWord> query_operands{loaded_img->getId()};
+
+    // query requires cap
+    BM->addCapability(spv::CapabilityImageQuery);
+
+    // buffer and MSAA images must use the non-LOD variant
+    const auto non_lod_variant =
+        (DemangledName.find("msaa") != std::string::npos ||
+         DemangledName.find("buffer") != std::string::npos);
+
+    auto query_op = spv::OpImageQuerySize;
+    if (!non_lod_variant) {
+      auto lod_arg = transValue(args[1], BB);
+      query_operands.emplace_back(lod_arg->getId());
+      query_op = spv::OpImageQuerySizeLod;
+    }
+
+    // the return type is already correct on the LLVM side, just translate it
+    SPIRVType *ret_type = transType(CI->getType());
+
+    auto img_query =
+        BM->addInstTemplate(query_op, query_operands, BB, ret_type);
+    return {img_query, img_query->getOpCode()};
+  }
+
+  return {nullptr, OpNop};
+}
+
 SPIRVInstruction *
 LLVMToSPIRVBase::transBuiltinToInstWithoutDecoration(Op OC, CallInst *CI,
                                                      SPIRVBasicBlock *BB) {
+  assert(!(SrcLang == spv::SourceLanguageGLSL && isImageOpCode(OC)) &&
+         "should not be here");
+
   if (isGroupOpCode(OC))
     BM->addCapability(CapabilityGroups);
   switch (OC) {
@@ -4100,6 +6328,7 @@ void addPassesForSPIRV(legacy::PassManager &PassMgr,
   PassMgr.add(createOCLTypeToSPIRVLegacy());
   PassMgr.add(createSPIRVLowerOCLBlocksLegacy());
   PassMgr.add(createOCLToSPIRVLegacy());
+  PassMgr.add(createLLVMToSPIRVTransformations());
   PassMgr.add(createSPIRVRegularizeLLVMLegacy());
   PassMgr.add(createSPIRVLowerConstExprLegacy());
   PassMgr.add(createSPIRVLowerBoolLegacy());
@@ -4122,7 +6351,7 @@ bool isValidLLVMModule(Module *M, SPIRVErrorLog &ErrorLog) {
   return true;
 }
 
-bool llvm::writeSpirv(Module *M, std::ostream &OS, std::string &ErrMsg) {
+bool llvm::writeSpirv(Module *M, spv_ostream &OS, std::string &ErrMsg) {
   SPIRV::TranslatorOpts DefaultOpts;
   // To preserve old behavior of the translator, let's enable all extensions
   // by default in this API
@@ -4131,17 +6360,19 @@ bool llvm::writeSpirv(Module *M, std::ostream &OS, std::string &ErrMsg) {
 }
 
 bool llvm::writeSpirv(Module *M, const SPIRV::TranslatorOpts &Opts,
-                      std::ostream &OS, std::string &ErrMsg) {
+                      spv_ostream &OS, std::string &ErrMsg) {
   std::unique_ptr<SPIRVModule> BM(SPIRVModule::createSPIRVModule(Opts));
   if (!isValidLLVMModule(M, BM->getErrorLog()))
     return false;
 
   legacy::PassManager PassMgr;
   addPassesForSPIRV(PassMgr, Opts);
+#if 0 // absolutely DO NOT do this
   // Run loop simplify pass in order to avoid duplicate OpLoopMerge
   // instruction. It can happen in case of continue operand in the loop.
   if (hasLoopMetadata(M))
     PassMgr.add(createLoopSimplifyPass());
+#endif
   PassMgr.add(createLLVMToSPIRVLegacy(BM.get()));
   PassMgr.run(*M);
 
diff --git a/lib/SPIRV/SPIRVWriter.h b/lib/SPIRV/SPIRVWriter.h
index 9b21121..46243d8 100644
--- a/lib/SPIRV/SPIRVWriter.h
+++ b/lib/SPIRV/SPIRVWriter.h
@@ -91,6 +91,7 @@ public:
   bool transAlign(Value *V, SPIRVValue *BV);
   std::vector<SPIRVWord> transArguments(CallInst *, SPIRVBasicBlock *,
                                         SPIRVEntry *);
+  bool transVulkanVersion();
   bool transSourceLanguage();
   bool transExtension();
   bool transBuiltinSet();
@@ -130,7 +131,7 @@ public:
                                                        SPIRVInstruction *I);
 
   typedef DenseMap<Type *, SPIRVType *> LLVMToSPIRVTypeMap;
-  typedef DenseMap<Value *, SPIRVValue *> LLVMToSPIRVValueMap;
+  typedef DenseMap<const Value *, SPIRVValue *> LLVMToSPIRVValueMap;
   typedef DenseMap<MDNode *, SmallSet<SPIRVId, 2>> LLVMToSPIRVMetadataMap;
 
   void setOCLTypeToSPIRV(OCLTypeToSPIRVBase *OCLTypeToSPIRV) {
@@ -159,8 +160,15 @@ private:
   bool joinFPContract(Function *F, FPContract C);
   void fpContractUpdateRecursive(Function *F, FPContract FPC);
 
+  // adds a SPIR-V float/int/uint scalar or vector type based on the LLVM type
+  // based on the 'is_signed' signedness - this is different to mapType and
+  // transType, because these won't handle signedness.
+  SPIRVType *addSignPreservingLLVMType(llvm::Type *type,
+                                       const bool is_signed = true);
+
   SPIRVType *mapType(Type *T, SPIRVType *BT);
-  SPIRVValue *mapValue(Value *V, SPIRVValue *BV);
+  SPIRVValue *mapValue(const Value *V, SPIRVValue *BV);
+  SPIRVValue *getSPIRVValue(const Value *V) { return ValueMap[V]; }
   SPIRVType *getSPIRVType(Type *T) { return TypeMap[T]; }
   SPIRVErrorLog &getErrorLog() { return BM->getErrorLog(); }
   llvm::IntegerType *getSizetType(unsigned AS = 0);
@@ -191,7 +199,8 @@ private:
                                SPIRVExtInstSetKind *BuiltinSet = nullptr,
                                SPIRVWord *EntryPoint = nullptr,
                                SmallVectorImpl<std::string> *Dec = nullptr);
-  bool isKernel(Function *F);
+  bool isEntryPoint(Function *F);
+  spv::ExecutionModel getEntryPointType(Function *F, unsigned int SrcLang);
   bool transMetadata();
   bool transOCLMetadata();
   SPIRVInstruction *transBuiltinToInst(StringRef DemangledName, CallInst *CI,
@@ -214,6 +223,48 @@ private:
       const Function *FS,
       const std::unordered_set<const Function *> Funcs) const;
   void collectInputOutputVariables(SPIRVFunction *SF, Function *F);
+
+  void decorateComposite(llvm::Type *llvm_type, SPIRVType *spirv_type);
+
+  bool ignore_next_unreachable{false};
+
+  //
+  struct spirv_global_io_type {
+    bool is_constant{false};
+    bool is_uniform{false};
+    bool is_iub{false};
+    bool is_input{false};
+    bool is_builtin{false};
+    bool is_image{false};
+    bool is_fbo_color{false};
+    bool is_fbo_depth{false};
+    bool is_read_only{false};
+    bool is_write_only{false};
+    bool set_location{false};
+    uint32_t location{0};
+  };
+
+  GlobalVariable *emitShaderGlobal(
+      const Function &F, SPIRVFunction *spirv_func, const std::string &var_name,
+      llvm::Type *llvm_type, uint32_t address_space,
+      const spirv_global_io_type global_type, const std::string &md_info,
+      SPIRVVariable **created_spirv_var = nullptr,
+      spv::BuiltIn builtin = spv::BuiltIn::BuiltInPosition);
+
+  SPIRVVariable *
+  emitShaderSPIRVGlobal(SPIRVFunction *spirv_func, const GlobalVariable &GV,
+                        const std::string &var_name, uint32_t address_space,
+                        const spirv_global_io_type global_type,
+                        const std::string &md_info,
+                        spv::BuiltIn builtin = spv::BuiltIn::BuiltInPosition);
+
+  SPIRVVariable *immutable_samplers{nullptr};
+  std::pair<SPIRVInstruction *, Op>
+  transVulkanImageFunction(CallInst *CI, SPIRVBasicBlock *BB,
+                           const std::string &DemangledName);
+
+  // function image arg -> image type map
+  std::unordered_map<const llvm::Value *, SPIRVType *> image_type_map;
 };
 
 class LLVMToSPIRVPass : public PassInfoMixin<LLVMToSPIRVPass>,
diff --git a/lib/SPIRV/SPIRVWriterPass.cpp b/lib/SPIRV/SPIRVWriterPass.cpp
index 4e211d0..50208e4 100644
--- a/lib/SPIRV/SPIRVWriterPass.cpp
+++ b/lib/SPIRV/SPIRVWriterPass.cpp
@@ -18,7 +18,7 @@
 #include "llvm/Pass.h"
 using namespace llvm;
 
-PreservedAnalyses SPIRVWriterPass::run(Module &M) {
+PreservedAnalyses SPIRVWriterPass::run(Module &M, ModuleAnalysisManager&) {
   // FIXME: at the moment LLVM/SPIR-V translation errors are ignored.
   std::string Err;
   writeSpirv(&M, Opts, OS, Err);
@@ -27,12 +27,12 @@ PreservedAnalyses SPIRVWriterPass::run(Module &M) {
 
 namespace {
 class WriteSPIRVPass : public ModulePass {
-  std::ostream &OS; // std::ostream to print on
+  raw_ostream& OS; // std::ostream to print on
   SPIRV::TranslatorOpts Opts;
 
 public:
   static char ID; // Pass identification, replacement for typeid
-  WriteSPIRVPass(std::ostream &OS, const SPIRV::TranslatorOpts &Opts)
+  WriteSPIRVPass(raw_ostream &OS, const SPIRV::TranslatorOpts &Opts)
       : ModulePass(ID), OS(OS), Opts(Opts) {}
 
   StringRef getPassName() const override { return "SPIRV Writer"; }
@@ -48,7 +48,7 @@ public:
 
 char WriteSPIRVPass::ID = 0;
 
-ModulePass *llvm::createSPIRVWriterPass(std::ostream &Str) {
+ModulePass *llvm::createSPIRVWriterPass(raw_ostream &Str) {
   SPIRV::TranslatorOpts DefaultOpts;
   // To preserve old behavior of the translator, let's enable all extensions
   // by default in this API
@@ -56,7 +56,7 @@ ModulePass *llvm::createSPIRVWriterPass(std::ostream &Str) {
   return createSPIRVWriterPass(Str, DefaultOpts);
 }
 
-ModulePass *llvm::createSPIRVWriterPass(std::ostream &Str,
+ModulePass *llvm::createSPIRVWriterPass(raw_ostream &Str,
                                         const SPIRV::TranslatorOpts &Opts) {
   return new WriteSPIRVPass(Str, Opts);
 }
diff --git a/lib/SPIRV/SPIRVWriterPass.h b/lib/SPIRV/SPIRVWriterPass.h
index fe80217..74c12b9 100644
--- a/lib/SPIRV/SPIRVWriterPass.h
+++ b/lib/SPIRV/SPIRVWriterPass.h
@@ -15,8 +15,9 @@
 #ifndef SPIRV_SPIRVWRITERPASS_H
 #define SPIRV_SPIRVWRITERPASS_H
 
-#include "LLVMSPIRVOpts.h"
+#include "llvm/../../projects/spirv/include/LLVMSPIRVOpts.h"
 #include "llvm/ADT/StringRef.h"
+#include "llvm/IR/PassManager.h"
 
 namespace llvm {
 class Module;
@@ -26,33 +27,33 @@ class PreservedAnalyses;
 /// \brief Create and return a pass that writes the module to the specified
 /// ostream. Note that this pass is designed for use with the legacy pass
 /// manager.
-ModulePass *createSPIRVWriterPass(std::ostream &Str);
+ModulePass *createSPIRVWriterPass(raw_ostream &Str);
 
 /// \brief Create and return a pass that writes the module to the specified
 /// ostream. Note that this pass is designed for use with the legacy pass
 /// manager.
-ModulePass *createSPIRVWriterPass(std::ostream &Str,
+ModulePass *createSPIRVWriterPass(raw_ostream &Str,
                                   const SPIRV::TranslatorOpts &Opts);
 
 /// \brief Pass for writing a module of IR out to a SPIRV file.
 ///
 /// Note that this is intended for use with the new pass manager. To construct
 /// a pass for the legacy pass manager, use the function above.
-class SPIRVWriterPass {
-  std::ostream &OS;
+class SPIRVWriterPass : public PassInfoMixin<SPIRVWriterPass> {
+  raw_ostream& OS;
   SPIRV::TranslatorOpts Opts;
 
 public:
   /// \brief Construct a SPIRV writer pass around a particular output stream.
-  explicit SPIRVWriterPass(std::ostream &OS) : OS(OS) {
+  explicit SPIRVWriterPass(raw_ostream &OS) : OS(OS) {
     Opts.enableAllExtensions();
   }
-  SPIRVWriterPass(std::ostream &OS, const SPIRV::TranslatorOpts &Opts)
+  SPIRVWriterPass(raw_ostream &OS, const SPIRV::TranslatorOpts &Opts)
       : OS(OS), Opts(Opts) {}
 
   /// \brief Run the SPIRV writer pass, and output the module to the selected
   /// output stream.
-  PreservedAnalyses run(Module &M);
+  PreservedAnalyses run(Module &M, ModuleAnalysisManager &);
 
   static StringRef name() { return "SPIRVWriterPass"; }
 };
diff --git a/lib/SPIRV/libSPIRV/GLSL.std.450.h b/lib/SPIRV/libSPIRV/GLSL.std.450.h
new file mode 100644
index 0000000..9ca739f
--- /dev/null
+++ b/lib/SPIRV/libSPIRV/GLSL.std.450.h
@@ -0,0 +1,135 @@
+/*
+** Copyright (c) 2014-2016 The Khronos Group Inc.
+**
+** Permission is hereby granted, free of charge, to any person obtaining a copy
+** of this software and/or associated documentation files (the "Materials"),
+** to deal in the Materials without restriction, including without limitation
+** the rights to use, copy, modify, merge, publish, distribute, sublicense,
+** and/or sell copies of the Materials, and to permit persons to whom the
+** Materials are furnished to do so, subject to the following conditions:
+**
+** The above copyright notice and this permission notice shall be included in
+** all copies or substantial portions of the Materials.
+**
+** MODIFICATIONS TO THIS FILE MAY MEAN IT NO LONGER ACCURATELY REFLECTS KHRONOS
+** STANDARDS. THE UNMODIFIED, NORMATIVE VERSIONS OF KHRONOS SPECIFICATIONS AND
+** HEADER INFORMATION ARE LOCATED AT https://www.khronos.org/registry/ 
+**
+** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+** THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+** FROM,OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE USE OR OTHER DEALINGS
+** IN THE MATERIALS.
+*/
+
+#ifndef GLSLstd450_H
+#define GLSLstd450_H
+
+namespace GLSLLIB {
+
+static const int GLSLstd450Version = 100;
+static const int GLSLstd450Revision = 3;
+
+enum GLSLstd450 {
+ Bad = 0,              // Don't use
+
+ Round = 1,
+ RoundEven = 2,
+ Trunc = 3,
+ FAbs = 4,
+ SAbs = 5,
+ FSign = 6,
+ SSign = 7,
+ Floor = 8,
+ Ceil = 9,
+ Fract = 10,
+
+ Radians = 11,
+ Degrees = 12,
+ Sin = 13,
+ Cos = 14,
+ Tan = 15,
+ Asin = 16,
+ Acos = 17,
+ Atan = 18,
+ Sinh = 19,
+ Cosh = 20,
+ Tanh = 21,
+ Asinh = 22,
+ Acosh = 23,
+ Atanh = 24,
+ Atan2 = 25,
+
+ Pow = 26,
+ Exp = 27,
+ Log = 28,
+ Exp2 = 29,
+ Log2 = 30,
+ Sqrt = 31,
+ InverseSqrt = 32,
+
+ Determinant = 33,
+ MatrixInverse = 34,
+
+ Modf = 35,            // second operand needs an OpVariable to write to
+ ModfStruct = 36,      // no OpVariable operand
+ FMin = 37,
+ UMin = 38,
+ SMin = 39,
+ FMax = 40,
+ UMax = 41,
+ SMax = 42,
+ FClamp = 43,
+ UClamp = 44,
+ SClamp = 45,
+ FMix = 46,
+ IMix = 47,            // Reserved
+ Step = 48,
+ SmoothStep = 49,
+
+ Fma = 50,
+ Frexp = 51,            // second operand needs an OpVariable to write to
+ FrexpStruct = 52,      // no OpVariable operand
+ Ldexp = 53,
+
+ PackSnorm4x8 = 54,
+ PackUnorm4x8 = 55,
+ PackSnorm2x16 = 56,
+ PackUnorm2x16 = 57,
+ PackHalf2x16 = 58,
+ PackDouble2x32 = 59,
+ UnpackSnorm2x16 = 60,
+ UnpackUnorm2x16 = 61,
+ UnpackHalf2x16 = 62,
+ UnpackSnorm4x8 = 63,
+ UnpackUnorm4x8 = 64,
+ UnpackDouble2x32 = 65,
+
+ Length = 66,
+ Distance = 67,
+ Cross = 68,
+ Normalize = 69,
+ FaceForward = 70,
+ Reflect = 71,
+ Refract = 72,
+
+ FindILsb = 73,
+ FindSMsb = 74,
+ FindUMsb = 75,
+
+ InterpolateAtCentroid = 76,
+ InterpolateAtSample = 77,
+ InterpolateAtOffset = 78,
+
+ NMin = 79,
+ NMax = 80,
+ NClamp = 81,
+
+ Count
+};
+
+} // namespace GLSLLIB
+
+#endif  // #ifndef GLSLstd450_H
diff --git a/lib/SPIRV/libSPIRV/SPIRVDebug.h b/lib/SPIRV/libSPIRV/SPIRVDebug.h
index 4337c75..ba5dba9 100644
--- a/lib/SPIRV/libSPIRV/SPIRVDebug.h
+++ b/lib/SPIRV/libSPIRV/SPIRVDebug.h
@@ -79,9 +79,15 @@ void verifyRegularizationPass(llvm::Module &, const std::string &);
   }
 
 // Output stream for SPIRV debug information.
+#if 1
+inline spv_ostream &spvdbgs() {
+  return llvm::errs();
+}
+#else
 inline spv_ostream &spvdbgs() {
   return std::cerr;
 }
+#endif
 
 #else
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVEntry.cpp b/lib/SPIRV/libSPIRV/SPIRVEntry.cpp
index 2de4153..6b7d1a3 100644
--- a/lib/SPIRV/libSPIRV/SPIRVEntry.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVEntry.cpp
@@ -193,14 +193,15 @@ void SPIRVEntry::encodeAll(spv_ostream &O) const {
 void SPIRVEntry::encodeChildren(spv_ostream &O) const {}
 
 void SPIRVEntry::encodeWordCountOpCode(spv_ostream &O) const {
+  const Op enc_op = (OpCode == spv::internal::OpUndefValueInternal ? OpUndef : OpCode);
 #ifdef _SPIRV_SUPPORT_TEXT_FMT
   if (SPIRVUseTextFormat) {
-    getEncoder(O) << WordCount << OpCode;
+    getEncoder(O) << WordCount << enc_op;
     return;
   }
 #endif
   assert(WordCount < 65536 && "WordCount must fit into 16-bit value");
-  SPIRVWord WordCountOpCode = (WordCount << WordCountShift) | OpCode;
+  SPIRVWord WordCountOpCode = (WordCount << WordCountShift) | enc_op;
   getEncoder(O) << WordCountOpCode;
 }
 // Read words from SPIRV binary and create members for SPIRVEntry.
diff --git a/lib/SPIRV/libSPIRV/SPIRVEntry.h b/lib/SPIRV/libSPIRV/SPIRVEntry.h
index f03e777..324c198 100644
--- a/lib/SPIRV/libSPIRV/SPIRVEntry.h
+++ b/lib/SPIRV/libSPIRV/SPIRVEntry.h
@@ -330,7 +330,7 @@ public:
   bool isMemberDecorate() const { return OpCode == OpMemberDecorate; }
   bool isForward() const { return OpCode == internal::OpForward; }
   bool isLabel() const { return OpCode == OpLabel; }
-  bool isUndef() const { return OpCode == OpUndef; }
+  bool isUndef() const { return OpCode == OpUndef || OpCode == internal::OpUndefValueInternal; }
   bool isControlBarrier() const { return OpCode == OpControlBarrier; }
   bool isMemoryBarrier() const { return OpCode == OpMemoryBarrier; }
   bool isVariable() const { return OpCode == OpVariable; }
@@ -428,11 +428,13 @@ protected:
   bool canHaveMemberDecorates() const {
     return OpCode == OpTypeStruct || OpCode == internal::OpForward;
   }
+public:
   MemberDecorateMapType &getMemberDecorates() {
     assert(canHaveMemberDecorates());
     return MemberDecorates;
   }
 
+protected:
   void updateModuleVersion() const;
 
   SPIRVModule *Module;
@@ -990,16 +992,12 @@ private:
 #define _SPIRV_OP(x) typedef SPIRVEntryUnimplemented<Op##x> SPIRV##x;
 _SPIRV_OP(Nop)
 _SPIRV_OP(SourceContinued)
-_SPIRV_OP(TypeRuntimeArray)
 _SPIRV_OP(Image)
 _SPIRV_OP(ImageTexelPointer)
-_SPIRV_OP(ImageSampleDrefImplicitLod)
-_SPIRV_OP(ImageSampleDrefExplicitLod)
 _SPIRV_OP(ImageSampleProjImplicitLod)
 _SPIRV_OP(ImageSampleProjExplicitLod)
 _SPIRV_OP(ImageSampleProjDrefImplicitLod)
 _SPIRV_OP(ImageSampleProjDrefExplicitLod)
-_SPIRV_OP(ImageFetch)
 _SPIRV_OP(ImageGather)
 _SPIRV_OP(ImageDrefGather)
 _SPIRV_OP(QuantizeToF16)
@@ -1012,20 +1010,10 @@ _SPIRV_OP(UMulExtended)
 _SPIRV_OP(BitFieldInsert)
 _SPIRV_OP(BitFieldSExtract)
 _SPIRV_OP(BitFieldUExtract)
-_SPIRV_OP(DPdx)
-_SPIRV_OP(DPdy)
-_SPIRV_OP(Fwidth)
-_SPIRV_OP(DPdxFine)
-_SPIRV_OP(DPdyFine)
-_SPIRV_OP(FwidthFine)
-_SPIRV_OP(DPdxCoarse)
-_SPIRV_OP(DPdyCoarse)
-_SPIRV_OP(FwidthCoarse)
 _SPIRV_OP(EmitVertex)
 _SPIRV_OP(EndPrimitive)
 _SPIRV_OP(EmitStreamVertex)
 _SPIRV_OP(EndStreamPrimitive)
-_SPIRV_OP(Kill)
 _SPIRV_OP(ImageSparseSampleImplicitLod)
 _SPIRV_OP(ImageSparseSampleExplicitLod)
 _SPIRV_OP(ImageSparseSampleDrefImplicitLod)
diff --git a/lib/SPIRV/libSPIRV/SPIRVEnum.h b/lib/SPIRV/libSPIRV/SPIRVEnum.h
index 1cd7238..cbcbf12 100644
--- a/lib/SPIRV/libSPIRV/SPIRVEnum.h
+++ b/lib/SPIRV/libSPIRV/SPIRVEnum.h
@@ -78,6 +78,7 @@ enum SPIRVExtInstSetKind {
   SPIRVEIS_OpenCL,
   SPIRVEIS_Debug,
   SPIRVEIS_OpenCL_DebugInfo_100,
+  SPIRVEIS_GLSL,
   SPIRVEIS_Count,
 };
 
@@ -129,6 +130,7 @@ template <> inline void SPIRVMap<SPIRVExtInstSetKind, std::string>::init() {
   add(SPIRVEIS_OpenCL, "OpenCL.std");
   add(SPIRVEIS_Debug, "SPIRV.debug");
   add(SPIRVEIS_OpenCL_DebugInfo_100, "OpenCL.DebugInfo.100");
+  add(SPIRVEIS_GLSL, "GLSL.std.450");
 }
 typedef SPIRVMap<SPIRVExtInstSetKind, std::string> SPIRVBuiltinSetNameMap;
 
@@ -175,7 +177,6 @@ template <> inline void SPIRVMap<SPIRVCapabilityKind, SPIRVCapVec>::init() {
   ADD_VEC_INIT(CapabilityImageRect, {CapabilitySampledRect});
   ADD_VEC_INIT(CapabilitySampledRect, {CapabilityShader});
   ADD_VEC_INIT(CapabilityGenericPointer, {CapabilityAddresses});
-  ADD_VEC_INIT(CapabilityInt8, {CapabilityKernel});
   ADD_VEC_INIT(CapabilityInputAttachment, {CapabilityShader});
   ADD_VEC_INIT(CapabilitySparseResidency, {CapabilityShader});
   ADD_VEC_INIT(CapabilityMinLod, {CapabilityShader});
@@ -197,6 +198,7 @@ template <> inline void SPIRVMap<SPIRVCapabilityKind, SPIRVCapVec>::init() {
                {CapabilitySubgroupAvcMotionEstimationINTEL});
   ADD_VEC_INIT(CapabilitySubgroupAvcMotionEstimationChromaINTEL,
                {CapabilitySubgroupAvcMotionEstimationIntraINTEL});
+  ADD_VEC_INIT(CapabilityMultiView, {CapabilityShader});
 }
 
 template <> inline void SPIRVMap<SPIRVExecutionModelKind, SPIRVCapVec>::init() {
@@ -339,7 +341,9 @@ template <> inline void SPIRVMap<ImageOperandsMask, SPIRVCapVec>::init() {
 
 template <> inline void SPIRVMap<Decoration, SPIRVCapVec>::init() {
   ADD_VEC_INIT(DecorationRelaxedPrecision, {CapabilityShader});
+#if 0 // both Kernel and Shader are valid, but either will already be specified
   ADD_VEC_INIT(DecorationSpecId, {CapabilityKernel});
+#endif
   ADD_VEC_INIT(DecorationBlock, {CapabilityShader});
   ADD_VEC_INIT(DecorationBufferBlock, {CapabilityShader});
   ADD_VEC_INIT(DecorationRowMajor, {CapabilityMatrix});
@@ -470,12 +474,18 @@ template <> inline void SPIRVMap<BuiltIn, SPIRVCapVec>::init() {
   ADD_VEC_INIT(BuiltInEnqueuedWorkgroupSize, {CapabilityKernel});
   ADD_VEC_INIT(BuiltInGlobalOffset, {CapabilityKernel});
   ADD_VEC_INIT(BuiltInGlobalLinearId, {CapabilityKernel});
+#if 0 // both Kernel and Shader
   ADD_VEC_INIT(BuiltInSubgroupSize, {CapabilityKernel});
+#endif
   ADD_VEC_INIT(BuiltInSubgroupMaxSize, {CapabilityKernel});
+#if 0 // both Kernel and Shader
   ADD_VEC_INIT(BuiltInNumSubgroups, {CapabilityKernel});
+#endif
   ADD_VEC_INIT(BuiltInNumEnqueuedSubgroups, {CapabilityKernel});
+#if 0 // both Kernel and Shader
   ADD_VEC_INIT(BuiltInSubgroupId, {CapabilityKernel});
   ADD_VEC_INIT(BuiltInSubgroupLocalInvocationId, {CapabilityKernel});
+#endif
   ADD_VEC_INIT(BuiltInSubgroupEqMask, {CapabilityGroupNonUniformBallot});
   ADD_VEC_INIT(BuiltInSubgroupGeMask, {CapabilityGroupNonUniformBallot});
   ADD_VEC_INIT(BuiltInSubgroupGtMask, {CapabilityGroupNonUniformBallot});
@@ -483,6 +493,7 @@ template <> inline void SPIRVMap<BuiltIn, SPIRVCapVec>::init() {
   ADD_VEC_INIT(BuiltInSubgroupLtMask, {CapabilityGroupNonUniformBallot});
   ADD_VEC_INIT(BuiltInVertexIndex, {CapabilityShader});
   ADD_VEC_INIT(BuiltInInstanceIndex, {CapabilityShader});
+  ADD_VEC_INIT(BuiltInViewIndex, {CapabilityMultiView});
 }
 
 template <> inline void SPIRVMap<MemorySemanticsMask, SPIRVCapVec>::init() {
diff --git a/lib/SPIRV/libSPIRV/SPIRVExtInst.h b/lib/SPIRV/libSPIRV/SPIRVExtInst.h
index 89581f4..f2575b5 100644
--- a/lib/SPIRV/libSPIRV/SPIRVExtInst.h
+++ b/lib/SPIRV/libSPIRV/SPIRVExtInst.h
@@ -42,6 +42,7 @@
 
 #include "OpenCL.std.h"
 #include "SPIRV.debug.h"
+#include "GLSL.std.450.h"
 #include "SPIRVEnum.h"
 #include "SPIRVUtil.h"
 
@@ -258,6 +259,92 @@ template <> inline void SPIRVMap<SPIRVDebugExtOpKind, std::string>::init() {
 }
 SPIRV_DEF_NAMEMAP(SPIRVDebugExtOpKind, SPIRVDebugExtOpMap)
 
+typedef GLSLLIB::GLSLstd450 GLSLExtOpKind;
+template <> inline void SPIRVMap<GLSLExtOpKind, std::string>::init() {
+  add(GLSLLIB::Acos, "acos");
+  add(GLSLLIB::Acosh, "acosh");
+  add(GLSLLIB::Asin, "asin");
+  add(GLSLLIB::Asinh, "asinh");
+  add(GLSLLIB::Atan, "atan");
+  add(GLSLLIB::Atan2, "atan2");
+  add(GLSLLIB::Atanh, "atanh");
+  add(GLSLLIB::Ceil, "ceil");
+  add(GLSLLIB::Cos, "cos");
+  add(GLSLLIB::Cosh, "cosh");
+  add(GLSLLIB::Cross, "cross");
+  add(GLSLLIB::Degrees, "degrees");
+  add(GLSLLIB::Determinant, "determinant");
+  add(GLSLLIB::Distance, "distance");
+  add(GLSLLIB::Exp, "exp");
+  add(GLSLLIB::Exp2, "exp2");
+  add(GLSLLIB::FAbs, "fabs");
+  add(GLSLLIB::FaceForward, "face_forward");
+  add(GLSLLIB::FClamp, "fclamp");
+  add(GLSLLIB::FindILsb, "find_ilsb");
+  add(GLSLLIB::FindSMsb, "find_smsb");
+  add(GLSLLIB::FindUMsb, "find_umsb");
+  add(GLSLLIB::Floor, "floor");
+  add(GLSLLIB::Fma, "fma");
+  add(GLSLLIB::FMax, "fmax");
+  add(GLSLLIB::FMin, "fmin");
+  add(GLSLLIB::FMix, "fmix");
+  add(GLSLLIB::Fract, "fract");
+  add(GLSLLIB::Frexp, "frexp");
+  add(GLSLLIB::FrexpStruct, "frexp_struct");
+  add(GLSLLIB::FSign, "fsign");
+  add(GLSLLIB::IMix, "imix");
+  add(GLSLLIB::InterpolateAtCentroid, "interpolate_at_centroid");
+  add(GLSLLIB::InterpolateAtOffset, "interpolate_at_offset");
+  add(GLSLLIB::InterpolateAtSample, "interpolate_at_sample");
+  add(GLSLLIB::InverseSqrt, "rsqrt");
+  add(GLSLLIB::Ldexp, "ldexp");
+  add(GLSLLIB::Length, "length");
+  add(GLSLLIB::Log, "log");
+  add(GLSLLIB::Log2, "log2");
+  add(GLSLLIB::MatrixInverse, "matrix_inverse");
+  add(GLSLLIB::Modf, "modf");
+  add(GLSLLIB::ModfStruct, "modf_struct");
+  add(GLSLLIB::NClamp, "nclamp");
+  add(GLSLLIB::NMax, "nmax");
+  add(GLSLLIB::NMin, "nmin");
+  add(GLSLLIB::Normalize, "normalize");
+  add(GLSLLIB::PackDouble2x32, "pack_double_2x32");
+  add(GLSLLIB::PackHalf2x16, "pack_half_2x16");
+  add(GLSLLIB::PackSnorm2x16, "pack_snorm_2x16");
+  add(GLSLLIB::PackSnorm4x8, "pack_snorm4x8");
+  add(GLSLLIB::PackUnorm2x16, "pack_unorm_2x16");
+  add(GLSLLIB::PackUnorm4x8, "pack_unorm_4x8");
+  add(GLSLLIB::Pow, "pow");
+  add(GLSLLIB::Radians, "radians");
+  add(GLSLLIB::Reflect, "reflect");
+  add(GLSLLIB::Refract, "refract");
+  add(GLSLLIB::Round, "round");
+  add(GLSLLIB::RoundEven, "round_even");
+  add(GLSLLIB::SAbs, "s_abs");
+  add(GLSLLIB::SClamp, "s_clamp");
+  add(GLSLLIB::Sin, "sin");
+  add(GLSLLIB::Sinh, "sinh");
+  add(GLSLLIB::SMax, "s_max");
+  add(GLSLLIB::SMin, "s_min");
+  add(GLSLLIB::SmoothStep, "smoothstep");
+  add(GLSLLIB::Sqrt, "sqrt");
+  add(GLSLLIB::SSign, "s_sign");
+  add(GLSLLIB::Step, "step");
+  add(GLSLLIB::Tan, "tan");
+  add(GLSLLIB::Tanh, "tanh");
+  add(GLSLLIB::Trunc, "trunc");
+  add(GLSLLIB::UClamp, "u_clamp");
+  add(GLSLLIB::UMax, "u_max");
+  add(GLSLLIB::UMin, "u_min");
+  add(GLSLLIB::UnpackDouble2x32, "unpack_double_2x32");
+  add(GLSLLIB::UnpackHalf2x16, "unpack_half_2x16");
+  add(GLSLLIB::UnpackSnorm2x16, "unpack_snorm_2x16");
+  add(GLSLLIB::UnpackSnorm4x8, "unpack_snorm_4x8");
+  add(GLSLLIB::UnpackUnorm2x16, "unpack_unorm_2x16");
+  add(GLSLLIB::UnpackUnorm4x8, "unpack_unorm_4x8");
+}
+SPIRV_DEF_NAMEMAP(GLSLExtOpKind, GLSLExtOpMap)
+
 } // namespace SPIRV
 
 #endif // SPIRV_LIBSPIRV_SPIRVEXTINST_H
diff --git a/lib/SPIRV/libSPIRV/SPIRVInstruction.cpp b/lib/SPIRV/libSPIRV/SPIRVInstruction.cpp
index 8e4753d..81be5f8 100644
--- a/lib/SPIRV/libSPIRV/SPIRVInstruction.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVInstruction.cpp
@@ -44,6 +44,8 @@
 #include <unordered_set>
 
 namespace SPIRV {
+std::vector<Capability> SPIRVImageInstBase::image_caps;
+std::vector<Capability> SPIRVImageQueryInstBase::image_query_caps;
 
 // Complete constructor for instruction with type and id
 SPIRVInstruction::SPIRVInstruction(unsigned TheWordCount, Op TheOC,
diff --git a/lib/SPIRV/libSPIRV/SPIRVInstruction.h b/lib/SPIRV/libSPIRV/SPIRVInstruction.h
index 74d469f..5f08944 100644
--- a/lib/SPIRV/libSPIRV/SPIRVInstruction.h
+++ b/lib/SPIRV/libSPIRV/SPIRVInstruction.h
@@ -154,6 +154,20 @@ public:
     return hasDecorate(DecorationSaturatedConversion) ||
            OpCode == OpSatConvertSToU || OpCode == OpSatConvertUToS;
   }
+  bool isTerminationInstruction() const {
+    switch (OpCode) {
+      case OpBranch:
+      case OpBranchConditional:
+      case OpSwitch:
+      case OpReturn:
+      case OpReturnValue:
+      case OpKill:
+      case OpUnreachable:
+        return true;
+      default: break;
+    }
+    return false;
+  }
 
   SPIRVBasicBlock *getBasicBlock() const { return BB; }
 
@@ -294,8 +308,11 @@ public:
   /// Get operand as value.
   /// If the operand is a literal, return it as a uint32 constant.
   SPIRVValue *getOpValue(int I) {
-    return isOperandLiteral(I) ? Module->getLiteralAsConstant(Ops[I])
-                               : getValue(Ops[I]);
+    return isOperandLiteral(I)
+               ? Module->getLiteralAsConstant(
+                     Ops[I], Module->getSourceLanguage(nullptr) ==
+                                 spv::SourceLanguageGLSL)
+               : getValue(Ops[I]);
   }
 
   std::vector<SPIRVValue *> getOperands() override {
@@ -703,6 +720,7 @@ protected:
 
 typedef SPIRVInstNoOperand<OpReturn> SPIRVReturn;
 typedef SPIRVInstNoOperand<OpUnreachable> SPIRVUnreachable;
+typedef SPIRVInstNoOperand<OpKill> SPIRVKill;
 
 class SPIRVReturnValue : public SPIRVInstruction {
 public:
@@ -967,6 +985,22 @@ _SPIRV_OP(Ordered)
 _SPIRV_OP(Unordered)
 #undef _SPIRV_OP
 
+class SPIRVUndefValueInternal : public SPIRVInstruction {
+public:
+  static const Op OC = internal::OpUndefValueInternal;
+  static const SPIRVWord FixedWordCount = 3;
+
+  SPIRVUndefValueInternal(SPIRVType *TheType, SPIRVId TheId, SPIRVBasicBlock *BB)
+      : SPIRVInstruction(3, OC, TheType, TheId, BB) {
+    validate();
+    assert(BB && "Invalid BB");
+  }
+  // Incomplete constructor
+	SPIRVUndefValueInternal() { validate(); }
+
+  _SPIRV_DEF_ENCDEC2(Type, Id)
+};
+
 class SPIRVSelect : public SPIRVInstruction {
 public:
   // Complete constructor
@@ -1564,6 +1598,38 @@ _SPIRV_OP(BitCount)
 _SPIRV_OP(BitReverse)
 #undef _SPIRV_OP
 
+template <Op OC_> class SPIRVDerivativeInst : public SPIRVInstruction {
+public:
+  const static Op OC = OC_;
+  // Complete constructor
+  SPIRVDerivativeInst(SPIRVId TheId, SPIRVValue *PVal, SPIRVBasicBlock *TheBB)
+      : SPIRVInstruction(4, OC, PVal->getType(), TheId, TheBB),
+        PId(PVal->getId()) {
+    validate();
+    assert(TheBB && "Invalid BB");
+  }
+  // Incomplete constructor
+  SPIRVDerivativeInst() : SPIRVInstruction(OC), PId(SPIRVID_INVALID) {}
+
+  _SPIRV_DEF_ENCDEC3(Type, Id, PId)
+
+protected:
+  void validate() const override { SPIRVInstruction::validate(); }
+  SPIRVId PId;
+};
+
+#define _SPIRV_OP(x) typedef SPIRVDerivativeInst<Op##x> SPIRV##x;
+_SPIRV_OP(DPdx)
+_SPIRV_OP(DPdy)
+_SPIRV_OP(Fwidth)
+_SPIRV_OP(DPdxFine)
+_SPIRV_OP(DPdyFine)
+_SPIRV_OP(FwidthFine)
+_SPIRV_OP(DPdxCoarse)
+_SPIRV_OP(DPdyCoarse)
+_SPIRV_OP(FwidthCoarse)
+#undef _SPIRV_OP
+
 class SPIRVAccessChainBase : public SPIRVInstTemplateBase {
 public:
   SPIRVValue *getBase() { return this->getValue(this->Ops[0]); }
@@ -1765,7 +1831,7 @@ public:
     assert(Module && "Invalid module");
     ExtSetKind = Module->getBuiltinSet(ExtSetId);
     assert((ExtSetKind == SPIRVEIS_OpenCL || ExtSetKind == SPIRVEIS_Debug ||
-            ExtSetKind == SPIRVEIS_OpenCL_DebugInfo_100) &&
+            ExtSetKind == SPIRVEIS_OpenCL_DebugInfo_100 || ExtSetKind == SPIRVEIS_GLSL) &&
            "not supported");
   }
   void encode(spv_ostream &O) const override {
@@ -1778,6 +1844,9 @@ public:
     case SPIRVEIS_OpenCL_DebugInfo_100:
       getEncoder(O) << ExtOpDebug;
       break;
+    case SPIRVEIS_GLSL:
+      getEncoder(O) << ExtOpGLSL;
+      break;
     default:
       assert(0 && "not supported");
       getEncoder(O) << ExtOp;
@@ -1795,6 +1864,9 @@ public:
     case SPIRVEIS_OpenCL_DebugInfo_100:
       getDecoder(I) >> ExtOpDebug;
       break;
+    case SPIRVEIS_GLSL:
+      getDecoder(I) >> ExtOpGLSL;
+      break;
     default:
       assert(0 && "not supported");
       getDecoder(I) >> ExtOp;
@@ -1806,27 +1878,35 @@ public:
     validateBuiltin(ExtSetId, ExtOp);
   }
   bool isOperandLiteral(unsigned Index) const override {
-    assert(ExtSetKind == SPIRVEIS_OpenCL &&
+    assert((ExtSetKind == SPIRVEIS_OpenCL || ExtSetKind == SPIRVEIS_GLSL) &&
            "Unsupported extended instruction set");
-    auto EOC = static_cast<OCLExtOpKind>(ExtOp);
-    switch (EOC) {
-    default:
-      return false;
-    case OpenCLLIB::Vloadn:
-    case OpenCLLIB::Vload_halfn:
-    case OpenCLLIB::Vloada_halfn:
-      return Index == 2;
-    case OpenCLLIB::Vstore_half_r:
-    case OpenCLLIB::Vstore_halfn_r:
-    case OpenCLLIB::Vstorea_halfn_r:
-      return Index == 3;
+    if (ExtSetKind == SPIRVEIS_OpenCL) {
+      auto EOC = static_cast<OCLExtOpKind>(ExtOp);
+      switch (EOC) {
+      default:
+        return false;
+      case OpenCLLIB::Vloadn:
+      case OpenCLLIB::Vload_halfn:
+      case OpenCLLIB::Vloada_halfn:
+        return Index == 2;
+      case OpenCLLIB::Vstore_half_r:
+      case OpenCLLIB::Vstore_halfn_r:
+      case OpenCLLIB::Vstorea_halfn_r:
+        return Index == 3;
+      }
+    } else {
+      auto EGLSL = static_cast<GLSLExtOpKind>(ExtOp);
+      switch (EGLSL) { // TODO: necessary?
+      default:
+        return false;
+      }
     }
   }
   std::vector<SPIRVValue *> getArgValues() {
     std::vector<SPIRVValue *> VArgs;
     for (size_t I = 0; I < Args.size(); ++I) {
       if (isOperandLiteral(I))
-        VArgs.push_back(Module->getLiteralAsConstant(Args[I]));
+        VArgs.push_back(Module->getLiteralAsConstant(Args[I], false));
       else
         VArgs.push_back(getValue(Args[I]));
     }
@@ -1847,6 +1927,7 @@ protected:
     SPIRVWord ExtOp;
     OCLExtOpKind ExtOpOCL;
     SPIRVDebugExtOpKind ExtOpDebug;
+    GLSLExtOpKind ExtOpGLSL;
   };
 };
 
@@ -1879,6 +1960,7 @@ protected:
   _SPIRV_DEF_ENCDEC3(Type, Id, Constituents)
   void validate() const override {
     SPIRVInstruction::validate();
+#if 0 // this doesn't work when no entry for "getId()/Id" exists yet
     switch (getValueType(this->getId())->getOpCode()) {
     case OpTypeVector:
       assert(getConstituents().size() > 1 &&
@@ -1890,6 +1972,10 @@ protected:
     default:
       assert(false && "Invalid type");
     }
+#else // -> use type directly instead
+    assert(Type->isTypeArray() || Type->isTypeStruct() || Type->isTypeVector());
+    assert(!Type->isTypeVector() || (Type->isTypeVector() && getConstituents().size() > 1));
+#endif
   }
   std::vector<SPIRVId> Constituents;
 };
@@ -2041,10 +2127,12 @@ protected:
   }
 
   void validate() const override {
+#if 0 // OpCopyMemory doesn't have an ID!
     assert((getValueType(Id) == getValueType(Source)) && "Inconsistent type");
     assert(getValueType(Id)->isTypePointer() && "Invalid type");
     assert(!(getValueType(Id)->getPointerElementType()->isTypeVoid()) &&
            "Invalid type");
+#endif
     SPIRVInstruction::validate();
   }
 
@@ -2688,8 +2776,27 @@ public:
     // Besides, OpAtomicCompareExchangeWeak, OpAtomicFlagTestAndSet and
     // OpAtomicFlagClear instructions require the "kernel" capability. But this
     // capability should be added by setting the OpenCL memory model.
-    if (hasType() && getType()->isTypeInt(64))
-      return {CapabilityInt64Atomics};
+    if (hasType()) {
+      if (getType()->isTypeInt(64)) {
+        return {CapabilityInt64Atomics};
+      } else if (OpCode == spv::OpAtomicFAddEXT) {
+        if (getType()->isTypeFloat(32)) {
+          return {CapabilityAtomicFloat32AddEXT};
+        } else if (getType()->isTypeFloat(64)) {
+          return {CapabilityAtomicFloat64AddEXT};
+        }
+      }
+    }
+    return {};
+  }
+
+  llvm::Optional<ExtensionID> getRequiredExtension() const override {
+    if (auto parent_ext = SPIRVInstTemplateBase::getRequiredExtension(); parent_ext.hasValue()) {
+      return parent_ext.getValue();
+    }
+    if (hasType() && (getType()->isTypeFloat(32) || getType()->isTypeFloat(64))) {
+      return ExtensionID::SPV_EXT_shader_atomic_float_add;
+    }
     return {};
   }
 
@@ -2782,9 +2889,32 @@ _SPIRV_OP(AtomicFMaxEXT, AtomicFMinMaxEXTBase, true, 7)
 #undef _SPIRV_OP
 
 class SPIRVImageInstBase : public SPIRVInstTemplateBase {
+protected:
+  // kernel and shader image caps differ, so this needs to be handled externally
+  static SPIRVCapVec image_caps;
+
 public:
-  SPIRVCapVec getRequiredCapability() const override {
-    return getVec(CapabilityImageBasic);
+  SPIRVCapVec getRequiredCapability() const override { return image_caps; }
+  static void addCap(const Capability cap) {
+    image_caps.emplace_back(cap);
+    std::sort(image_caps.begin(), image_caps.end());
+    image_caps.erase(std::unique(image_caps.begin(), image_caps.end()),
+                     image_caps.end());
+  }
+};
+
+class SPIRVImageQueryInstBase : public SPIRVInstTemplateBase {
+protected:
+  static SPIRVCapVec image_query_caps;
+
+public:
+  SPIRVCapVec getRequiredCapability() const override { return image_query_caps; }
+  static void addCap(const Capability cap) {
+    image_query_caps.emplace_back(cap);
+    std::sort(image_query_caps.begin(), image_query_caps.end());
+    image_query_caps.erase(
+        std::unique(image_query_caps.begin(), image_query_caps.end()),
+        image_query_caps.end());
   }
 };
 
@@ -2794,8 +2924,17 @@ public:
 _SPIRV_OP(SampledImage, true, 5)
 _SPIRV_OP(ImageSampleImplicitLod, true, 5, true)
 _SPIRV_OP(ImageSampleExplicitLod, true, 7, true, 2)
+_SPIRV_OP(ImageSampleDrefImplicitLod, true, 6, true)
+_SPIRV_OP(ImageSampleDrefExplicitLod, true, 8, true)
+_SPIRV_OP(ImageFetch, true, 5, true)
 _SPIRV_OP(ImageRead, true, 5, true, 2)
 _SPIRV_OP(ImageWrite, false, 4, true, 3)
+#undef _SPIRV_OP
+
+#define _SPIRV_OP(x, ...)                                                      \
+  typedef SPIRVInstTemplate<SPIRVImageQueryInstBase, Op##x, __VA_ARGS__>       \
+      SPIRV##x;
+// ImageQuery instructions
 _SPIRV_OP(ImageQueryFormat, true, 4)
 _SPIRV_OP(ImageQueryOrder, true, 4)
 _SPIRV_OP(ImageQuerySizeLod, true, 5)
diff --git a/lib/SPIRV/libSPIRV/SPIRVModule.cpp b/lib/SPIRV/libSPIRV/SPIRVModule.cpp
index 5b46a3a..699197c 100644
--- a/lib/SPIRV/libSPIRV/SPIRVModule.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVModule.cpp
@@ -51,11 +51,22 @@
 #include "SPIRVValue.h"
 
 #include "llvm/ADT/APInt.h"
+#include "llvm/Support/ErrorHandling.h"
 
 #include <set>
 #include <unordered_map>
 #include <unordered_set>
 
+namespace std {
+template <>
+struct hash<pair<SPIRV::SPIRVType *, uint32_t>> : public hash<size_t> {
+  size_t operator()(const pair<SPIRV::SPIRVType *, uint32_t> &value) const
+      noexcept {
+    return (hash<uint32_t>()(value.second) ^ hash<void *>()(value.first));
+  }
+};
+}
+
 namespace SPIRV {
 
 SPIRVModule::SPIRVModule()
@@ -71,10 +82,8 @@ public:
         GeneratorId(SPIRVGEN_KhronosLLVMSPIRVTranslator), GeneratorVer(0),
         InstSchema(SPIRVISCH_Default), SrcLang(SourceLanguageOpenCL_C),
         SrcLangVer(102000) {
-    AddrModel = sizeof(size_t) == 32 ? AddressingModelPhysical32
-                                     : AddressingModelPhysical64;
-    // OpenCL memory model requires Kernel capability
-    setMemoryModel(MemoryModelOpenCL);
+    AddrModel = sizeof(size_t) == 4 ? AddressingModelPhysical32
+                                    : AddressingModelPhysical64;
   }
 
   SPIRVModuleImpl(const SPIRV::TranslatorOpts &Opts) : SPIRVModuleImpl() {
@@ -127,7 +136,9 @@ public:
   std::vector<SPIRVType *>
   getValueTypes(const std::vector<SPIRVId> &) const override;
   SPIRVMemoryModelKind getMemoryModel() const override { return MemoryModel; }
-  SPIRVConstant *getLiteralAsConstant(unsigned Literal) override;
+  SPIRVConstant *getLiteralAsConstant(unsigned Literal, bool is_signed) override;
+  SPIRVConstant *getLiteralAsConstant(float Literal) override;
+  SPIRVConstant *getLiteralAsConstant(double Literal) override;
   unsigned getNumEntryPoints(SPIRVExecutionModelKind EM) const override {
     auto Loc = EntryPointVec.find(EM);
     if (Loc == EntryPointVec.end())
@@ -142,6 +153,10 @@ public:
     assert(I < Loc->second.size());
     return get<SPIRVFunction>(Loc->second[I]);
   }
+  const std::map<SPIRVId, std::vector<SPIRVVariable *>> &
+  getEntryPointIO() const override {
+    return EntryPointIO;
+  }
   unsigned getNumFunctions() const override { return FuncVec.size(); }
   unsigned getNumVariables() const override { return VariableVec.size(); }
   SourceLanguage getSourceLanguage(SPIRVWord *Ver = nullptr) const override {
@@ -216,6 +231,7 @@ public:
                          const std::vector<SPIRVEntry *> &Targets) override;
   void addEntryPoint(SPIRVExecutionModelKind ExecModel,
                      SPIRVId EntryPoint) override;
+  void addEntryPointIO(SPIRVId EntryPoint, SPIRVVariable *var) override;
   SPIRVForward *addForward(SPIRVType *Ty) override;
   SPIRVForward *addForward(SPIRVId, SPIRVType *Ty) override;
   SPIRVFunction *addFunction(SPIRVFunction *) override;
@@ -226,11 +242,12 @@ public:
   // Type creation functions
   template <class T> T *addType(T *Ty);
   SPIRVTypeArray *addArrayType(SPIRVType *, SPIRVConstant *) override;
+  SPIRVTypeRuntimeArray *addRuntimeArrayType(SPIRVType *) override;
   SPIRVTypeBool *addBoolType() override;
   SPIRVTypeFloat *addFloatType(unsigned BitWidth) override;
   SPIRVTypeFunction *addFunctionType(SPIRVType *,
                                      const std::vector<SPIRVType *> &) override;
-  SPIRVTypeInt *addIntegerType(unsigned BitWidth) override;
+  SPIRVTypeInt *addIntegerType(unsigned BitWidth, bool is_signed) override;
   SPIRVTypeOpaque *addOpaqueType(const std::string &) override;
   SPIRVTypePointer *addPointerType(SPIRVStorageClassKind, SPIRVType *) override;
   SPIRVTypeImage *addImageType(SPIRVType *,
@@ -280,6 +297,7 @@ public:
   SPIRVValue *addIntegerConstant(SPIRVTypeInt *, uint64_t) override;
   SPIRVValue *addNullConstant(SPIRVType *) override;
   SPIRVValue *addUndef(SPIRVType *TheType) override;
+  SPIRVValue *addUndefInst(SPIRVType *TheType, SPIRVBasicBlock *) override;
   SPIRVValue *addSamplerConstant(SPIRVType *TheType, SPIRVWord AddrMode,
                                  SPIRVWord ParametricMode,
                                  SPIRVWord FilterMode) override;
@@ -287,10 +305,19 @@ public:
                                      SPIRVWord PacketAlign,
                                      SPIRVWord Capacity) override;
 
+  // Specialization constants creation functions
+  SPIRVValue *addSpecDoubleConstant(SPIRVTypeFloat *, double) override;
+  SPIRVValue *addSpecFloatConstant(SPIRVTypeFloat *, float) override;
+  SPIRVValue *addSpecIntegerConstant(SPIRVTypeInt *, uint64_t) override;
+  SPIRVValue *addSpecCompositeConstant(SPIRVType *, const std::vector<SPIRVValue *> &) override;
+
   // Instruction creation functions
   SPIRVInstruction *addPtrAccessChainInst(SPIRVType *, SPIRVValue *,
                                           std::vector<SPIRVValue *>,
                                           SPIRVBasicBlock *, bool) override;
+  SPIRVInstruction *addAccessChainInst(SPIRVType *, SPIRVValue *,
+                                       std::vector<SPIRVValue *>,
+                                       SPIRVBasicBlock *, bool) override;
   SPIRVInstruction *addAsyncGroupCopy(SPIRVValue *Scope, SPIRVValue *Dest,
                                       SPIRVValue *Src, SPIRVValue *NumElems,
                                       SPIRVValue *Stride, SPIRVValue *Event,
@@ -434,10 +461,21 @@ public:
   SPIRVInstruction *addVectorInsertDynamicInst(SPIRVValue *, SPIRVValue *,
                                                SPIRVValue *,
                                                SPIRVBasicBlock *) override;
-  SPIRVInstruction *addFPGARegINTELInst(SPIRVType *, SPIRVValue *,
-                                        SPIRVBasicBlock *) override;
   SPIRVInstruction *addSampledImageInst(SPIRVType *, SPIRVValue *, SPIRVValue *,
                                         SPIRVBasicBlock *) override;
+
+  // GLSL/shader functions
+  SPIRVInstruction *addKillInst(SPIRVBasicBlock *) override;
+  SPIRVInstruction *addDerivativeInst(Op op, SPIRVValue *p,
+                                      SPIRVBasicBlock *BB) override;
+  SPIRVInstruction *addBitCountInst(SPIRVType *ret_type, SPIRVValue *p,
+                                    SPIRVBasicBlock *BB) override;
+  SPIRVInstruction *
+  addBitReverseInst(SPIRVType *ret_type, SPIRVValue *p, SPIRVBasicBlock *BB) override;
+
+  // other ext functions
+  SPIRVInstruction *addFPGARegINTELInst(SPIRVType *, SPIRVValue *,
+                                        SPIRVBasicBlock *) override;
   template <typename AliasingInstType>
   SPIRVEntry *getOrAddMemAliasingINTELInst(std::vector<SPIRVId> Args,
                                            llvm::MDNode *MD);
@@ -519,11 +557,40 @@ private:
   SPIRVAsmVector AsmVec;
   SPIRVExecModelIdSetMap EntryPointSet;
   SPIRVExecModelIdVecMap EntryPointVec;
+  std::map<SPIRVId, std::vector<SPIRVVariable *>> EntryPointIO;
   SPIRVStringMap StrMap;
   SPIRVCapMap CapMap;
   SPIRVUnknownStructFieldMap UnknownStructFieldMap;
-  std::map<unsigned, SPIRVTypeInt *> IntTypeMap;
-  std::map<unsigned, SPIRVConstant *> LiteralMap;
+  std::map<uint32_t, SPIRVTypeInt *> IntTypeMap;
+  std::map<uint32_t, SPIRVTypeInt *> SignedIntTypeMap;
+  std::map<uint32_t, SPIRVConstant *> LiteralMap;
+  std::map<uint32_t, SPIRVConstant *> SignedLiteralMap;
+  std::map<float, SPIRVConstant *> FloatLiteralMap;
+  std::map<double, SPIRVConstant *> DoubleLiteralMap;
+  std::map<uint32_t, SPIRVTypeFloat *> FloatTypeMap;
+  std::map<std::pair<SPIRVType *, uint32_t>, SPIRVTypeVector *>
+      VectorTypeMap;
+  std::map<std::pair<SPIRVType *, uint32_t>, SPIRVTypePointer *>
+      PointerTypeMap;
+  std::map<SPIRVTypeImage *, SPIRVTypeSampledImage *>
+      SampledImageTypeMap;
+
+  struct image_type_info {
+    // -> info
+    SPIRVType *sampled_type{nullptr};
+    SPIRVTypeImageDescriptor desc;
+    SPIRVAccessQualifierKind access{
+        SPIRVAccessQualifierKind::AccessQualifierNone};
+
+    // -> created type
+    SPIRVTypeImage *image_type{nullptr};
+  };
+
+  SPIRVTypeVoid *VoidType{nullptr};
+  SPIRVTypeBool *BoolType{nullptr};
+  SPIRVTypeSampler *SamplerType{nullptr};
+
+  std::vector<image_type_info> ImageTypeMap;
   std::vector<SPIRVExtInst *> DebugInstVec;
   std::vector<SPIRVModuleProcessed *> ModuleProcessedVec;
   SPIRVAliasInstMDVec AliasInstMDVec;
@@ -615,13 +682,46 @@ void SPIRVModuleImpl::addCapabilityInternal(SPIRVCapabilityKind Cap) {
   }
 }
 
-SPIRVConstant *SPIRVModuleImpl::getLiteralAsConstant(unsigned Literal) {
-  auto Loc = LiteralMap.find(Literal);
-  if (Loc != LiteralMap.end())
-    return Loc->second;
-  auto Ty = addIntegerType(32);
+SPIRVConstant *SPIRVModuleImpl::getLiteralAsConstant(unsigned Literal,
+                                                     bool is_signed) {
+  if (!is_signed) {
+    auto Loc = LiteralMap.find(Literal);
+    if (Loc != LiteralMap.end())
+      return Loc->second;
+  } else {
+    auto Loc = SignedLiteralMap.find(Literal);
+    if (Loc != SignedLiteralMap.end())
+      return Loc->second;
+  }
+  auto Ty = addIntegerType(32, is_signed);
   auto V = new SPIRVConstant(this, Ty, getId(), static_cast<uint64_t>(Literal));
-  LiteralMap[Literal] = V;
+  if (!is_signed) {
+    LiteralMap[Literal] = V;
+  } else {
+    SignedLiteralMap[Literal] = V;
+  }
+  addConstant(V);
+  return V;
+}
+
+SPIRVConstant *SPIRVModuleImpl::getLiteralAsConstant(float Literal) {
+  auto Loc = FloatLiteralMap.find(Literal);
+  if (Loc != FloatLiteralMap.end())
+    return Loc->second;
+  auto Ty = addFloatType(32);
+  auto V = new SPIRVConstant(this, Ty, getId(), Literal);
+  FloatLiteralMap[Literal] = V;
+  addConstant(V);
+  return V;
+}
+
+SPIRVConstant *SPIRVModuleImpl::getLiteralAsConstant(double Literal) {
+  auto Loc = DoubleLiteralMap.find(Literal);
+  if (Loc != DoubleLiteralMap.end())
+    return Loc->second;
+  auto Ty = addFloatType(64);
+  auto V = new SPIRVConstant(this, Ty, getId(), Literal);
+  DoubleLiteralMap[Literal] = V;
   addConstant(V);
   return V;
 }
@@ -828,7 +928,12 @@ template <class T> T *SPIRVModuleImpl::addType(T *Ty) {
 }
 
 SPIRVTypeVoid *SPIRVModuleImpl::addVoidType() {
-  return addType(new SPIRVTypeVoid(this, getId()));
+  // only ever create one void type
+  if (VoidType != nullptr) {
+    return VoidType;
+  }
+  VoidType = new SPIRVTypeVoid(this, getId());
+  return addType(VoidType);
 }
 
 SPIRVTypeArray *SPIRVModuleImpl::addArrayType(SPIRVType *ElementType,
@@ -836,29 +941,58 @@ SPIRVTypeArray *SPIRVModuleImpl::addArrayType(SPIRVType *ElementType,
   return addType(new SPIRVTypeArray(this, getId(), ElementType, Length));
 }
 
+SPIRVTypeRuntimeArray *
+SPIRVModuleImpl::addRuntimeArrayType(SPIRVType *ElementType) {
+  return addType(new SPIRVTypeRuntimeArray(this, getId(), ElementType));
+}
+
 SPIRVTypeBool *SPIRVModuleImpl::addBoolType() {
-  return addType(new SPIRVTypeBool(this, getId()));
+  // only ever create one bool type
+  if (BoolType != nullptr) {
+    return BoolType;
+  }
+  BoolType = new SPIRVTypeBool(this, getId());
+  return addType(BoolType);
 }
 
-SPIRVTypeInt *SPIRVModuleImpl::addIntegerType(unsigned BitWidth) {
-  auto Loc = IntTypeMap.find(BitWidth);
-  if (Loc != IntTypeMap.end())
-    return Loc->second;
-  auto Ty = new SPIRVTypeInt(this, getId(), BitWidth, false);
-  IntTypeMap[BitWidth] = Ty;
+SPIRVTypeInt *SPIRVModuleImpl::addIntegerType(unsigned BitWidth, bool is_signed) {
+  if (!is_signed) {
+    auto Loc = IntTypeMap.find(BitWidth);
+    if (Loc != IntTypeMap.end())
+      return Loc->second;
+  } else {
+    auto Loc = SignedIntTypeMap.find(BitWidth);
+    if (Loc != SignedIntTypeMap.end())
+      return Loc->second;
+  }
+  auto Ty = new SPIRVTypeInt(this, getId(), BitWidth, is_signed);
+  if (!is_signed) {
+    IntTypeMap[BitWidth] = Ty;
+  } else {
+    SignedIntTypeMap[BitWidth] = Ty;
+  }
   return addType(Ty);
 }
 
 SPIRVTypeFloat *SPIRVModuleImpl::addFloatType(unsigned BitWidth) {
-  SPIRVTypeFloat *T = addType(new SPIRVTypeFloat(this, getId(), BitWidth));
+  auto Loc = FloatTypeMap.find(BitWidth);
+  if (Loc != FloatTypeMap.end())
+    return Loc->second;
+  auto Ty = new SPIRVTypeFloat(this, getId(), BitWidth);
+  FloatTypeMap[BitWidth] = Ty;
+  SPIRVTypeFloat *T = addType(Ty);
   return T;
 }
 
 SPIRVTypePointer *
 SPIRVModuleImpl::addPointerType(SPIRVStorageClassKind StorageClass,
                                 SPIRVType *ElementType) {
-  return addType(
-      new SPIRVTypePointer(this, getId(), StorageClass, ElementType));
+  auto Loc = PointerTypeMap.find({ElementType, StorageClass});
+  if (Loc != PointerTypeMap.end())
+    return Loc->second;
+  auto Ty = new SPIRVTypePointer(this, getId(), StorageClass, ElementType);
+  PointerTypeMap[std::make_pair(ElementType, StorageClass)] = Ty;
+  return addType(Ty);
 }
 
 SPIRVTypeFunction *SPIRVModuleImpl::addFunctionType(
@@ -888,7 +1022,12 @@ void SPIRVModuleImpl::closeStructType(SPIRVTypeStruct *T, bool Packed) {
 
 SPIRVTypeVector *SPIRVModuleImpl::addVectorType(SPIRVType *CompType,
                                                 SPIRVWord CompCount) {
-  return addType(new SPIRVTypeVector(this, getId(), CompType, CompCount));
+  auto Loc = VectorTypeMap.find({CompType, CompCount});
+  if (Loc != VectorTypeMap.end())
+    return Loc->second;
+  auto Ty = new SPIRVTypeVector(this, getId(), CompType, CompCount);
+  VectorTypeMap[std::make_pair(CompType, CompCount)] = Ty;
+  return addType(Ty);
 }
 SPIRVType *SPIRVModuleImpl::addOpaqueGenericType(Op TheOpCode) {
   return addType(new SPIRVTypeOpaqueGeneric(TheOpCode, this, getId()));
@@ -909,20 +1048,46 @@ SPIRVTypePipe *SPIRVModuleImpl::addPipeType() {
 SPIRVTypeImage *
 SPIRVModuleImpl::addImageType(SPIRVType *SampledType,
                               const SPIRVTypeImageDescriptor &Desc) {
-  return addType(new SPIRVTypeImage(
-      this, getId(), SampledType ? SampledType->getId() : 0, Desc));
+  return addImageType(SampledType, Desc, spv::AccessQualifierNone);
 }
 
 SPIRVTypeImage *
 SPIRVModuleImpl::addImageType(SPIRVType *SampledType,
                               const SPIRVTypeImageDescriptor &Desc,
                               SPIRVAccessQualifierKind Acc) {
-  return addType(new SPIRVTypeImage(
-      this, getId(), SampledType ? SampledType->getId() : 0, Desc, Acc));
+  // only ever create one OpTypeImage with the same parameters
+  for (const auto &entry : ImageTypeMap) {
+    if (entry.sampled_type == SampledType &&
+        entry.desc.Arrayed == Desc.Arrayed && entry.desc.Depth == Desc.Depth &&
+        entry.desc.Dim == Desc.Dim && entry.desc.Format == Desc.Format &&
+        entry.desc.MS == Desc.MS && entry.desc.Sampled == Desc.Sampled &&
+        entry.access == Acc) {
+      return entry.image_type;
+    }
+  }
+
+  // doesn't exist yet, create it
+  image_type_info info{
+      .sampled_type = SampledType, .desc = Desc, .access = Acc,
+  };
+  if (Acc != spv::AccessQualifierNone) {
+    info.image_type = addType(new SPIRVTypeImage(
+        this, getId(), SampledType ? SampledType->getId() : 0, Desc, Acc));
+  } else {
+    info.image_type = addType(new SPIRVTypeImage(
+        this, getId(), SampledType ? SampledType->getId() : 0, Desc));
+  }
+  ImageTypeMap.emplace_back(info);
+  return info.image_type;
 }
 
 SPIRVTypeSampler *SPIRVModuleImpl::addSamplerType() {
-  return addType(new SPIRVTypeSampler(this, getId()));
+  // only ever create one sampler type
+  if (SamplerType != nullptr) {
+    return SamplerType;
+  }
+  SamplerType = new SPIRVTypeSampler(this, getId());
+  return addType(SamplerType);
 }
 
 SPIRVTypePipeStorage *SPIRVModuleImpl::addPipeStorageType() {
@@ -930,7 +1095,13 @@ SPIRVTypePipeStorage *SPIRVModuleImpl::addPipeStorageType() {
 }
 
 SPIRVTypeSampledImage *SPIRVModuleImpl::addSampledImageType(SPIRVTypeImage *T) {
-  return addType(new SPIRVTypeSampledImage(this, getId(), T));
+  const auto iter = SampledImageTypeMap.find(T);
+  if (iter != SampledImageTypeMap.end()) {
+    return iter->second;
+  }
+  auto ret = new SPIRVTypeSampledImage(this, getId(), T);
+  SampledImageTypeMap.emplace(T, ret);
+  return addType(ret);
 }
 
 SPIRVTypeVmeImageINTEL *
@@ -989,6 +1160,21 @@ void SPIRVModuleImpl::addEntryPoint(SPIRVExecutionModelKind ExecModel,
   addCapabilities(SPIRV::getCapability(ExecModel));
 }
 
+void SPIRVModuleImpl::addEntryPointIO(SPIRVId EntryPoint, SPIRVVariable *var) {
+  assert(EntryPoint != SPIRVID_INVALID && "Invalid entry point");
+  decltype(EntryPointIO)::mapped_type *io_vars = nullptr;
+  const auto ep_iter = EntryPointIO.find(EntryPoint);
+  if (ep_iter != EntryPointIO.end()) {
+    io_vars = &ep_iter->second;
+  } else {
+    const auto empl_iter =
+        EntryPointIO.emplace(EntryPoint, decltype(EntryPointIO)::mapped_type{});
+    assert(empl_iter.second && "failed to insert new entry point i/o");
+    io_vars = &empl_iter.first->second;
+  }
+  io_vars->push_back(var);
+}
+
 SPIRVForward *SPIRVModuleImpl::addForward(SPIRVType *Ty) {
   return add(new SPIRVForward(this, Ty, getId()));
 }
@@ -1037,6 +1223,10 @@ SPIRVValue *SPIRVModuleImpl::addConstant(SPIRVType *Ty, uint64_t V) {
   }
   if (Ty->isTypeInt())
     return addIntegerConstant(static_cast<SPIRVTypeInt *>(Ty), V);
+  if (Ty->isTypeFloat(32))
+    return addFloatConstant(static_cast<SPIRVTypeFloat *>(Ty), *(float *)&V);
+  if (Ty->isTypeFloat(64))
+    return addDoubleConstant(static_cast<SPIRVTypeFloat *>(Ty), *(double *)&V);
   return addConstant(new SPIRVConstant(this, Ty, getId(), V));
 }
 
@@ -1045,19 +1235,34 @@ SPIRVValue *SPIRVModuleImpl::addConstant(SPIRVType *Ty, llvm::APInt V) {
 }
 
 SPIRVValue *SPIRVModuleImpl::addIntegerConstant(SPIRVTypeInt *Ty, uint64_t V) {
-  if (Ty->getBitWidth() == 32) {
-    unsigned I32 = static_cast<unsigned>(V);
+  const auto bit_width = Ty->getBitWidth();
+  if (bit_width == 32) {
+    uint32_t I32 = static_cast<uint32_t>(V);
     assert(I32 == V && "Integer value truncated");
-    return getLiteralAsConstant(I32);
+    return getLiteralAsConstant(I32, Ty->isSigned());
+  }
+  // for signed constants of bit-width 8 and 16, ensure upper bits are set if they are supposed to be negative
+  if (Ty->isSigned()) {
+    if (bit_width == 8 && V > 127) {
+      V |= 0xFFFF'FFFF'FFFF'FF00ull;
+    } else if (bit_width == 16 && V > 32767) {
+      V |= 0xFFFF'FFFF'FFFF'0000ull;
+    }
   }
   return addConstant(new SPIRVConstant(this, Ty, getId(), V));
 }
 
 SPIRVValue *SPIRVModuleImpl::addFloatConstant(SPIRVTypeFloat *Ty, float V) {
+  if (Ty->getBitWidth() == 32) {
+    return getLiteralAsConstant(V);
+  }
   return addConstant(new SPIRVConstant(this, Ty, getId(), V));
 }
 
 SPIRVValue *SPIRVModuleImpl::addDoubleConstant(SPIRVTypeFloat *Ty, double V) {
+  if (Ty->getBitWidth() == 64) {
+    return getLiteralAsConstant(V);
+  }
   return addConstant(new SPIRVConstant(this, Ty, getId(), V));
 }
 
@@ -1144,6 +1349,31 @@ SPIRVValue *SPIRVModuleImpl::addUndef(SPIRVType *TheType) {
   return addConstant(new SPIRVUndef(this, TheType, getId()));
 }
 
+SPIRVValue *SPIRVModuleImpl::addUndefInst(SPIRVType *TheType,
+                                          SPIRVBasicBlock *BB) {
+  return BB->addInstruction(new SPIRVUndefValueInternal(TheType, getId(), BB));
+}
+
+// Specialization constants creation functions
+SPIRVValue *SPIRVModuleImpl::addSpecDoubleConstant(SPIRVTypeFloat *Ty,
+                                                   double V) {
+  return add(new SPIRVSpecConstant(this, Ty, getId(), V));
+}
+
+SPIRVValue *SPIRVModuleImpl::addSpecFloatConstant(SPIRVTypeFloat *Ty, float V) {
+  return add(new SPIRVSpecConstant(this, Ty, getId(), V));
+}
+
+SPIRVValue *SPIRVModuleImpl::addSpecIntegerConstant(SPIRVTypeInt *Ty,
+                                                    uint64_t V) {
+  return add(new SPIRVSpecConstant(this, Ty, getId(), V));
+}
+
+SPIRVValue *SPIRVModuleImpl::addSpecCompositeConstant(
+    SPIRVType *Ty, const std::vector<SPIRVValue *> &Elements) {
+  return add(new SPIRVSpecConstantComposite(this, Ty, getId(), Elements));
+}
+
 SPIRVValue *SPIRVModuleImpl::addSpecConstant(SPIRVType *Ty, uint64_t V) {
   if (Ty->isTypeBool()) {
     if (V)
@@ -1449,17 +1679,31 @@ SPIRVInstruction *SPIRVModuleImpl::addSelectInst(SPIRVValue *Condition,
 
 SPIRVInstruction *SPIRVModuleImpl::addSelectionMergeInst(
     SPIRVId MergeBlock, SPIRVWord SelectionControl, SPIRVBasicBlock *BB) {
+  // NOTE: same as addLoopMergeInst, this must come before the terminator
+  auto term_instr = const_cast<SPIRVInstruction *>(BB->getTerminateInstr());
+  if (term_instr && !term_instr->isTerminationInstruction()) {
+    term_instr = nullptr;
+  }
   return addInstruction(
-      new SPIRVSelectionMerge(MergeBlock, SelectionControl, BB), BB);
+      new SPIRVSelectionMerge(MergeBlock, SelectionControl, BB), BB,
+      term_instr);
 }
 
 SPIRVInstruction *SPIRVModuleImpl::addLoopMergeInst(
     SPIRVId MergeBlock, SPIRVId ContinueTarget, SPIRVWord LoopControl,
     std::vector<SPIRVWord> LoopControlParameters, SPIRVBasicBlock *BB) {
+  // NOTE: "getTerminateInstr()" does not return a termination instruction,
+  // but just the current last instruction in the BB
+  // -> check if it's an actual term instruction, null it if not,
+  //    so that we don't add to the LoopMerge in front of a non-term instr
+  auto term_instr = const_cast<SPIRVInstruction *>(BB->getTerminateInstr());
+  if (term_instr && !term_instr->isTerminationInstruction()) {
+    term_instr = nullptr;
+  }
   return addInstruction(
       new SPIRVLoopMerge(MergeBlock, ContinueTarget, LoopControl,
                          LoopControlParameters, BB),
-      BB, const_cast<SPIRVInstruction *>(BB->getTerminateInstr()));
+      BB, term_instr);
 }
 
 SPIRVInstruction *SPIRVModuleImpl::addLoopControlINTELInst(
@@ -1507,6 +1751,37 @@ SPIRVModuleImpl::addPtrAccessChainInst(SPIRVType *Type, SPIRVValue *Base,
       BB);
 }
 
+SPIRVInstruction *
+SPIRVModuleImpl::addAccessChainInst(SPIRVType *Type, SPIRVValue *Base,
+                                    std::vector<SPIRVValue *> Indices,
+                                    SPIRVBasicBlock *BB, bool IsInBounds) {
+  // check if this is a run-time array access (SSBO)
+  bool is_rtarr_access = false;
+  if (Base->getType()->isTypePointer() &&
+      Base->getType()->getPointerElementType()->isTypeStruct()) {
+    auto st_type = (SPIRVTypeStruct *)Base->getType()->getPointerElementType();
+    if (st_type->getStructMemberCount() > 0 &&
+        st_type->getMemberType(0)->isTypeRuntimeArray()) {
+      is_rtarr_access = true;
+    }
+  }
+  if (is_rtarr_access) {
+    // add an additional 0 index in front, because we always wrap SSBO/run-time
+    // array data in a struct
+    Indices.insert(
+        begin(Indices),
+        addIntegerConstant((SPIRVTypeInt *)Indices[0]->getType(), 0));
+  } else if (Indices.size() > 1) {
+    // if it's not a run-time array access, remove the first (0) index
+    Indices.erase(Indices.begin());
+  }
+  return addInstruction(
+      SPIRVInstTemplateBase::create(
+          IsInBounds ? OpInBoundsAccessChain : OpAccessChain, Type, getId(),
+          getVec(Base->getId(), Base->getIds(Indices)), BB, this),
+      BB);
+}
+
 SPIRVInstruction *SPIRVModuleImpl::addAsyncGroupCopy(
     SPIRVValue *Scope, SPIRVValue *Dest, SPIRVValue *Src, SPIRVValue *NumElems,
     SPIRVValue *Stride, SPIRVValue *Event, SPIRVBasicBlock *BB) {
@@ -1635,16 +1910,73 @@ SPIRVInstruction *SPIRVModuleImpl::addVariable(
     SPIRVStorageClassKind StorageClass, SPIRVBasicBlock *BB) {
   SPIRVVariable *Variable = new SPIRVVariable(Type, getId(), Initializer, Name,
                                               StorageClass, BB, this);
-  if (BB)
-    return addInstruction(Variable, BB);
+  if (BB) {
+    // ensure variables are always added at the front
+    SPIRVInstruction* insert_before = nullptr;
+    if (BB->getNumInst() > 0) {
+      insert_before = BB->getInst(0);
+    }
+    return addInstruction(Variable, BB, insert_before);
+  }
 
   add(Variable);
   if (LinkageTy != internal::LinkageTypeInternal)
     Variable->setLinkageType(LinkageTy);
-  Variable->setIsConstant(IsConstant);
+  // shader doesn't have the constant decoration
+  if (SrcLang != spv::SourceLanguageGLSL) {
+    Variable->setIsConstant(IsConstant);
+  }
   return Variable;
 }
 
+SPIRVInstruction *SPIRVModuleImpl::addKillInst(SPIRVBasicBlock *BB) {
+  return addInstruction(new SPIRVKill(BB), BB);
+}
+
+SPIRVInstruction *SPIRVModuleImpl::addDerivativeInst(Op op, SPIRVValue *p,
+                                                     SPIRVBasicBlock *BB) {
+  switch (op) {
+  case spv::OpDPdx:
+    return addInstruction(new SPIRVDPdx(getId(), p, BB), BB);
+  case spv::OpDPdxFine:
+    return addInstruction(new SPIRVDPdxFine(getId(), p, BB), BB);
+  case spv::OpDPdxCoarse:
+    return addInstruction(new SPIRVDPdxCoarse(getId(), p, BB), BB);
+  case spv::OpDPdy:
+    return addInstruction(new SPIRVDPdy(getId(), p, BB), BB);
+  case spv::OpDPdyFine:
+    return addInstruction(new SPIRVDPdyFine(getId(), p, BB), BB);
+  case spv::OpDPdyCoarse:
+    return addInstruction(new SPIRVDPdyCoarse(getId(), p, BB), BB);
+  case spv::OpFwidth:
+    return addInstruction(new SPIRVFwidth(getId(), p, BB), BB);
+  case spv::OpFwidthFine:
+    return addInstruction(new SPIRVFwidthFine(getId(), p, BB), BB);
+  case spv::OpFwidthCoarse:
+    return addInstruction(new SPIRVFwidthCoarse(getId(), p, BB), BB);
+  default:
+    llvm_unreachable("invalid derivative opcode");
+  }
+}
+
+SPIRVInstruction *SPIRVModuleImpl::addBitCountInst(SPIRVType *ret_type,
+                                                   SPIRVValue *p,
+                                                   SPIRVBasicBlock *BB) {
+  return addInstruction(
+      SPIRVInstTemplateBase::create(spv::OpBitCount, ret_type, getId(),
+                                    getVec(p->getId()), BB, this),
+      BB);
+}
+
+SPIRVInstruction *SPIRVModuleImpl::addBitReverseInst(SPIRVType *ret_type,
+                                                     SPIRVValue *p,
+                                                     SPIRVBasicBlock *BB) {
+  return addInstruction(
+      SPIRVInstTemplateBase::create(spv::OpBitReverse, ret_type, getId(),
+                                    getVec(p->getId()), BB, this),
+      BB);
+}
+
 template <class T>
 spv_ostream &operator<<(spv_ostream &O, const std::vector<T *> &V) {
   for (auto &I : V)
@@ -1796,6 +2128,13 @@ spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M) {
 
   for (auto &I : M.getExtension()) {
     assert(!I.empty() && "Invalid extension");
+
+    // skip vk_capability_* "extensions"
+    // we only want these as caps, not extensions
+    if (I.find("vk_capability_") != std::string::npos) {
+      continue;
+    }
+
     O << SPIRVExtension(&M, I);
   }
 
@@ -1804,10 +2143,24 @@ spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M) {
 
   O << SPIRVMemoryModel(&M);
 
-  for (auto &I : MI.EntryPointVec)
-    for (auto &II : I.second)
-      O << SPIRVEntryPoint(&M, I.first, II, M.get<SPIRVFunction>(II)->getName(),
-                           M.get<SPIRVFunction>(II)->getVariables());
+  for (auto &I : MI.EntryPointVec) {
+    for (auto &II : I.second) {
+      if (MI.getSourceLanguage(nullptr) != spv::SourceLanguageGLSL) {
+        O << SPIRVEntryPoint(&M, I.first, II, M.get<SPIRVFunction>(II)->getName(),
+                             M.get<SPIRVFunction>(II)->getVariables());
+      } else {
+        std::vector<SPIRVId> io_vars;
+        const auto ep_iter = MI.getEntryPointIO().find(II);
+        if (ep_iter != MI.getEntryPointIO().end()) {
+          for (const auto& var : ep_iter->second) {
+            io_vars.emplace_back(var->getId());
+          }
+        }
+        O << SPIRVEntryPoint(&M, I.first, II, M.get<SPIRVFunction>(II)->getName(),
+                             io_vars);
+      }
+    }
+  }
 
   for (auto &I : MI.EntryPointVec)
     for (auto &II : I.second)
@@ -1823,6 +2176,7 @@ spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M) {
   O << SPIRVSource(&M);
 
   for (auto &I : MI.NamedId) {
+#if 0
     // Don't output name for entry point since it is redundant
     bool IsEntryPoint = false;
     for (auto &EPS : MI.EntryPointSet)
@@ -1832,6 +2186,9 @@ spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M) {
       }
     if (!IsEntryPoint)
       M.getEntry(I)->encodeName(O);
+#else
+    M.getEntry(I)->encodeName(O);
+#endif
   }
 
   if (M.isAllowedToUseExtension(
@@ -1933,6 +2290,12 @@ static std::string to_string(uint32_t Version) {
   case static_cast<uint32_t>(VersionNumber::SPIRV_1_3):
     Res = "1.3";
     break;
+  case static_cast<uint32_t>(VersionNumber::SPIRV_1_4):
+    Res = "1.4";
+    break;
+  case static_cast<uint32_t>(VersionNumber::SPIRV_1_5):
+    Res = "1.5";
+    break;
   default:
     Res = "unknown";
   }
@@ -2092,7 +2455,7 @@ bool isSpirvBinary(const std::string &Img) {
 
 #ifdef _SPIRV_SUPPORT_TEXT_FMT
 
-bool convertSpirv(std::istream &IS, std::ostream &OS, std::string &ErrMsg,
+bool convertSpirv(std::istream &IS, spv_ostream &OS, std::string &ErrMsg,
                   bool FromText, bool ToText) {
   auto SaveOpt = SPIRVUseTextFormat;
   SPIRVUseTextFormat = FromText;
@@ -2136,10 +2499,10 @@ bool convertSpirv(std::string &Input, std::string &Out, std::string &ErrMsg,
     return true;
   }
   std::istringstream IS(Input);
-  std::ostringstream OS;
+  raw_string_ostream OS(Out);
   if (!convertSpirv(IS, OS, ErrMsg, FromText, ToText))
     return false;
-  Out = OS.str();
+  OS.flush();
   return true;
 }
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVModule.h b/lib/SPIRV/libSPIRV/SPIRVModule.h
index b68c332..891058a 100644
--- a/lib/SPIRV/libSPIRV/SPIRVModule.h
+++ b/lib/SPIRV/libSPIRV/SPIRVModule.h
@@ -65,6 +65,7 @@ class SPIRVFunction;
 class SPIRVInstruction;
 class SPIRVType;
 class SPIRVTypeArray;
+class SPIRVTypeRuntimeArray;
 class SPIRVTypeBool;
 class SPIRVTypeFloat;
 class SPIRVTypeFunction;
@@ -134,6 +135,8 @@ public:
   virtual SPIRVExtInstSetKind getBuiltinSet(SPIRVId) const = 0;
   virtual SPIRVFunction *getEntryPoint(SPIRVExecutionModelKind,
                                        unsigned) const = 0;
+  virtual const std::map<SPIRVId, std::vector<SPIRVVariable *>> &
+  getEntryPointIO() const = 0;
   virtual std::set<std::string> &getExtension() = 0;
   virtual SPIRVFunction *getFunction(unsigned) const = 0;
   virtual SPIRVVariable *getVariable(unsigned) const = 0;
@@ -153,7 +156,9 @@ public:
   virtual SPIRVType *getValueType(SPIRVId TheId) const = 0;
   virtual std::vector<SPIRVType *>
   getValueTypes(const std::vector<SPIRVId> &) const = 0;
-  virtual SPIRVConstant *getLiteralAsConstant(unsigned Literal) = 0;
+  virtual SPIRVConstant *getLiteralAsConstant(unsigned Literal, bool is_signed) = 0;
+  virtual SPIRVConstant *getLiteralAsConstant(float Literal) = 0;
+  virtual SPIRVConstant *getLiteralAsConstant(double Literal) = 0;
   virtual bool isEntryPoint(SPIRVExecutionModelKind, SPIRVId) const = 0;
   virtual unsigned short getGeneratorId() const = 0;
   virtual unsigned short getGeneratorVer() const = 0;
@@ -212,6 +217,7 @@ public:
   virtual SPIRVGroupDecorateGeneric *
   addGroupDecorateGeneric(SPIRVGroupDecorateGeneric *GDec) = 0;
   virtual void addEntryPoint(SPIRVExecutionModelKind, SPIRVId) = 0;
+  virtual void addEntryPointIO(SPIRVId EntryPoint, SPIRVVariable *var) = 0;
   virtual SPIRVForward *addForward(SPIRVType *Ty) = 0;
   virtual SPIRVForward *addForward(SPIRVId, SPIRVType *Ty) = 0;
   virtual SPIRVFunction *addFunction(SPIRVFunction *) = 0;
@@ -222,6 +228,7 @@ public:
 
   // Type creation functions
   virtual SPIRVTypeArray *addArrayType(SPIRVType *, SPIRVConstant *) = 0;
+  virtual SPIRVTypeRuntimeArray *addRuntimeArrayType(SPIRVType *) = 0;
   virtual SPIRVTypeBool *addBoolType() = 0;
   virtual SPIRVTypeFloat *addFloatType(unsigned) = 0;
   virtual SPIRVTypeFunction *
@@ -234,7 +241,7 @@ public:
   virtual SPIRVTypeSampler *addSamplerType() = 0;
   virtual SPIRVTypePipeStorage *addPipeStorageType() = 0;
   virtual SPIRVTypeSampledImage *addSampledImageType(SPIRVTypeImage *T) = 0;
-  virtual SPIRVTypeInt *addIntegerType(unsigned) = 0;
+  virtual SPIRVTypeInt *addIntegerType(unsigned, bool is_signed) = 0;
   virtual SPIRVTypeOpaque *addOpaqueType(const std::string &) = 0;
   virtual SPIRVTypePointer *addPointerType(SPIRVStorageClassKind,
                                            SPIRVType *) = 0;
@@ -274,6 +281,7 @@ public:
   virtual SPIRVValue *addIntegerConstant(SPIRVTypeInt *, uint64_t) = 0;
   virtual SPIRVValue *addNullConstant(SPIRVType *) = 0;
   virtual SPIRVValue *addUndef(SPIRVType *TheType) = 0;
+  virtual SPIRVValue *addUndefInst(SPIRVType *TheType, SPIRVBasicBlock *) = 0;
   virtual SPIRVValue *addSamplerConstant(SPIRVType *TheType, SPIRVWord AddrMode,
                                          SPIRVWord ParametricMode,
                                          SPIRVWord FilterMode) = 0;
@@ -282,10 +290,20 @@ public:
                                              SPIRVWord PacketAlign,
                                              SPIRVWord Capacity) = 0;
 
+  // Specialization constants creation functions
+  virtual SPIRVValue *addSpecDoubleConstant(SPIRVTypeFloat *, double) = 0;
+  virtual SPIRVValue *addSpecFloatConstant(SPIRVTypeFloat *, float) = 0;
+  virtual SPIRVValue *addSpecIntegerConstant(SPIRVTypeInt *, uint64_t) = 0;
+  virtual SPIRVValue *
+  addSpecCompositeConstant(SPIRVType *, const std::vector<SPIRVValue *> &) = 0;
+
   // Instruction creation functions
   virtual SPIRVInstruction *addPtrAccessChainInst(SPIRVType *, SPIRVValue *,
                                                   std::vector<SPIRVValue *>,
                                                   SPIRVBasicBlock *, bool) = 0;
+  virtual SPIRVInstruction *addAccessChainInst(SPIRVType *, SPIRVValue *,
+                                               std::vector<SPIRVValue *>,
+                                               SPIRVBasicBlock *, bool) = 0;
   virtual SPIRVInstruction *
   addAsyncGroupCopy(SPIRVValue *Scope, SPIRVValue *Dest, SPIRVValue *Src,
                     SPIRVValue *NumElems, SPIRVValue *Stride, SPIRVValue *Event,
@@ -460,6 +478,17 @@ public:
                                              SPIRVValue *ExpectedValue,
                                              SPIRVBasicBlock *BB) = 0;
 
+  virtual SPIRVInstruction *addBitCountInst(SPIRVType *ret_type, SPIRVValue *p,
+                                            SPIRVBasicBlock *BB) = 0;
+
+  // GLSL/shader functions
+  virtual SPIRVInstruction *addKillInst(SPIRVBasicBlock *) = 0;
+  virtual SPIRVInstruction *addDerivativeInst(Op op, SPIRVValue *p,
+                                              SPIRVBasicBlock *BB) = 0;
+  virtual SPIRVInstruction *addBitReverseInst(SPIRVType *ret_type,
+                                              SPIRVValue *p,
+                                              SPIRVBasicBlock *BB) = 0;
+
   virtual SPIRVId getExtInstSetId(SPIRVExtInstSetKind Kind) const = 0;
 
   virtual bool
diff --git a/lib/SPIRV/libSPIRV/SPIRVOpCode.h b/lib/SPIRV/libSPIRV/SPIRVOpCode.h
index 8092370..7fadd30 100644
--- a/lib/SPIRV/libSPIRV/SPIRVOpCode.h
+++ b/lib/SPIRV/libSPIRV/SPIRVOpCode.h
@@ -138,6 +138,14 @@ inline bool isAccessChainOpCode(Op OpCode) {
   return OpCode == OpAccessChain || OpCode == OpInBoundsAccessChain;
 }
 
+inline bool isImageOpCode(Op OpCode) {
+  return (((unsigned)OpCode >= OpSampledImage &&
+           (unsigned)OpCode <= OpImageQuerySamples) ||
+          ((unsigned)OpCode >= OpImageSparseSampleImplicitLod &&
+           (unsigned)OpCode <= OpImageSparseTexelsResident) ||
+          OpCode == OpImageTexelPointer || OpCode == OpImageSparseRead);
+}
+
 inline bool hasExecScope(Op OpCode) {
   unsigned OC = OpCode;
   return (OpGroupWaitEvents <= OC && OC <= OpGroupSMax) ||
diff --git a/lib/SPIRV/libSPIRV/SPIRVOpCodeEnumInternal.h b/lib/SPIRV/libSPIRV/SPIRVOpCodeEnumInternal.h
index b91b571..55dcf8f 100644
--- a/lib/SPIRV/libSPIRV/SPIRVOpCodeEnumInternal.h
+++ b/lib/SPIRV/libSPIRV/SPIRVOpCodeEnumInternal.h
@@ -1,6 +1,7 @@
 #include "spirv_internal.hpp"
 
 _SPIRV_OP_INTERNAL(Forward, internal::OpForward)
+_SPIRV_OP_INTERNAL(UndefValueInternal, internal::OpUndefValueInternal)
 _SPIRV_OP_INTERNAL(AliasDomainDeclINTEL, internal::OpAliasDomainDeclINTEL)
 _SPIRV_OP_INTERNAL(AliasScopeDeclINTEL, internal::OpAliasScopeDeclINTEL)
 _SPIRV_OP_INTERNAL(AliasScopeListDeclINTEL, internal::OpAliasScopeListDeclINTEL)
diff --git a/lib/SPIRV/libSPIRV/SPIRVStream.cpp b/lib/SPIRV/libSPIRV/SPIRVStream.cpp
index 555b7a2..d38dfe7 100644
--- a/lib/SPIRV/libSPIRV/SPIRVStream.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVStream.cpp
@@ -134,6 +134,7 @@ SPIRV_DEF_ENCDEC(Capability)
 SPIRV_DEF_ENCDEC(Decoration)
 SPIRV_DEF_ENCDEC(OCLExtOpKind)
 SPIRV_DEF_ENCDEC(SPIRVDebugExtOpKind)
+SPIRV_DEF_ENCDEC(GLSLExtOpKind)
 SPIRV_DEF_ENCDEC(LinkageType)
 
 // Read a string with padded 0's at the end so that they form a stream of
diff --git a/lib/SPIRV/libSPIRV/SPIRVStream.h b/lib/SPIRV/libSPIRV/SPIRVStream.h
index 0208827..a0558c5 100644
--- a/lib/SPIRV/libSPIRV/SPIRVStream.h
+++ b/lib/SPIRV/libSPIRV/SPIRVStream.h
@@ -226,6 +226,7 @@ SPIRV_DEC_ENCDEC(Capability)
 SPIRV_DEC_ENCDEC(Decoration)
 SPIRV_DEC_ENCDEC(OCLExtOpKind)
 SPIRV_DEC_ENCDEC(SPIRVDebugExtOpKind)
+SPIRV_DEC_ENCDEC(GLSLExtOpKind)
 SPIRV_DEC_ENCDEC(LinkageType)
 
 const SPIRVEncoder &operator<<(const SPIRVEncoder &O, const std::string &Str);
diff --git a/lib/SPIRV/libSPIRV/SPIRVType.cpp b/lib/SPIRV/libSPIRV/SPIRVType.cpp
index d9074ad..de1ad9c 100644
--- a/lib/SPIRV/libSPIRV/SPIRVType.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVType.cpp
@@ -47,8 +47,13 @@
 namespace SPIRV {
 
 SPIRVType *SPIRVType::getArrayElementType() const {
-  assert(OpCode == OpTypeArray && "Not array type");
-  return static_cast<const SPIRVTypeArray *>(this)->getElementType();
+  assert((OpCode == OpTypeArray || OpCode == OpTypeRuntimeArray) &&
+         "Not array type");
+  if (OpCode == OpTypeArray) {
+    return static_cast<const SPIRVTypeArray *const>(this)->getElementType();
+  }
+  return static_cast<const SPIRVTypeRuntimeArray *const>(this)
+      ->getElementType();
 }
 
 uint64_t SPIRVType::getArrayLength() const {
@@ -146,7 +151,14 @@ SPIRVType *SPIRVType::getScalarType() const {
 }
 
 bool SPIRVType::isTypeVoid() const { return OpCode == OpTypeVoid; }
-bool SPIRVType::isTypeArray() const { return OpCode == OpTypeArray; }
+
+bool SPIRVType::isTypeArray() const {
+  return OpCode == OpTypeArray || OpCode == OpTypeRuntimeArray;
+}
+
+bool SPIRVType::isTypeRuntimeArray() const {
+  return OpCode == OpTypeRuntimeArray;
+}
 
 bool SPIRVType::isTypeBool() const { return OpCode == OpTypeBool; }
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVType.h b/lib/SPIRV/libSPIRV/SPIRVType.h
index b8fcd1b..03b7747 100644
--- a/lib/SPIRV/libSPIRV/SPIRVType.h
+++ b/lib/SPIRV/libSPIRV/SPIRVType.h
@@ -79,6 +79,7 @@ public:
 
   bool isTypeVoid() const;
   bool isTypeArray() const;
+  bool isTypeRuntimeArray() const;
   bool isTypeBool() const;
   bool isTypeComposite() const;
   bool isTypeEvent() const;
@@ -177,6 +178,16 @@ public:
     }
   }
 
+  // gets the signed integer type with the same bit-width as this type
+  SPIRVTypeInt *getSigned() const {
+    return Module->addIntegerType(BitWidth, true);
+  }
+
+  // gets the unsigned integer type with the same bit-width as this type
+  SPIRVTypeInt *getUnsigned() const {
+    return Module->addIntegerType(BitWidth, false);
+  }
+
 protected:
   _SPIRV_DEF_ENCDEC3(Id, BitWidth, IsSigned)
   void validate() const override {
@@ -207,11 +218,15 @@ public:
   SPIRVCapVec getRequiredCapability() const override {
     SPIRVCapVec CV;
     if (isTypeFloat(16)) {
-      CV.push_back(CapabilityFloat16Buffer);
-      auto Extensions = getModule()->getSourceExtension();
-      if (std::any_of(Extensions.begin(), Extensions.end(),
-                      [](const std::string &I) { return I == "cl_khr_fp16"; }))
+      if (Module->getSourceLanguage(nullptr) == spv::SourceLanguageGLSL) {
         CV.push_back(CapabilityFloat16);
+      } else {
+        CV.push_back(CapabilityFloat16Buffer);
+        auto Extensions = getModule()->getSourceExtension();
+        if (std::any_of(Extensions.begin(), Extensions.end(),
+                        [](const std::string &I) { return I == "cl_khr_fp16"; }))
+          CV.push_back(CapabilityFloat16);
+      }
     } else if (isTypeFloat(64))
       CV.push_back(CapabilityFloat64);
     return CV;
@@ -248,6 +263,10 @@ public:
   }
   SPIRVStorageClassKind getStorageClass() const { return ElemStorageClass; }
   SPIRVCapVec getRequiredCapability() const override {
+    // cap requirements are different for shaders and kernels
+    if (Module->getSourceLanguage(nullptr) == spv::SourceLanguageGLSL) {
+      return getCapability(ElemStorageClass);
+    }
     auto Cap = getVec(CapabilityAddresses);
     if (getElementType()->isTypeFloat(16))
       Cap.push_back(CapabilityFloat16Buffer);
@@ -411,6 +430,36 @@ private:
   SPIRVId Length;      // Array Length
 };
 
+class SPIRVTypeRuntimeArray : public SPIRVType {
+public:
+  // Complete constructor
+  SPIRVTypeRuntimeArray(SPIRVModule *M, SPIRVId TheId, SPIRVType *TheElemType)
+      : SPIRVType(M, 3, OpTypeRuntimeArray, TheId), ElemType(TheElemType) {
+    validate();
+  }
+  // Incomplete constructor
+  SPIRVTypeRuntimeArray() : SPIRVType(OpTypeRuntimeArray), ElemType(nullptr) {}
+
+  SPIRVType *getElementType() const { return ElemType; }
+  SPIRVCapVec getRequiredCapability() const override {
+    return getElementType()->getRequiredCapability();
+  }
+  std::vector<SPIRVEntry *> getNonLiteralOperands() const override {
+    std::vector<SPIRVEntry *> Operands(1, ElemType);
+    return Operands;
+  }
+
+protected:
+  _SPIRV_DEF_ENCDEC2(Id, ElemType)
+  void validate() const override {
+    SPIRVEntry::validate();
+    ElemType->validate();
+  }
+
+private:
+  SPIRVType *ElemType; // Element Type
+};
+
 class SPIRVTypeOpaque : public SPIRVType {
 public:
   // Complete constructor
@@ -469,6 +518,10 @@ inline void SPIRVMap<std::string, SPIRVTypeImageDescriptor>::init() {
   _SPIRV_OP(image2d_msaa_depth_t, Dim2D, 1, 0, 1, 0, 0)
   _SPIRV_OP(image2d_array_msaa_depth_t, Dim2D, 1, 1, 1, 0, 0)
   _SPIRV_OP(image3d_t, Dim3D, 0, 0, 0, 0, 0)
+  _SPIRV_OP(imagecube_t, DimCube, 0, 0, 0, 0, 0)
+  _SPIRV_OP(imagecube_array_t, DimCube, 0, 1, 0, 0, 0)
+  _SPIRV_OP(imagecube_depth_t, DimCube, 1, 0, 0, 0, 0)
+  _SPIRV_OP(imagecube_array_depth_t, DimCube, 1, 1, 0, 0, 0)
 #undef _SPIRV_OP
 }
 typedef SPIRVMap<std::string, SPIRVTypeImageDescriptor> OCLSPIRVImageTypeMap;
@@ -487,36 +540,44 @@ public:
   SPIRVTypeImage(SPIRVModule *M, SPIRVId TheId, SPIRVId TheSampledType,
                  const SPIRVTypeImageDescriptor &TheDesc)
       : SPIRVType(M, FixedWC, OC, TheId), SampledType(TheSampledType),
-        Desc(TheDesc) {
+        Desc(TheDesc), Acc(spv::AccessQualifierNone) {
     validate();
   }
   SPIRVTypeImage(SPIRVModule *M, SPIRVId TheId, SPIRVId TheSampledType,
                  const SPIRVTypeImageDescriptor &TheDesc,
                  SPIRVAccessQualifierKind TheAcc)
       : SPIRVType(M, FixedWC + 1, OC, TheId), SampledType(TheSampledType),
-        Desc(TheDesc) {
-    Acc.push_back(TheAcc);
+        Desc(TheDesc), Acc(TheAcc) {
     validate();
   }
   SPIRVTypeImage() : SPIRVType(OC), SampledType(SPIRVID_INVALID), Desc() {}
   const SPIRVTypeImageDescriptor &getDescriptor() const { return Desc; }
   bool isOCLImage() const { return Desc.Sampled == 0 && Desc.Format == 0; }
-  bool hasAccessQualifier() const { return !Acc.empty(); }
+  bool hasAccessQualifier() const { return Acc != spv::AccessQualifierNone; }
   SPIRVAccessQualifierKind getAccessQualifier() const {
     assert(hasAccessQualifier());
-    return Acc[0];
+    return Acc;
   }
   SPIRVCapVec getRequiredCapability() const override {
     SPIRVCapVec CV;
-    CV.push_back(CapabilityImageBasic);
-    if (Desc.Dim == SPIRVImageDimKind::Dim1D)
+    if (Module->getSourceLanguage(nullptr) != spv::SourceLanguageGLSL) {
+      CV.push_back(CapabilityImageBasic);
+      if (Acc != spv::AccessQualifierNone && Acc == AccessQualifierReadWrite)
+        CV.push_back(CapabilityImageReadWrite);
+      if (Desc.MS)
+        CV.push_back(CapabilityImageMipmap);
+    } else {
+      if (Desc.MS)
+        CV.push_back(CapabilityImageMSArray);
+    }
+    if (Desc.Dim == spv::Dim1D) {
       CV.push_back(CapabilitySampled1D);
-    else if (Desc.Dim == SPIRVImageDimKind::DimBuffer)
+      if (Desc.Sampled == 2) {
+        CV.push_back(CapabilityImage1D);
+      }
+    } else if (Desc.Dim == spv::DimBuffer) {
       CV.push_back(CapabilitySampledBuffer);
-    if (Acc.size() > 0 && Acc[0] == AccessQualifierReadWrite)
-      CV.push_back(CapabilityImageReadWrite);
-    if (Desc.MS)
-      CV.push_back(CapabilityImageMipmap);
+    }
     return CV;
   }
   SPIRVType *getSampledType() const { return get<SPIRVType>(SampledType); }
@@ -526,30 +587,39 @@ public:
   }
 
 protected:
-  _SPIRV_DEF_ENCDEC9(Id, SampledType, Desc.Dim, Desc.Depth, Desc.Arrayed,
-                     Desc.MS, Desc.Sampled, Desc.Format, Acc)
-  // The validation assumes OpenCL image or sampler type.
+  void encode(spv_ostream &O) const override {
+    getEncoder(O) << Id << SampledType << Desc.Dim << Desc.Depth << Desc.Arrayed
+                  << Desc.MS << Desc.Sampled << Desc.Format;
+    if (Acc != spv::AccessQualifierNone)
+      getEncoder(O) << Acc;
+  }
+  void decode(std::istream &I) override {
+    getDecoder(I) >> Id >> SampledType >> Desc.Dim >> Desc.Depth >>
+        Desc.Arrayed >> Desc.MS >> Desc.Sampled >> Desc.Format;
+    // TODO: test this
+    if (WordCount >= 10)
+      getDecoder(I) >> Acc;
+    else
+      Acc = spv::AccessQualifierNone;
+  }
   void validate() const override {
     assert(OpCode == OC);
-    assert(WordCount == FixedWC + Acc.size());
-    assert(SampledType != SPIRVID_INVALID && "Invalid sampled type");
-    assert(Desc.Dim <= 5);
+    assert(WordCount == FixedWC + (Acc != spv::AccessQualifierNone ? 1 : 0));
+    assert(Desc.Dim < DimMax);
     assert(Desc.Depth <= 1);
     assert(Desc.Arrayed <= 1);
     assert(Desc.MS <= 1);
-    assert(Desc.Sampled == 0); // For OCL only
-    assert(Desc.Format == 0);  // For OCL only
-    assert(Acc.size() <= 1);
+    assert(Desc.Sampled <= 2);
+    assert(Desc.Format < ImageFormatMax);
   }
   void setWordCount(SPIRVWord TheWC) override {
     WordCount = TheWC;
-    Acc.resize(WordCount - FixedWC);
   }
 
 private:
   SPIRVId SampledType;
   SPIRVTypeImageDescriptor Desc;
-  std::vector<SPIRVAccessQualifierKind> Acc;
+  SPIRVAccessQualifierKind Acc;
 };
 
 class SPIRVTypeSampler : public SPIRVType {
@@ -911,7 +981,7 @@ protected:
   }
   void setWordCount(SPIRVWord TheWC) override {
     if (TheWC > FixedWC)
-      AccessKind = SPIRVAccessQualifierKind::AccessQualifierMax;
+      AccessKind = SPIRVAccessQualifierKind::AccessQualifierNone;
     WordCount = TheWC;
   }
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVUtil.h b/lib/SPIRV/libSPIRV/SPIRVUtil.h
index 0020249..cf63c31 100644
--- a/lib/SPIRV/libSPIRV/SPIRVUtil.h
+++ b/lib/SPIRV/libSPIRV/SPIRVUtil.h
@@ -40,8 +40,13 @@
 #ifndef SPIRV_LIBSPIRV_SPIRVUTIL_H
 #define SPIRV_LIBSPIRV_SPIRVUTIL_H
 
+#if 1
+#include "llvm/Support/raw_ostream.h"
+#define spv_ostream llvm::raw_ostream
+#else
 #include <ostream>
 #define spv_ostream std::ostream
+#endif
 
 #include <algorithm>
 #include <cassert>
@@ -101,22 +106,26 @@ public:
     return Val;
   }
 
-  static const SPIRVMap &getMap() {
+  static SPIRVMap &getMapMod() {
 #if defined(_MSC_VER) && (_MSC_VER < 1900)
     llvm::sys::ScopedLock mapGuard(MapLock);
 #endif // LLVM_MSC_PREREQ(1900)
-    static const SPIRVMap Map(false);
+    static SPIRVMap Map(false);
     return Map;
   }
 
-  static const SPIRVMap &getRMap() {
+  static SPIRVMap &getRMapMod() {
 #if defined(_MSC_VER) && (_MSC_VER < 1900)
     llvm::sys::ScopedLock mapGuard(MapLock);
 #endif // LLVM_MSC_PREREQ(1900)
-    static const SPIRVMap Map(true);
+    static SPIRVMap Map(true);
     return Map;
   }
 
+  static const SPIRVMap &getMap() { return getMapMod(); }
+
+  static const SPIRVMap &getRMap() { return getRMapMod(); }
+
   static void foreach (std::function<void(Ty1, Ty2)> F) {
     for (auto &I : getMap().Map)
       F(I.first, I.second);
@@ -150,6 +159,14 @@ public:
       *Val = Loc->second;
     return true;
   }
+
+  static void replace(Ty1 Key, Ty2 Val) {
+    SPIRVMap &Map = getMapMod();
+    SPIRVMap &RMap = getRMapMod();
+    Map.Map[Key] = Val;
+    RMap.RevMap[Val] = Key;
+  }
+
   SPIRVMap() : IsReverse(false) {}
 
 protected:
diff --git a/lib/SPIRV/libSPIRV/spirv.hpp b/lib/SPIRV/libSPIRV/spirv.hpp
index 3bce5cd..a89b8ae 100644
--- a/lib/SPIRV/libSPIRV/spirv.hpp
+++ b/lib/SPIRV/libSPIRV/spirv.hpp
@@ -91,6 +91,7 @@ enum ExecutionModel {
     ExecutionModelCallableKHR = 5318,
     ExecutionModelCallableNV = 5318,
     ExecutionModelMax = 0x7fffffff,
+    ExecutionModelInvalid = ExecutionModelMax,
 };
 
 enum AddressingModel {
@@ -223,7 +224,7 @@ enum Dim {
     DimRect = 4,
     DimBuffer = 5,
     DimSubpassData = 6,
-    DimMax = 0x7fffffff,
+    DimMax,
 };
 
 enum SamplerAddressingMode {
@@ -284,7 +285,7 @@ enum ImageFormat {
     ImageFormatR8ui = 39,
     ImageFormatR64ui = 40,
     ImageFormatR64i = 41,
-    ImageFormatMax = 0x7fffffff,
+    ImageFormatMax,
 };
 
 enum ImageChannelOrder {
@@ -429,7 +430,8 @@ enum AccessQualifier {
     AccessQualifierReadOnly = 0,
     AccessQualifierWriteOnly = 1,
     AccessQualifierReadWrite = 2,
-    AccessQualifierMax = 0x7fffffff,
+	// used by Vulkan/SPIR-V, which can't have access qualifiers
+	AccessQualifierNone = 0x7fffffff,
 };
 
 enum FunctionParameterAttribute {
diff --git a/lib/SPIRV/libSPIRV/spirv_internal.hpp b/lib/SPIRV/libSPIRV/spirv_internal.hpp
index 4f86e3b..9f54c69 100644
--- a/lib/SPIRV/libSPIRV/spirv_internal.hpp
+++ b/lib/SPIRV/libSPIRV/spirv_internal.hpp
@@ -40,6 +40,7 @@ enum InternalOp {
   IOpAliasScopeListDeclINTEL = 5913,
   IOpTypeTokenINTEL = 6113,
   IOpPrev = OpMax - 2,
+  IOpUndefValueInternal,
   IOpForward
 };
 
@@ -75,6 +76,7 @@ constexpr LinkageType LinkageTypeInternal =
     static_cast<LinkageType>(ILTInternal);
 
 constexpr Op OpForward = static_cast<Op>(IOpForward);
+constexpr Op OpUndefValueInternal = static_cast<Op>(IOpUndefValueInternal);
 constexpr Op OpAliasDomainDeclINTEL = static_cast<Op>(IOpAliasDomainDeclINTEL);
 constexpr Op OpAliasScopeDeclINTEL = static_cast<Op>(IOpAliasScopeDeclINTEL);
 constexpr Op OpAliasScopeListDeclINTEL =
diff --git a/tools/llvm-spirv/llvm-spirv.cpp b/tools/llvm-spirv/llvm-spirv.cpp
index 4529b36..0ba5d1d 100644
--- a/tools/llvm-spirv/llvm-spirv.cpp
+++ b/tools/llvm-spirv/llvm-spirv.cpp
@@ -104,7 +104,9 @@ static cl::opt<VersionNumber> MaxSPIRVVersion(
     cl::values(clEnumValN(VersionNumber::SPIRV_1_0, "1.0", "SPIR-V 1.0"),
                clEnumValN(VersionNumber::SPIRV_1_1, "1.1", "SPIR-V 1.1"),
                clEnumValN(VersionNumber::SPIRV_1_2, "1.2", "SPIR-V 1.2"),
-               clEnumValN(VersionNumber::SPIRV_1_3, "1.3", "SPIR-V 1.3")),
+               clEnumValN(VersionNumber::SPIRV_1_3, "1.3", "SPIR-V 1.3"),
+               clEnumValN(VersionNumber::SPIRV_1_4, "1.4", "SPIR-V 1.4"),
+               clEnumValN(VersionNumber::SPIRV_1_5, "1.5", "SPIR-V 1.5")),
     cl::init(VersionNumber::MaximumVersion));
 
 static cl::list<std::string>
@@ -242,10 +244,11 @@ static int convertLLVMToSPIRV(const SPIRV::TranslatorOpts &Opts) {
   std::string Err;
   bool Success = false;
   if (OutputFile != "-") {
-    std::ofstream OutFile(OutputFile, std::ios::binary);
+    std::error_code EC {};
+    raw_fd_ostream OutFile(OutputFile, EC);
     Success = writeSpirv(M.get(), Opts, OutFile, Err);
   } else {
-    Success = writeSpirv(M.get(), Opts, std::cout, Err);
+    Success = writeSpirv(M.get(), Opts, llvm::outs(), Err);
   }
 
   if (!Success) {
@@ -316,7 +319,7 @@ static int convertSPIRV() {
     }
   }
 
-  auto Action = [&](std::ostream &OFS) {
+  auto Action = [&](llvm::raw_ostream &OFS) {
     std::string Err;
     if (!SPIRV::convertSpirv(IFS, OFS, Err, ToBinary, ToText)) {
       errs() << "Fails to convert SPIR-V : " << Err << '\n';
@@ -326,16 +329,18 @@ static int convertSPIRV() {
   };
 
   if (OutputFile == "-")
-    return Action(std::cout);
+    return Action(llvm::outs());
 
   // Open the output file in binary mode in case we convert text to SPIRV binary
   if (ToBinary) {
-    std::ofstream OFS(OutputFile, std::ios::binary);
+    std::error_code EC;
+    llvm::raw_fd_ostream OFS(OutputFile, EC);
     return Action(OFS);
   }
 
   // Convert SPIRV binary to text
-  std::ofstream OFS(OutputFile);
+  std::error_code EC;
+  llvm::raw_fd_ostream OFS(OutputFile, EC);
   return Action(OFS);
 }
 #endif
