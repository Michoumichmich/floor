diff --git a/include/llvm/CodeGen/AsmPrinter.h b/include/llvm/CodeGen/AsmPrinter.h
index e1c9a14..1c9e06b 100644
--- a/include/llvm/CodeGen/AsmPrinter.h
+++ b/include/llvm/CodeGen/AsmPrinter.h
@@ -232,7 +232,7 @@ public:
   /// requested, it will override the alignment request if required for
   /// correctness.
   ///
-  void EmitAlignment(unsigned NumBits, const GlobalObject *GO = nullptr) const;
+  virtual void EmitAlignment(unsigned NumBits, const GlobalObject *GO = nullptr) const;
 
   /// This method prints the label for the specified MachineBasicBlock, an
   /// alignment (if present) and a comment describing it if appropriate.
@@ -496,7 +496,7 @@ private:
   void EmitVisibility(MCSymbol *Sym, unsigned Visibility,
                       bool IsDefinition = true) const;
 
-  void EmitLinkage(const GlobalValue *GV, MCSymbol *GVSym) const;
+  virtual void EmitLinkage(const GlobalValue *GV, MCSymbol *GVSym) const;
 
   void EmitJumpTableEntry(const MachineJumpTableInfo *MJTI,
                           const MachineBasicBlock *MBB, unsigned uid) const;
diff --git a/include/llvm/InitializePasses.h b/include/llvm/InitializePasses.h
index 02f4259..47103f2 100644
--- a/include/llvm/InitializePasses.h
+++ b/include/llvm/InitializePasses.h
@@ -64,6 +64,7 @@ void initializeTarget(PassRegistry&);
 
 void initializeAAEvalPass(PassRegistry&);
 void initializeAddDiscriminatorsPass(PassRegistry&);
+void initializeAddressSpaceFixPass(PassRegistry&);
 void initializeADCEPass(PassRegistry&);
 void initializeAliasAnalysisAnalysisGroup(PassRegistry&);
 void initializeAliasAnalysisCounterPass(PassRegistry&);
diff --git a/include/llvm/LinkAllPasses.h b/include/llvm/LinkAllPasses.h
index e06560c..6e7d587 100644
--- a/include/llvm/LinkAllPasses.h
+++ b/include/llvm/LinkAllPasses.h
@@ -48,6 +48,7 @@ namespace {
         return;
 
       (void) llvm::createAAEvalPass();
+      (void) llvm::createAddressSpaceFixPass();
       (void) llvm::createAggressiveDCEPass();
       (void) llvm::createAliasAnalysisCounterPass();
       (void) llvm::createAliasDebugger();
diff --git a/include/llvm/Transforms/Scalar.h b/include/llvm/Transforms/Scalar.h
index 413134e..8905464 100644
--- a/include/llvm/Transforms/Scalar.h
+++ b/include/llvm/Transforms/Scalar.h
@@ -30,6 +30,13 @@ class TargetMachine;
 
 //===----------------------------------------------------------------------===//
 //
+// AddressSpaceFix - This pass fixes (intentionally) broken uses of addrspace
+// pointers that should be non-addrspace pointers.
+//
+FunctionPass *createAddressSpaceFixPass();
+
+//===----------------------------------------------------------------------===//
+//
 // ConstantPropagation - A worklist driven constant propagation pass
 //
 FunctionPass *createConstantPropagationPass();
diff --git a/lib/AsmParser/LLParser.cpp b/lib/AsmParser/LLParser.cpp
index ac6e0e5..9e922f8 100644
--- a/lib/AsmParser/LLParser.cpp
+++ b/lib/AsmParser/LLParser.cpp
@@ -2644,10 +2644,10 @@ bool LLParser::ParseValID(ValID &ID, PerFunctionState *PFS) {
         ParseType(DestTy) ||
         ParseToken(lltok::rparen, "expected ')' at end of constantexpr cast"))
       return true;
-    if (!CastInst::castIsValid((Instruction::CastOps)Opc, SrcVal, DestTy))
+    /*if (!CastInst::castIsValid((Instruction::CastOps)Opc, SrcVal, DestTy))
       return Error(ID.Loc, "invalid cast opcode for cast from '" +
                    getTypeString(SrcVal->getType()) + "' to '" +
-                   getTypeString(DestTy) + "'");
+                   getTypeString(DestTy) + "'");*/
     ID.ConstantVal = ConstantExpr::getCast((Instruction::CastOps)Opc,
                                                  SrcVal, DestTy);
     ID.Kind = ValID::t_Constant;
@@ -3971,12 +3971,12 @@ bool LLParser::ParseCast(Instruction *&Inst, PerFunctionState &PFS,
       ParseType(DestTy))
     return true;
 
-  if (!CastInst::castIsValid((Instruction::CastOps)Opc, Op, DestTy)) {
+  /*if (!CastInst::castIsValid((Instruction::CastOps)Opc, Op, DestTy)) {
     CastInst::castIsValid((Instruction::CastOps)Opc, Op, DestTy);
     return Error(Loc, "invalid cast opcode for cast from '" +
                  getTypeString(Op->getType()) + "' to '" +
                  getTypeString(DestTy) + "'");
-  }
+  }*/
   Inst = CastInst::Create((Instruction::CastOps)Opc, Op, DestTy);
   return false;
 }
diff --git a/lib/IR/Constants.cpp b/lib/IR/Constants.cpp
index b815936..da8596b 100644
--- a/lib/IR/Constants.cpp
+++ b/lib/IR/Constants.cpp
@@ -1494,7 +1494,8 @@ Constant *ConstantExpr::getCast(unsigned oc, Constant *C, Type *Ty) {
   Instruction::CastOps opc = Instruction::CastOps(oc);
   assert(Instruction::isCast(opc) && "opcode out of range");
   assert(C && Ty && "Null arguments to getCast");
-  assert(CastInst::castIsValid(opc, C, Ty) && "Invalid constantexpr cast!");
+  // TODO: fix this!
+  //assert(CastInst::castIsValid(opc, C, Ty) && "Invalid constantexpr cast!");
 
   switch (opc) {
   default:
@@ -1719,8 +1720,9 @@ Constant *ConstantExpr::getIntToPtr(Constant *C, Type *DstTy) {
 }
 
 Constant *ConstantExpr::getBitCast(Constant *C, Type *DstTy) {
-  assert(CastInst::castIsValid(Instruction::BitCast, C, DstTy) &&
-         "Invalid constantexpr bitcast!");
+  // TODO: fix this! fails in AddAppleCLKernelAnnotation
+  //assert(CastInst::castIsValid(Instruction::BitCast, C, DstTy) &&
+  //     "Invalid constantexpr bitcast!");
 
   // It is common to ask for a bitcast of a value to its own type, handle this
   // speedily.
diff --git a/lib/IR/Instructions.cpp b/lib/IR/Instructions.cpp
index 9553252..5047ab2 100644
--- a/lib/IR/Instructions.cpp
+++ b/lib/IR/Instructions.cpp
@@ -275,11 +275,13 @@ void CallInst::init(Value *Func, ArrayRef<Value *> Args, const Twine &NameStr) {
           (FTy->isVarArg() && Args.size() > FTy->getNumParams())) &&
          "Calling a function with bad signature!");
 
+#if 0 // TODO: disabled for now, need to ignore address space mismatches
   for (unsigned i = 0; i != Args.size(); ++i)
     assert((i >= FTy->getNumParams() || 
             FTy->getParamType(i) == Args[i]->getType()) &&
            "Calling a function with a bad signature!");
 #endif
+#endif
 
   std::copy(Args.begin(), Args.end(), op_begin());
   setName(NameStr);
diff --git a/lib/IR/Verifier.cpp b/lib/IR/Verifier.cpp
index 9cf911b..8d61d2b 100644
--- a/lib/IR/Verifier.cpp
+++ b/lib/IR/Verifier.cpp
@@ -1542,10 +1542,17 @@ void Verifier::VerifyCallSite(CallSite CS) {
             "Incorrect number of arguments passed to called function!", I);
 
   // Verify that all arguments to the call match the function type.
-  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i)
-    Assert3(CS.getArgument(i)->getType() == FTy->getParamType(i),
+  // Note that address space mismatches will be fixed later.
+  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i) {
+    Assert3(CS.getArgument(i)->getType() == FTy->getParamType(i) ||
+            (CS.getArgument(i)->getType()->isPointerTy() &&
+             FTy->getParamType(i)->isPointerTy() &&
+             PointerType::get(cast<PointerType>(CS.getArgument(i)->getType())->getElementType(),
+                              FTy->getParamType(i)->getPointerAddressSpace()) ==
+             FTy->getParamType(i)),
             "Call parameter type does not match function signature!",
             CS.getArgument(i), FTy->getParamType(i), I);
+  }
 
   AttributeSet Attrs = CS.getAttributes();
 
diff --git a/lib/Target/NVPTX/NVPTX.td b/lib/Target/NVPTX/NVPTX.td
index 93fabf6..2dfb759 100644
--- a/lib/Target/NVPTX/NVPTX.td
+++ b/lib/Target/NVPTX/NVPTX.td
@@ -32,10 +32,18 @@ def SM21 : SubtargetFeature<"sm_21", "SmVersion", "21",
                             "Target SM 2.1">;
 def SM30 : SubtargetFeature<"sm_30", "SmVersion", "30",
                             "Target SM 3.0">;
+def SM32 : SubtargetFeature<"sm_32", "SmVersion", "32",
+                            "Target SM 3.2">;
 def SM35 : SubtargetFeature<"sm_35", "SmVersion", "35",
                             "Target SM 3.5">;
+def SM37 : SubtargetFeature<"sm_37", "SmVersion", "37",
+                            "Target SM 3.7">;
 def SM50 : SubtargetFeature<"sm_50", "SmVersion", "50",
                             "Target SM 5.0">;
+def SM52 : SubtargetFeature<"sm_52", "SmVersion", "52",
+                            "Target SM 5.2">;
+def SM53 : SubtargetFeature<"sm_53", "SmVersion", "53",
+                            "Target SM 5.3">;
 
 // PTX Versions
 def PTX30 : SubtargetFeature<"ptx30", "PTXVersion", "30",
@@ -46,6 +54,10 @@ def PTX32 : SubtargetFeature<"ptx32", "PTXVersion", "32",
                              "Use PTX version 3.2">;
 def PTX40 : SubtargetFeature<"ptx40", "PTXVersion", "40",
                              "Use PTX version 4.0">;
+def PTX41 : SubtargetFeature<"ptx41", "PTXVersion", "41",
+                             "Use PTX version 4.1">;
+def PTX42 : SubtargetFeature<"ptx42", "PTXVersion", "42",
+                             "Use PTX version 4.2">;
 
 //===----------------------------------------------------------------------===//
 // NVPTX supported processors.
@@ -57,8 +69,12 @@ class Proc<string Name, list<SubtargetFeature> Features>
 def : Proc<"sm_20", [SM20]>;
 def : Proc<"sm_21", [SM21]>;
 def : Proc<"sm_30", [SM30]>;
+def : Proc<"sm_32", [SM32, PTX40]>;
 def : Proc<"sm_35", [SM35]>;
-def : Proc<"sm_50", [SM50]>;
+def : Proc<"sm_37", [SM37, PTX41]>;
+def : Proc<"sm_50", [SM50, PTX40]>;
+def : Proc<"sm_52", [SM52, PTX41]>;
+def : Proc<"sm_53", [SM53, PTX42]>;
 
 
 def NVPTXInstrInfo : InstrInfo {
diff --git a/lib/Target/NVPTX/NVPTXAsmPrinter.h b/lib/Target/NVPTX/NVPTXAsmPrinter.h
index a9f9bdd..bf44862 100644
--- a/lib/Target/NVPTX/NVPTXAsmPrinter.h
+++ b/lib/Target/NVPTX/NVPTXAsmPrinter.h
@@ -202,6 +202,12 @@ private:
   void EmitFunctionBodyEnd() override;
   void emitImplicitDef(const MachineInstr *MI) const override;
 
+  /// superfluous function header fix: nop these three functions
+  void EmitGlobalVariable(const GlobalVariable *GV) override {}
+  void EmitLinkage(const GlobalValue *GV, MCSymbol *GVSym) const override {}
+  void EmitAlignment(unsigned NumBits, const GlobalObject *GO = nullptr) const override {}
+  ///
+
   void EmitInstruction(const MachineInstr *) override;
   void lowerToMCInst(const MachineInstr *MI, MCInst &OutMI);
   bool lowerOperand(const MachineOperand &MO, MCOperand &MCOp);
diff --git a/lib/Target/NVPTX/NVPTXInstrInfo.td b/lib/Target/NVPTX/NVPTXInstrInfo.td
index 9900b8c..4879b84 100644
--- a/lib/Target/NVPTX/NVPTXInstrInfo.td
+++ b/lib/Target/NVPTX/NVPTXInstrInfo.td
@@ -1659,12 +1659,12 @@ multiclass FSET_FORMAT<PatFrag OpNode, PatLeaf Mode, PatLeaf ModeFTZ> {
             (SET_f64ir fpimm:$a, Float64Regs:$b, Mode)>;
 }
 
-defm FSetGT : FSET_FORMAT<setogt, CmpGT, CmpGT_FTZ>;
-defm FSetLT : FSET_FORMAT<setolt, CmpLT, CmpLT_FTZ>;
-defm FSetGE : FSET_FORMAT<setoge, CmpGE, CmpGE_FTZ>;
-defm FSetLE : FSET_FORMAT<setole, CmpLE, CmpLE_FTZ>;
-defm FSetEQ : FSET_FORMAT<setoeq, CmpEQ, CmpEQ_FTZ>;
-defm FSetNE : FSET_FORMAT<setone, CmpNE, CmpNE_FTZ>;
+defm FSetOGT : FSET_FORMAT<setogt, CmpGT, CmpGT_FTZ>;
+defm FSetOLT : FSET_FORMAT<setolt, CmpLT, CmpLT_FTZ>;
+defm FSetOGE : FSET_FORMAT<setoge, CmpGE, CmpGE_FTZ>;
+defm FSetOLE : FSET_FORMAT<setole, CmpLE, CmpLE_FTZ>;
+defm FSetOEQ : FSET_FORMAT<setoeq, CmpEQ, CmpEQ_FTZ>;
+defm FSetONE : FSET_FORMAT<setone, CmpNE, CmpNE_FTZ>;
 
 defm FSetUGT : FSET_FORMAT<setugt, CmpGTU, CmpGTU_FTZ>;
 defm FSetULT : FSET_FORMAT<setult, CmpLTU, CmpLTU_FTZ>;
@@ -1673,6 +1673,13 @@ defm FSetULE : FSET_FORMAT<setule, CmpLEU, CmpLEU_FTZ>;
 defm FSetUEQ : FSET_FORMAT<setueq, CmpEQU, CmpEQU_FTZ>;
 defm FSetUNE : FSET_FORMAT<setune, CmpNEU, CmpNEU_FTZ>;
 
+defm FSetGT : FSET_FORMAT<setgt, CmpGT, CmpGT_FTZ>;
+defm FSetLT : FSET_FORMAT<setlt, CmpLT, CmpLT_FTZ>;
+defm FSetGE : FSET_FORMAT<setge, CmpGE, CmpGE_FTZ>;
+defm FSetLE : FSET_FORMAT<setle, CmpLE, CmpLE_FTZ>;
+defm FSetEQ : FSET_FORMAT<seteq, CmpEQ, CmpEQ_FTZ>;
+defm FSetNE : FSET_FORMAT<setne, CmpNE, CmpNE_FTZ>;
+
 defm FSetNUM : FSET_FORMAT<seto, CmpNUM, CmpNUM_FTZ>;
 defm FSetNAN : FSET_FORMAT<setuo, CmpNAN, CmpNAN_FTZ>;
 
diff --git a/lib/Target/NVPTX/NVPTXSubtarget.cpp b/lib/Target/NVPTX/NVPTXSubtarget.cpp
index d5cded2..2e0ca79 100644
--- a/lib/Target/NVPTX/NVPTXSubtarget.cpp
+++ b/lib/Target/NVPTX/NVPTXSubtarget.cpp
@@ -45,9 +45,9 @@ NVPTXSubtarget &NVPTXSubtarget::initializeSubtargetDependencies(StringRef CPU,
 
   ParseSubtargetFeatures(TargetName, FS);
 
-  // Set default to PTX 3.2 (CUDA 5.5)
+  // Set default to PTX 4.0
   if (PTXVersion == 0) {
-    PTXVersion = 32;
+    PTXVersion = 40;
   }
 
   return *this;
diff --git a/lib/Transforms/Scalar/AddressSpaceFix.cpp b/lib/Transforms/Scalar/AddressSpaceFix.cpp
new file mode 100644
index 0000000..db4605a
--- /dev/null
+++ b/lib/Transforms/Scalar/AddressSpaceFix.cpp
@@ -0,0 +1,183 @@
+//===- AddressSpaceFix.cpp - Example code from "Writing an LLVM Pass" -----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements an address space fixer for OpenCL/SPIR (and related).
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/ADT/Statistic.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SetVector.h"
+#include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/IR/CFG.h"
+#include "llvm/IR/CallSite.h"
+#include "llvm/IR/CallingConv.h"
+#include "llvm/IR/ConstantRange.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/IR/DebugInfo.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/Dominators.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/InlineAsm.h"
+#include "llvm/IR/InstIterator.h"
+#include "llvm/IR/InstVisitor.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/Metadata.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/LegacyPassManager.h"
+#include "llvm/Pass.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Transforms/IPO/PassManagerBuilder.h"
+#include "llvm/Transforms/Scalar.h"
+#include <algorithm>
+#include <cstdarg>
+#include <memory>
+using namespace llvm;
+
+#define DEBUG_TYPE "AddressSpaceFix"
+
+#define DBG(x)
+//#define DBG(x) x
+
+namespace {
+	// AddressSpaceFix
+	struct AddressSpaceFix : public FunctionPass, InstVisitor<AddressSpaceFix> {
+		friend class InstVisitor<AddressSpaceFix>;
+		
+		static char ID; // Pass identification, replacement for typeid
+		
+		std::shared_ptr<llvm::IRBuilder<>> builder;
+		
+		Module* M { nullptr };
+		LLVMContext* ctx { nullptr };
+		Function* func { nullptr };
+		Instruction* alloca_insert { nullptr };
+		bool was_modified { false };
+		
+		AddressSpaceFix() : FunctionPass(ID) {
+			initializeAddressSpaceFixPass(*PassRegistry::getPassRegistry());
+		}
+		
+		bool runOnFunction(Function &F) override {
+			// exit if empty function
+			if (F.empty()) return false;
+			
+			//
+			M = F.getParent();
+			ctx = &M->getContext();
+			func = &F;
+			builder = std::make_shared<llvm::IRBuilder<>>(*ctx);
+			
+			// find first non-alloca instruction in the entry block of the function
+			// -> this will be the insert position for new alloca instructions
+			for(auto& instr : *F.begin()) {
+				if(!isa<AllocaInst>(instr)) {
+					alloca_insert = &instr;
+					break;
+				}
+			}
+			
+			// visit everything in this function
+			was_modified = false; // reset every time
+			visit(F);
+			if(was_modified) {
+				DBG(errs() << "!! modified function: ";)
+				DBG(errs().write_escaped(F.getName()) << '\n';)
+			}
+			return was_modified;
+		}
+		
+		// InstVisitor overrides...
+		using InstVisitor<AddressSpaceFix>::visit;
+		void visit(Instruction& I) {
+			InstVisitor<AddressSpaceFix>::visit(I);
+		}
+		
+		void visitCallInst(CallInst& CI) {
+			CallSite CS { &CI };
+			PointerType* FPTy = cast<PointerType>(CS.getCalledValue()->getType());
+			FunctionType* FTy = cast<FunctionType>(FPTy->getElementType());
+			
+			for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i) {
+				// check if there is a type mismatch
+				if(CS.getArgument(i)->getType() != FTy->getParamType(i)) {
+					// both types must be pointers
+					auto called_arg_type = CS.getArgument(i)->getType();
+					auto expected_arg_type = FTy->getParamType(i);
+					if(!called_arg_type->isPointerTy() ||
+					   !expected_arg_type->isPointerTy()) {
+						// emit original verifier assertion (TODO: fix it there!)
+						assert(false && "Call parameter type does not match function signature!");
+						continue;
+					}
+					
+					// check if the mismatch is _only_ due to the addrspace
+					DBG(errs() << "\t>> call, both types are ptrs: ";)
+					DBG(errs() << called_arg_type->getPointerAddressSpace() << ", ";)
+					DBG(errs() << expected_arg_type->getPointerAddressSpace() << "\n";)
+					auto as_ptr = cast<PointerType>(called_arg_type);
+					if(PointerType::get(as_ptr->getElementType(),
+										expected_arg_type->getPointerAddressSpace()) !=
+					   expected_arg_type) {
+						// emit original verifier assertion (TODO: fix it there!)
+						assert(false && "Call parameter type does not match function signature!");
+						continue;
+					}
+					// else: yup, only addrspace mismatch
+					DBG(errs() << "\tonly addrspace mismatch!\n";)
+					DBG(errs() << "\treplacing arg #" << i << "!\n";)
+					
+					// fix it:
+					//  * create a temporary object (of the element/pointee type of the address space pointer)
+					//  * load data from the address space pointer to the temp object
+					//  * replace the respective call operand/argument with a pointer to the temp object
+					//  * after the call, store data back to the address space pointer from the temp object
+					
+					// TODO: only do this if param address space is 0?
+					// TODO: if const, don't write back
+					// TODO: handle alignment?
+					
+					builder->SetInsertPoint(alloca_insert); // insert alloca at function entry
+					auto tmp = builder->CreateAlloca(as_ptr->getElementType(),
+													 // what about arrays?
+													 nullptr,
+													 // give it a nice name
+													 "asfixtmp");
+					
+					builder->SetInsertPoint(&CI); // insert load before call
+					auto src = CS.getArgument(i);
+					builder->CreateStore(builder->CreateLoad(src), tmp);
+					
+					CS.setArgument(i, tmp);
+					
+					builder->SetInsertPoint(CI.getNextNode()); // insert store after call
+					builder->CreateStore(builder->CreateLoad(tmp), src);
+					
+					// done, signal that the function was modified
+					was_modified = true;
+				}
+			}
+		}
+	};
+}
+
+char AddressSpaceFix::ID = 0;
+INITIALIZE_PASS(AddressSpaceFix, "AddressSpaceFix", "AddressSpaceFix Pass", false, false)
+
+FunctionPass *llvm::createAddressSpaceFixPass() {
+	return new AddressSpaceFix();
+}
diff --git a/lib/Transforms/Scalar/CMakeLists.txt b/lib/Transforms/Scalar/CMakeLists.txt
index 261ddda..7eed586 100644
--- a/lib/Transforms/Scalar/CMakeLists.txt
+++ b/lib/Transforms/Scalar/CMakeLists.txt
@@ -1,4 +1,5 @@
 add_llvm_library(LLVMScalarOpts
+  AddressSpaceFix.cpp
   ADCE.cpp
   ConstantHoisting.cpp
   ConstantProp.cpp
diff --git a/lib/Transforms/Scalar/Scalar.cpp b/lib/Transforms/Scalar/Scalar.cpp
index de724d4..831b1bb 100644
--- a/lib/Transforms/Scalar/Scalar.cpp
+++ b/lib/Transforms/Scalar/Scalar.cpp
@@ -73,6 +73,10 @@ void LLVMInitializeScalarOpts(LLVMPassRegistryRef R) {
   initializeScalarOpts(*unwrap(R));
 }
 
+void LLVMAddAddressSpaceFixPass(LLVMPassManagerRef PM) {
+  unwrap(PM)->add(createAddressSpaceFixPass());
+}
+
 void LLVMAddAggressiveDCEPass(LLVMPassManagerRef PM) {
   unwrap(PM)->add(createAggressiveDCEPass());
 }
diff --git a/tools/clang/include/clang/AST/ASTContext.h b/tools/clang/include/clang/AST/ASTContext.h
index 8134f6b..f0b0f86 100644
--- a/tools/clang/include/clang/AST/ASTContext.h
+++ b/tools/clang/include/clang/AST/ASTContext.h
@@ -789,7 +789,7 @@ public:
   CanQualType ObjCBuiltinIdTy, ObjCBuiltinClassTy, ObjCBuiltinSelTy;
   CanQualType ObjCBuiltinBoolTy;
   CanQualType OCLImage1dTy, OCLImage1dArrayTy, OCLImage1dBufferTy;
-  CanQualType OCLImage2dTy, OCLImage2dArrayTy;
+  CanQualType OCLImage2dTy, OCLImage2dArrayTy, OCLImage2dDepthTy, OCLImage2dArrayDepthTy, OCLImage2dMSAATy, OCLImage2dArrayMSAATy, OCLImage2dMSAADepthTy, OCLImage2dArrayMSAADepthTy;
   CanQualType OCLImage3dTy;
   CanQualType OCLSamplerTy, OCLEventTy;
 
diff --git a/tools/clang/include/clang/AST/BuiltinTypes.def b/tools/clang/include/clang/AST/BuiltinTypes.def
index 488cace..f68cb37 100644
--- a/tools/clang/include/clang/AST/BuiltinTypes.def
+++ b/tools/clang/include/clang/AST/BuiltinTypes.def
@@ -160,6 +160,12 @@ BUILTIN_TYPE(OCLImage1dArray, OCLImage1dArrayTy)
 BUILTIN_TYPE(OCLImage1dBuffer, OCLImage1dBufferTy)
 BUILTIN_TYPE(OCLImage2d, OCLImage2dTy)
 BUILTIN_TYPE(OCLImage2dArray, OCLImage2dArrayTy)
+BUILTIN_TYPE(OCLImage2dDepth, OCLImage2dDepthTy)
+BUILTIN_TYPE(OCLImage2dArrayDepth, OCLImage2dArrayDepthTy)
+BUILTIN_TYPE(OCLImage2dMSAA, OCLImage2dMSAATy)
+BUILTIN_TYPE(OCLImage2dArrayMSAA, OCLImage2dArrayMSAATy)
+BUILTIN_TYPE(OCLImage2dMSAADepth, OCLImage2dMSAADepthTy)
+BUILTIN_TYPE(OCLImage2dArrayMSAADepth, OCLImage2dArrayMSAADepthTy)
 BUILTIN_TYPE(OCLImage3d, OCLImage3dTy)
 
 // OpenCL sampler_t.
diff --git a/tools/clang/include/clang/AST/Type.h b/tools/clang/include/clang/AST/Type.h
index 09862e4..ddc236c 100644
--- a/tools/clang/include/clang/AST/Type.h
+++ b/tools/clang/include/clang/AST/Type.h
@@ -1575,6 +1575,12 @@ public:
   bool isImage1dBufferT() const;                // OpenCL image1d_buffer_t
   bool isImage2dT() const;                      // OpenCL image2d_t
   bool isImage2dArrayT() const;                 // OpenCL image2d_array_t
+  bool isImage2dDepthT() const;                 // OpenCL image2d_depth_t
+  bool isImage2dArrayDepthT() const;            // OpenCL image2d_array_depth_t
+  bool isImage2dMSAAT() const;                  // OpenCL image2d_msaa_t
+  bool isImage2dArrayMSAAT() const;             // OpenCL image2d_array_msaa_t
+  bool isImage2dMSAADepthT() const;             // OpenCL image2d_msaa_depth_t
+  bool isImage2dArrayMSAADepthT() const;        // OpenCL image2d_array_msaa_depth_t
   bool isImage3dT() const;                      // OpenCL image3d_t
 
   bool isImageType() const;                     // Any OpenCL image type
@@ -5008,6 +5014,30 @@ inline bool Type::isImage2dArrayT() const {
   return isSpecificBuiltinType(BuiltinType::OCLImage2dArray);
 }
 
+inline bool Type::isImage2dDepthT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dDepth);
+}
+
+inline bool Type::isImage2dArrayDepthT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayDepth);
+}
+
+inline bool Type::isImage2dMSAAT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dMSAA);
+}
+
+inline bool Type::isImage2dArrayMSAAT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayMSAA);
+}
+
+inline bool Type::isImage2dMSAADepthT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dMSAADepth);
+}
+
+inline bool Type::isImage2dArrayMSAADepthT() const {
+  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayMSAADepth);
+}
+
 inline bool Type::isImage3dT() const {
   return isSpecificBuiltinType(BuiltinType::OCLImage3d);
 }
@@ -5023,6 +5053,9 @@ inline bool Type::isEventT() const {
 inline bool Type::isImageType() const {
   return isImage3dT() ||
          isImage2dT() || isImage2dArrayT() ||
+         isImage2dDepthT() || isImage2dArrayDepthT() ||
+         isImage2dMSAAT() || isImage2dArrayMSAAT() ||
+         isImage2dMSAADepthT() || isImage2dArrayMSAADepthT() ||
          isImage1dT() || isImage1dArrayT() || isImage1dBufferT();
 }
 
diff --git a/tools/clang/include/clang/Basic/Attr.td b/tools/clang/include/clang/Basic/Attr.td
index 704a375..e6bc378 100644
--- a/tools/clang/include/clang/Basic/Attr.td
+++ b/tools/clang/include/clang/Basic/Attr.td
@@ -354,6 +354,25 @@ def Aligned : InheritableAttr {
   let Documentation = [Undocumented];
 }
 
+def AlignValue : Attr {
+  let Spellings = [
+    // Unfortunately, this is semantically an assertion, not a
+    // directive (something else must ensure the alignment), so
+    // aligned_value is a probably a better name. We might want
+    // to add an aligned_value spelling in the future (and a
+    // corresponding C++ attribute), but this can be done later
+    // once we decide if we also want them to have
+    // slightly-different semantics than Intel's align_value.
+    GNU<"align_value">
+    // Intel's compiler on Windows also supports:
+    // , Declspec<"align_value">
+  ];
+  let Args = [ExprArgument<"Alignment">];
+  let Subjects = SubjectList<[Var, TypedefName], WarnDiag,
+                             "ExpectedVariableOrTypedef">;
+  let Documentation = [AlignValueDocs];
+}
+
 def AlignMac68k : InheritableAttr {
   // This attribute has no spellings as it is only ever created implicitly.
   let Spellings = [];
@@ -514,7 +533,7 @@ def Constructor : InheritableAttr {
 }
 
 def CUDAConstant : InheritableAttr {
-  let Spellings = [GNU<"constant">];
+  let Spellings = [GNU<"constant">, GNU<"cuda_constant">];
   let Subjects = SubjectList<[Var]>;
   let LangOpts = [CUDA];
   let Documentation = [Undocumented];
@@ -528,7 +547,7 @@ def CUDADevice : InheritableAttr {
 }
 
 def CUDAGlobal : InheritableAttr {
-  let Spellings = [GNU<"global">];
+  let Spellings = [GNU<"global">, GNU<"cuda_kernel">];
   let Subjects = SubjectList<[Function]>;
   let LangOpts = [CUDA];
   let Documentation = [Undocumented];
@@ -554,7 +573,7 @@ def CUDALaunchBounds : InheritableAttr {
 }
 
 def CUDAShared : InheritableAttr {
-  let Spellings = [GNU<"shared">];
+  let Spellings = [GNU<"shared">, GNU<"cuda_local">];
   let Subjects = SubjectList<[Var]>;
   let LangOpts = [CUDA];
   let Documentation = [Undocumented];
@@ -574,7 +593,7 @@ def CXX11NoReturn : InheritableAttr {
 }
 
 def OpenCLKernel : InheritableAttr {
-  let Spellings = [Keyword<"__kernel">, Keyword<"kernel">];
+  let Spellings = [Keyword<"__kernel">, GNU<"opencl_kernel">];
   let Subjects = SubjectList<[Function], ErrorDiag>;
   let Documentation = [Undocumented];
 }
@@ -582,36 +601,39 @@ def OpenCLKernel : InheritableAttr {
 // This attribute is both a type attribute, and a declaration attribute (for
 // parameter variables).
 def OpenCLImageAccess : Attr {
-  let Spellings = [Keyword<"__read_only">, Keyword<"read_only">,
-                   Keyword<"__write_only">, Keyword<"write_only">,
-                   Keyword<"__read_write">, Keyword<"read_write">];
-  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
+  let Spellings = [Keyword<"__read_only">, GNU<"image_read_only">, CXX11<"","image_read_only">,
+                   Keyword<"__write_only">, GNU<"image_write_only">, CXX11<"","image_write_only">,
+                   Keyword<"__read_write">, GNU<"image_read_write">, CXX11<"","image_read_write">];
+  //let Subjects = SubjectList<[ParmVar], ErrorDiag>;
   let Accessors = [Accessor<"isReadOnly", [Keyword<"__read_only">,
-                                           Keyword<"read_only">]>,
+										   GNU<"image_read_only">,
+										   CXX11<"","image_read_only">]>,
                    Accessor<"isReadWrite", [Keyword<"__read_write">,
-                                            Keyword<"read_write">]>,
+											GNU<"image_read_write">,
+											CXX11<"","image_read_write">]>,
                    Accessor<"isWriteOnly", [Keyword<"__write_only">,
-                                            Keyword<"write_only">]>];
+											GNU<"image_write_only">,
+											CXX11<"","image_write_only">]>];
   let Documentation = [Undocumented];
 }
 
 def OpenCLPrivateAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__private">, Keyword<"private">];
+  let Spellings = [Keyword<"__private">, GNU<"opencl_private">];
   let Documentation = [Undocumented];
 }
 
 def OpenCLGlobalAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__global">, Keyword<"global">];
+  let Spellings = [Keyword<"__global">, GNU<"opencl_global">];
   let Documentation = [Undocumented];
 }
 
 def OpenCLLocalAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__local">, Keyword<"local">];
+  let Spellings = [Keyword<"__local">, GNU<"opencl_local">];
   let Documentation = [Undocumented];
 }
 
 def OpenCLConstantAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__constant">, Keyword<"constant">];
+  let Spellings = [Keyword<"__constant">, GNU<"opencl_constant">];
   let Documentation = [Undocumented];
 }
 
diff --git a/tools/clang/include/clang/Basic/AttrDocs.td b/tools/clang/include/clang/Basic/AttrDocs.td
index e6d6a33..3e7bdc1 100644
--- a/tools/clang/include/clang/Basic/AttrDocs.td
+++ b/tools/clang/include/clang/Basic/AttrDocs.td
@@ -987,6 +987,26 @@ Clang implements two kinds of checks with this attribute.
   }];
 }
 
+def AlignValueDocs : Documentation {
+  let Category = DocCatType;
+  let Content = [{
+The align_value attribute can be added to the typedef of a pointer type or the
+declaration of a variable of pointer or reference type. It specifies that the
+pointer will point to, or the reference will bind to, only objects with at
+least the provided alignment. This alignment value must be some positive power
+of 2.
+
+   .. code-block:: c
+
+     typedef double * aligned_double_ptr __attribute__((align_value(64)));
+     void foo(double & x  __attribute__((align_value(128)),
+              aligned_double_ptr y) { ... }
+
+If the pointer value does not have the specified alignment at runtime, the
+behavior of the program is undefined.
+  }];
+}
+
 def MSInheritanceDocs : Documentation {
   let Category = DocCatType;
   let Heading = "__single_inhertiance, __multiple_inheritance, __virtual_inheritance";
diff --git a/tools/clang/include/clang/Basic/Builtins.def b/tools/clang/include/clang/Basic/Builtins.def
index e705382..8d81d77 100644
--- a/tools/clang/include/clang/Basic/Builtins.def
+++ b/tools/clang/include/clang/Basic/Builtins.def
@@ -1210,6 +1210,10 @@ BUILTIN(__builtin_addressof, "v*v&", "nct")
 BUILTIN(__builtin_operator_new, "v*z", "c")
 BUILTIN(__builtin_operator_delete, "vv*", "n")
 
+// floor builtins.
+BUILTIN(__builtin_image_type_compare, "i.", "nctu")
+BUILTIN(__builtin_image_type_extract, "i.", "nctu")
+
 #undef BUILTIN
 #undef LIBBUILTIN
 #undef LANGBUILTIN
diff --git a/tools/clang/include/clang/Basic/DiagnosticSemaKinds.td b/tools/clang/include/clang/Basic/DiagnosticSemaKinds.td
index 1665a45..3778e80 100644
--- a/tools/clang/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/tools/clang/include/clang/Basic/DiagnosticSemaKinds.td
@@ -1897,8 +1897,12 @@ def err_attribute_bad_neon_vector_size : Error<
   "Neon vector size must be 64 or 128 bits">;
 def err_attribute_unsupported : Error<
   "%0 attribute is not supported for this target">;
+// The err_*_attribute_argument_not_int are seperate because they're used by
+// VerifyIntegerConstantExpression.
 def err_aligned_attribute_argument_not_int : Error<
   "'aligned' attribute requires integer constant">;
+def err_align_value_attribute_argument_not_int : Error<
+  "'align_value' attribute requires integer constant">;
 def err_alignas_attribute_wrong_decl_type : Error<
   "%0 attribute cannot be applied to a %select{function parameter|"
   "variable with 'register' storage class|'catch' variable|bit-field}1">;
@@ -1934,6 +1938,9 @@ def err_attribute_pointers_only : Error<warn_attribute_pointers_only.Text>;
 def warn_attribute_return_pointers_only : Warning<
   "%0 attribute only applies to return values that are pointers">,
   InGroup<IgnoredAttributes>;
+def warn_attribute_pointer_or_reference_only : Warning<
+  "%0 attribute only applies to a pointer or reference (%1 is invalid)">,
+  InGroup<IgnoredAttributes>;
 def err_attribute_no_member_pointers : Error<
   "%0 attribute cannot be used with pointers to members">;
 def err_attribute_invalid_implicit_this_argument : Error<
@@ -2054,6 +2061,9 @@ def err_no_accessor_for_property : Error<
 def error_cannot_find_suitable_accessor : Error<
   "cannot find suitable %select{getter|setter}0 for property %1">;
 
+def err_alignment_not_power_of_two : Error<
+  "requested alignment is not a power of 2">;
+
 def err_attribute_aligned_not_power_of_two : Error<
   "requested alignment is not a power of 2">;
 def err_attribute_aligned_too_great : Error<
@@ -2166,7 +2176,7 @@ def warn_attribute_wrong_decl_type : Warning<
   "functions, methods and blocks|functions, methods, and classes|"
   "functions, methods, and parameters|classes|variables|methods|"
   "variables, functions and labels|fields and global variables|structs|"
-  "variables, functions and tag types|thread-local variables|"
+  "variables and typedefs|thread-local variables|"
   "variables and fields|variables, data members and tag types|"
   "types and namespaces|Objective-C interfaces|methods and properties|"
   "struct or union|struct, union or class|types|"
diff --git a/tools/clang/include/clang/Basic/LangOptions.h b/tools/clang/include/clang/Basic/LangOptions.h
index 9bffc7c..8fbc316 100644
--- a/tools/clang/include/clang/Basic/LangOptions.h
+++ b/tools/clang/include/clang/Basic/LangOptions.h
@@ -20,6 +20,7 @@
 #include "clang/Basic/ObjCRuntime.h"
 #include "clang/Basic/Visibility.h"
 #include <string>
+#include <array>
 
 namespace clang {
 
@@ -74,6 +75,9 @@ public:
 
   enum AddrSpaceMapMangling { ASMM_Target, ASMM_On, ASMM_Off };
 
+  std::array<uint32_t, 3> metal_version {{ 1, 6, 0 }};
+  std::array<uint32_t, 3> metal_language_version {{ 1, 0, 0 }};
+
 public:
   clang::ObjCRuntime ObjCRuntime;
 
diff --git a/tools/clang/include/clang/Basic/TokenKinds.def b/tools/clang/include/clang/Basic/TokenKinds.def
index 5d08833..52d3d3e 100644
--- a/tools/clang/include/clang/Basic/TokenKinds.def
+++ b/tools/clang/include/clang/Basic/TokenKinds.def
@@ -461,27 +461,19 @@ KEYWORD(__forceinline               , KEYMS)
 KEYWORD(__unaligned                 , KEYMS)
 
 // OpenCL address space qualifiers
-KEYWORD(__global                    , KEYOPENCL)
-KEYWORD(__local                     , KEYOPENCL)
-KEYWORD(__constant                  , KEYOPENCL)
-KEYWORD(__private                   , KEYOPENCL)
-ALIAS("global", __global            , KEYOPENCL)
-ALIAS("local", __local              , KEYOPENCL)
-ALIAS("constant", __constant        , KEYOPENCL)
-ALIAS("private", __private          , KEYOPENCL)
+KEYWORD(__global                    , KEYCXX|KEYOPENCL)
+KEYWORD(__local                     , KEYCXX|KEYOPENCL)
+KEYWORD(__constant                  , KEYCXX|KEYOPENCL)
+KEYWORD(__private                   , KEYCXX|KEYOPENCL)
 // OpenCL function qualifiers
-KEYWORD(__kernel                    , KEYOPENCL)
-ALIAS("kernel", __kernel            , KEYOPENCL)
+KEYWORD(__kernel                    , KEYCXX|KEYOPENCL)
 // OpenCL access qualifiers
-KEYWORD(__read_only                 , KEYOPENCL)
-KEYWORD(__write_only                , KEYOPENCL)
-KEYWORD(__read_write                , KEYOPENCL)
-ALIAS("read_only", __read_only      , KEYOPENCL)
-ALIAS("write_only", __write_only    , KEYOPENCL)
-ALIAS("read_write", __read_write    , KEYOPENCL)
+KEYWORD(__read_only                 , KEYCXX|KEYOPENCL)
+KEYWORD(__write_only                , KEYCXX|KEYOPENCL)
+KEYWORD(__read_write                , KEYCXX|KEYOPENCL)
 // OpenCL builtins
-KEYWORD(__builtin_astype            , KEYOPENCL)
-KEYWORD(vec_step                    , KEYOPENCL|KEYALTIVEC)
+KEYWORD(__builtin_astype            , KEYCXX|KEYOPENCL)
+KEYWORD(vec_step                    , KEYCXX|KEYOPENCL|KEYALTIVEC)
 
 // Borland Extensions.
 KEYWORD(__pascal                    , KEYALL)
diff --git a/tools/clang/include/clang/Driver/CC1Options.td b/tools/clang/include/clang/Driver/CC1Options.td
index d25560c..2e7317e 100644
--- a/tools/clang/include/clang/Driver/CC1Options.td
+++ b/tools/clang/include/clang/Driver/CC1Options.td
@@ -577,6 +577,18 @@ def cl_std_EQ : Joined<["-"], "cl-std=">,
 def fcuda_is_device : Flag<["-"], "fcuda-is-device">,
   HelpText<"Generate code for CUDA device">;
 
+//===----------------------------------------------------------------------===//
+// AIR/Metal Options
+//===----------------------------------------------------------------------===//
+def metal_air : Joined<["-"], "metal-air=">,
+  HelpText<"AIR/Metal only. Generate general air/metal and kernel argument metadata.">;
+
+//===----------------------------------------------------------------------===//
+// AIR/Metal Options
+//===----------------------------------------------------------------------===//
+def applecl_kernel_info : Flag<["-"], "applecl-kernel-info">,
+  HelpText<"AppleCL/OpenCL only. Generate general AppleCL and kernel argument metadata.">;
+
 } // let Flags = [CC1Option]
 
 
diff --git a/tools/clang/include/clang/Frontend/CodeGenOptions.def b/tools/clang/include/clang/Frontend/CodeGenOptions.def
index 1d92efe..d66c494 100644
--- a/tools/clang/include/clang/Frontend/CodeGenOptions.def
+++ b/tools/clang/include/clang/Frontend/CodeGenOptions.def
@@ -56,6 +56,8 @@ CODEGENOPT(EmitDeclMetadata  , 1, 0) ///< Emit special metadata indicating what
 CODEGENOPT(EmitGcovArcs      , 1, 0) ///< Emit coverage data files, aka. GCDA.
 CODEGENOPT(EmitGcovNotes     , 1, 0) ///< Emit coverage "notes" files, aka GCNO.
 CODEGENOPT(EmitOpenCLArgMetadata , 1, 0) ///< Emit OpenCL kernel arg metadata.
+CODEGENOPT(EmitAIRMetadata , 1, 0) ///< Emit AIR/Metal kernel info and arg metadata.
+CODEGENOPT(EmitAppleCLMetadata , 1, 0) ///< Emit AppleCL kernel info and arg metadata.
 /// \brief FP_CONTRACT mode (on/off/fast).
 ENUM_CODEGENOPT(FPContractMode, FPContractModeKind, 2, FPC_On)
 CODEGENOPT(ForbidGuardVariables , 1, 0) ///< Issue errors if C++ guard variables
diff --git a/tools/clang/include/clang/Frontend/LangStandards.def b/tools/clang/include/clang/Frontend/LangStandards.def
index 90a27b5..f014a08 100644
--- a/tools/clang/include/clang/Frontend/LangStandards.def
+++ b/tools/clang/include/clang/Frontend/LangStandards.def
@@ -134,17 +134,21 @@ LANGSTANDARD(gnucxx1z, "gnu++1z",
 // OpenCL
 LANGSTANDARD(opencl, "cl",
              "OpenCL 1.0",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus1y |
+             Digraphs | GNUMode)
 LANGSTANDARD(opencl11, "CL1.1",
              "OpenCL 1.1",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus1y |
+             Digraphs | GNUMode)
 LANGSTANDARD(opencl12, "CL1.2",
              "OpenCL 1.2",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus1y |
+             Digraphs | GNUMode)
 
 // CUDA
 LANGSTANDARD(cuda, "cuda",
              "NVIDIA CUDA(tm)",
-             LineComment | CPlusPlus | Digraphs)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus1y |
+             Digraphs | GNUMode)
 
 #undef LANGSTANDARD
diff --git a/tools/clang/include/clang/Sema/AttributeList.h b/tools/clang/include/clang/Sema/AttributeList.h
index c21c19f..a37f138 100644
--- a/tools/clang/include/clang/Sema/AttributeList.h
+++ b/tools/clang/include/clang/Sema/AttributeList.h
@@ -826,7 +826,7 @@ enum AttributeDeclKind {
   ExpectedVariableFunctionOrLabel,
   ExpectedFieldOrGlobalVar,
   ExpectedStruct,
-  ExpectedVariableFunctionOrTag,
+  ExpectedVariableOrTypedef,
   ExpectedTLSVar,
   ExpectedVariableOrField,
   ExpectedVariableFieldOrTag,
diff --git a/tools/clang/include/clang/Sema/Sema.h b/tools/clang/include/clang/Sema/Sema.h
index e254afd..1f05b24 100644
--- a/tools/clang/include/clang/Sema/Sema.h
+++ b/tools/clang/include/clang/Sema/Sema.h
@@ -7283,6 +7283,11 @@ public:
   void AddAlignedAttr(SourceRange AttrRange, Decl *D, TypeSourceInfo *T,
                       unsigned SpellingListIndex, bool IsPackExpansion);
 
+  /// AddAlignValueAttr - Adds an align_value attribute to a particular
+  /// declaration.
+  void AddAlignValueAttr(SourceRange AttrRange, Decl *D, Expr *E,
+                         unsigned SpellingListIndex);
+
   // OpenMP directives and clauses.
 private:
   void *VarDataSharingAttributesStack;
diff --git a/tools/clang/include/clang/Serialization/ASTBitCodes.h b/tools/clang/include/clang/Serialization/ASTBitCodes.h
index 7ae1977..bc2f64c 100644
--- a/tools/clang/include/clang/Serialization/ASTBitCodes.h
+++ b/tools/clang/include/clang/Serialization/ASTBitCodes.h
@@ -744,6 +744,12 @@ namespace clang {
       PREDEF_TYPE_IMAGE2D_ID    = 41,
       /// \brief OpenCL 2d image array type.
       PREDEF_TYPE_IMAGE2D_ARR_ID = 42,
+      PREDEF_TYPE_IMAGE2D_DEPTH_ID = 46,
+      PREDEF_TYPE_IMAGE2D_ARR_DEPTH_ID = 47,
+      PREDEF_TYPE_IMAGE2D_MSAA_ID = 48,
+      PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID = 49,
+      PREDEF_TYPE_IMAGE2D_MSAA_DEPTH_ID = 50,
+      PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID = 51,
       /// \brief OpenCL 3d image type.
       PREDEF_TYPE_IMAGE3D_ID    = 43,
       /// \brief OpenCL event type.
diff --git a/tools/clang/lib/AST/ASTContext.cpp b/tools/clang/lib/AST/ASTContext.cpp
index bccdae9..65a7d6c 100644
--- a/tools/clang/lib/AST/ASTContext.cpp
+++ b/tools/clang/lib/AST/ASTContext.cpp
@@ -1030,6 +1030,12 @@ void ASTContext::InitBuiltinTypes(const TargetInfo &Target) {
     InitBuiltinType(OCLImage1dBufferTy, BuiltinType::OCLImage1dBuffer);
     InitBuiltinType(OCLImage2dTy, BuiltinType::OCLImage2d);
     InitBuiltinType(OCLImage2dArrayTy, BuiltinType::OCLImage2dArray);
+    InitBuiltinType(OCLImage2dDepthTy, BuiltinType::OCLImage2dDepth);
+    InitBuiltinType(OCLImage2dArrayDepthTy, BuiltinType::OCLImage2dArrayDepth);
+    InitBuiltinType(OCLImage2dMSAATy, BuiltinType::OCLImage2dMSAA);
+    InitBuiltinType(OCLImage2dArrayMSAATy, BuiltinType::OCLImage2dArrayMSAA);
+    InitBuiltinType(OCLImage2dMSAADepthTy, BuiltinType::OCLImage2dMSAADepth);
+    InitBuiltinType(OCLImage2dArrayMSAADepthTy, BuiltinType::OCLImage2dArrayMSAADepth);
     InitBuiltinType(OCLImage3dTy, BuiltinType::OCLImage3d);
 
     InitBuiltinType(OCLSamplerTy, BuiltinType::OCLSampler);
@@ -1596,6 +1602,12 @@ ASTContext::getTypeInfoImpl(const Type *T) const {
     case BuiltinType::OCLImage1dBuffer:
     case BuiltinType::OCLImage2d:
     case BuiltinType::OCLImage2dArray:
+    case BuiltinType::OCLImage2dDepth:
+    case BuiltinType::OCLImage2dArrayDepth:
+    case BuiltinType::OCLImage2dMSAA:
+    case BuiltinType::OCLImage2dArrayMSAA:
+    case BuiltinType::OCLImage2dMSAADepth:
+    case BuiltinType::OCLImage2dArrayMSAADepth:
     case BuiltinType::OCLImage3d:
       // Currently these types are pointers to opaque types.
       Width = Target->getPointerWidth(0);
@@ -5154,6 +5166,12 @@ static char getObjCEncodingForPrimitiveKind(const ASTContext *C,
     case BuiltinType::OCLImage1dBuffer:
     case BuiltinType::OCLImage2d:
     case BuiltinType::OCLImage2dArray:
+    case BuiltinType::OCLImage2dDepth:
+    case BuiltinType::OCLImage2dArrayDepth:
+    case BuiltinType::OCLImage2dMSAA:
+    case BuiltinType::OCLImage2dArrayMSAA:
+    case BuiltinType::OCLImage2dMSAADepth:
+    case BuiltinType::OCLImage2dArrayMSAADepth:
     case BuiltinType::OCLImage3d:
     case BuiltinType::OCLEvent:
     case BuiltinType::OCLSampler:
diff --git a/tools/clang/lib/AST/ExprConstant.cpp b/tools/clang/lib/AST/ExprConstant.cpp
index 7d7ca99..9cf73cb 100644
--- a/tools/clang/lib/AST/ExprConstant.cpp
+++ b/tools/clang/lib/AST/ExprConstant.cpp
@@ -5849,6 +5849,74 @@ bool IntExprEvaluator::CheckReferencedDecl(const Expr* E, const Decl* D) {
   return false;
 }
 
+/// EvaluateBuiltinImageTypeCompare - Evaluate __builtin_image_type_compare(expr, mask, cmp).
+static int EvaluateBuiltinImageTypeCompare(ASTContext &Ctx, const CallExpr *E) {
+	if(E->getNumArgs() != 3) return 0;
+	const auto img_arg = E->getArg(0);
+	const auto mask_arg = E->getArg(1);
+	const auto cmp_arg = E->getArg(2);
+	
+	// mask and cmp must both be integer constant exprs (enum values, evaluable at compile-time)
+	if(!mask_arg->isIntegerConstantExpr(Ctx)) {
+		return 0;
+	}
+	if(!cmp_arg->isIntegerConstantExpr(Ctx)) {
+		return 0;
+	}
+	
+	llvm::APSInt mask_int, cmp_int;
+	if(!mask_arg->EvaluateAsInt(mask_int, Ctx)) {
+		return 0;
+	}
+	if(!cmp_arg->EvaluateAsInt(cmp_int, Ctx)) {
+		return 0;
+	}
+	
+	// image arg must be a template
+	if(const auto img_tmpl_type = img_arg->getType()->getAs<TemplateSpecializationType>()) {
+		if(img_tmpl_type->getNumArgs() < 1) return 0;
+		if(auto img_tmpl_arg_expr = img_tmpl_type->getArg(0).getAsExpr()) {
+			llvm::APSInt img_type_int;
+			if(img_tmpl_arg_expr->EvaluateAsInt(img_type_int, Ctx)) {
+				// note: all ints are unsigned 32-bit
+				return ((uint32_t(img_type_int.getZExtValue()) & uint32_t(mask_int.getZExtValue())) ==
+						uint32_t(cmp_int.getZExtValue()));
+			}
+		}
+	}
+	return 0;
+}
+
+/// EvaluateBuiltinImageTypeExtract - Evaluate __builtin_image_type_extract(expr, mask).
+static uint32_t EvaluateBuiltinImageTypeExtract(ASTContext &Ctx, const CallExpr *E) {
+	if(E->getNumArgs() != 2) return 0;
+	const auto img_arg = E->getArg(0);
+	const auto mask_arg = E->getArg(1);
+	
+	// mask must be an integer constant expr (enum value, evaluable at compile-time)
+	if(!mask_arg->isIntegerConstantExpr(Ctx)) {
+		return 0;
+	}
+	
+	llvm::APSInt mask_int;
+	if(!mask_arg->EvaluateAsInt(mask_int, Ctx)) {
+		return 0;
+	}
+	
+	// image arg must be a template
+	if(const auto img_tmpl_type = img_arg->getType()->getAs<TemplateSpecializationType>()) {
+		if(img_tmpl_type->getNumArgs() < 1) return 0;
+		if(auto img_tmpl_arg_expr = img_tmpl_type->getArg(0).getAsExpr()) {
+			llvm::APSInt img_type_int;
+			if(img_tmpl_arg_expr->EvaluateAsInt(img_type_int, Ctx)) {
+				// note: all ints are unsigned 32-bit
+				return uint32_t(img_type_int.getZExtValue()) & uint32_t(mask_int.getZExtValue());
+			}
+		}
+	}
+	return 0;
+}
+
 /// EvaluateBuiltinClassifyType - Evaluate __builtin_classify_type the same way
 /// as GCC.
 static int EvaluateBuiltinClassifyType(const CallExpr *E) {
@@ -6263,6 +6331,10 @@ bool IntExprEvaluator::VisitCallExpr(const CallExpr *E) {
     return BuiltinOp == Builtin::BI__atomic_always_lock_free ?
         Success(0, E) : Error(E);
   }
+  case Builtin::BI__builtin_image_type_compare:
+    return Success(EvaluateBuiltinImageTypeCompare(Info.Ctx, E), E);
+  case Builtin::BI__builtin_image_type_extract:
+    return Success(EvaluateBuiltinImageTypeExtract(Info.Ctx, E), E);
   }
 }
 
diff --git a/tools/clang/lib/AST/ItaniumMangle.cpp b/tools/clang/lib/AST/ItaniumMangle.cpp
index 977d6fc..307186b 100644
--- a/tools/clang/lib/AST/ItaniumMangle.cpp
+++ b/tools/clang/lib/AST/ItaniumMangle.cpp
@@ -1920,6 +1920,14 @@ void CXXNameMangler::mangleNameOrStandardSubstitution(const NamedDecl *ND) {
 }
 
 void CXXNameMangler::mangleType(const BuiltinType *T) {
+  // helper function to discern between spir and applecl name mangling depending on the triple vendor
+  static const auto mangle_opencl_name = [](const ASTContext& ast_ctx, const char* spir_name, const char* applecl_name) {
+    if(ast_ctx.getTargetInfo().getTriple().getVendorName().str() == "applecl") {
+      return applecl_name;
+    }
+    return spir_name;
+  };
+
   //  <type>         ::= <builtin-type>
   //  <builtin-type> ::= v  # void
   //                 ::= w  # wchar_t
@@ -1984,14 +1992,20 @@ void CXXNameMangler::mangleType(const BuiltinType *T) {
   case BuiltinType::ObjCId: Out << "11objc_object"; break;
   case BuiltinType::ObjCClass: Out << "10objc_class"; break;
   case BuiltinType::ObjCSel: Out << "13objc_selector"; break;
-  case BuiltinType::OCLImage1d: Out << "11ocl_image1d"; break;
-  case BuiltinType::OCLImage1dArray: Out << "16ocl_image1darray"; break;
-  case BuiltinType::OCLImage1dBuffer: Out << "17ocl_image1dbuffer"; break;
-  case BuiltinType::OCLImage2d: Out << "11ocl_image2d"; break;
-  case BuiltinType::OCLImage2dArray: Out << "16ocl_image2darray"; break;
-  case BuiltinType::OCLImage3d: Out << "11ocl_image3d"; break;
-  case BuiltinType::OCLSampler: Out << "11ocl_sampler"; break;
-  case BuiltinType::OCLEvent: Out << "9ocl_event"; break;
+  case BuiltinType::OCLImage1d: Out << mangle_opencl_name(getASTContext(), "11ocl_image1d", "PU3AS110_image1d_t"); break;
+  case BuiltinType::OCLImage1dArray: Out << mangle_opencl_name(getASTContext(), "16ocl_image1darray", "PU3AS116_image1d_array_t"); break;
+  case BuiltinType::OCLImage1dBuffer: Out << mangle_opencl_name(getASTContext(), "17ocl_image1dbuffer", "PU3AS117_image1d_buffer_t"); break;
+  case BuiltinType::OCLImage2d: Out << mangle_opencl_name(getASTContext(), "11ocl_image2d", "PU3AS110_image2d_t"); break;
+  case BuiltinType::OCLImage2dArray: Out << mangle_opencl_name(getASTContext(), "16ocl_image2darray", "PU3AS116_image2d_array_t"); break;
+  case BuiltinType::OCLImage2dDepth: Out << mangle_opencl_name(getASTContext(), "16ocl_image2ddepth", "PU3AS116_image2d_depth_t"); break;
+  case BuiltinType::OCLImage2dArrayDepth: Out << mangle_opencl_name(getASTContext(), "21ocl_image2darraydepth", "PU3AS122_image2d_array_depth_t"); break;
+  case BuiltinType::OCLImage2dMSAA: Out << mangle_opencl_name(getASTContext(), "15ocl_image2dmsaa", "PU3AS115_image2d_msaa_t"); break;
+  case BuiltinType::OCLImage2dArrayMSAA: Out << mangle_opencl_name(getASTContext(), "20ocl_image2darraymsaa", "PU3AS121_image2d_array_msaa_t"); break;
+  case BuiltinType::OCLImage2dMSAADepth: Out << mangle_opencl_name(getASTContext(), "20ocl_image2dmsaadepth", "PU3AS121_image2d_msaa_depth_t"); break;
+  case BuiltinType::OCLImage2dArrayMSAADepth: Out << mangle_opencl_name(getASTContext(), "25ocl_image2darraymsaadepth", "PU3AS127_image2d_array_msaa_depth_t"); break;
+  case BuiltinType::OCLImage3d: Out << mangle_opencl_name(getASTContext(), "11ocl_image3d", "PU3AS110_image3d_t"); break;
+  case BuiltinType::OCLSampler: Out << mangle_opencl_name(getASTContext(), "11ocl_sampler", "uSampler"); break;
+  case BuiltinType::OCLEvent: Out << mangle_opencl_name(getASTContext(), "9ocl_event", "i"); break;
   }
 }
 
diff --git a/tools/clang/lib/AST/MicrosoftMangle.cpp b/tools/clang/lib/AST/MicrosoftMangle.cpp
index e6a6d09..9855017 100644
--- a/tools/clang/lib/AST/MicrosoftMangle.cpp
+++ b/tools/clang/lib/AST/MicrosoftMangle.cpp
@@ -1492,6 +1492,12 @@ void MicrosoftCXXNameMangler::mangleType(const BuiltinType *T,
   case BuiltinType::OCLImage1dBuffer: Out << "PAUocl_image1dbuffer@@"; break;
   case BuiltinType::OCLImage2d: Out << "PAUocl_image2d@@"; break;
   case BuiltinType::OCLImage2dArray: Out << "PAUocl_image2darray@@"; break;
+  case BuiltinType::OCLImage2dDepth: Out << "PAUocl_image2ddepth@@"; break;
+  case BuiltinType::OCLImage2dArrayDepth: Out << "PAUocl_image2darraydepth@@"; break;
+  case BuiltinType::OCLImage2dMSAA: Out << "PAUocl_image2dmsaa@@"; break;
+  case BuiltinType::OCLImage2dArrayMSAA: Out << "PAUocl_image2darraymsaa@@"; break;
+  case BuiltinType::OCLImage2dMSAADepth: Out << "PAUocl_image2dmsaadepth@@"; break;
+  case BuiltinType::OCLImage2dArrayMSAADepth: Out << "PAUocl_image2darraymsaadepth@@"; break;
   case BuiltinType::OCLImage3d: Out << "PAUocl_image3d@@"; break;
   case BuiltinType::OCLSampler: Out << "PAUocl_sampler@@"; break;
   case BuiltinType::OCLEvent: Out << "PAUocl_event@@"; break;
diff --git a/tools/clang/lib/AST/NSAPI.cpp b/tools/clang/lib/AST/NSAPI.cpp
index 986b3b5..5503cce 100644
--- a/tools/clang/lib/AST/NSAPI.cpp
+++ b/tools/clang/lib/AST/NSAPI.cpp
@@ -349,6 +349,12 @@ NSAPI::getNSNumberFactoryMethodKind(QualType T) const {
   case BuiltinType::OCLImage1dBuffer:
   case BuiltinType::OCLImage2d:
   case BuiltinType::OCLImage2dArray:
+  case BuiltinType::OCLImage2dDepth:
+  case BuiltinType::OCLImage2dArrayDepth:
+  case BuiltinType::OCLImage2dMSAA:
+  case BuiltinType::OCLImage2dArrayMSAA:
+  case BuiltinType::OCLImage2dMSAADepth:
+  case BuiltinType::OCLImage2dArrayMSAADepth:
   case BuiltinType::OCLImage3d:
   case BuiltinType::OCLSampler:
   case BuiltinType::OCLEvent:
diff --git a/tools/clang/lib/AST/Type.cpp b/tools/clang/lib/AST/Type.cpp
index 1677874..e3e1be8 100644
--- a/tools/clang/lib/AST/Type.cpp
+++ b/tools/clang/lib/AST/Type.cpp
@@ -1546,6 +1546,12 @@ StringRef BuiltinType::getName(const PrintingPolicy &Policy) const {
   case OCLImage1dBuffer:  return "image1d_buffer_t";
   case OCLImage2d:        return "image2d_t";
   case OCLImage2dArray:   return "image2d_array_t";
+  case OCLImage2dDepth:   return "image2d_depth_t";
+  case OCLImage2dArrayDepth: return "image2d_array_depth_t";
+  case OCLImage2dMSAA:    return "image2d_msaa_t";
+  case OCLImage2dArrayMSAA: return "image2d_array_msaa_t";
+  case OCLImage2dMSAADepth: return "image2d_msaa_depth_t";
+  case OCLImage2dArrayMSAADepth: return "image2d_array_msaa_depth_t";
   case OCLImage3d:        return "image3d_t";
   case OCLSampler:        return "sampler_t";
   case OCLEvent:          return "event_t";
diff --git a/tools/clang/lib/AST/TypeLoc.cpp b/tools/clang/lib/AST/TypeLoc.cpp
index 208d695..89548e8 100644
--- a/tools/clang/lib/AST/TypeLoc.cpp
+++ b/tools/clang/lib/AST/TypeLoc.cpp
@@ -296,6 +296,12 @@ TypeSpecifierType BuiltinTypeLoc::getWrittenTypeSpec() const {
   case BuiltinType::OCLImage1dBuffer:
   case BuiltinType::OCLImage2d:
   case BuiltinType::OCLImage2dArray:
+  case BuiltinType::OCLImage2dDepth:
+  case BuiltinType::OCLImage2dArrayDepth:
+  case BuiltinType::OCLImage2dMSAA:
+  case BuiltinType::OCLImage2dArrayMSAA:
+  case BuiltinType::OCLImage2dMSAADepth:
+  case BuiltinType::OCLImage2dArrayMSAADepth:
   case BuiltinType::OCLImage3d:
   case BuiltinType::OCLSampler:
   case BuiltinType::OCLEvent:
diff --git a/tools/clang/lib/Basic/Targets.cpp b/tools/clang/lib/Basic/Targets.cpp
index 075f905..c9be0ff 100644
--- a/tools/clang/lib/Basic/Targets.cpp
+++ b/tools/clang/lib/Basic/Targets.cpp
@@ -1361,6 +1361,7 @@ namespace {
       // Define available target features
       // These must be defined in sorted order!
       NoAsmVariants = true;
+      UserLabelPrefix = "";
     }
     void getTargetDefines(const LangOptions &Opts,
                           MacroBuilder &Builder) const override {
@@ -1411,7 +1412,12 @@ namespace {
         .Case("sm_20", true)
         .Case("sm_21", true)
         .Case("sm_30", true)
+        .Case("sm_32", true)
         .Case("sm_35", true)
+        .Case("sm_37", true)
+        .Case("sm_50", true)
+        .Case("sm_52", true)
+        .Case("sm_53", true)
         .Default(false);
 
       return Valid;
@@ -5886,6 +5892,7 @@ namespace {
       // Define available target features
       // These must be defined in sorted order!
       NoAsmVariants = true;
+      UserLabelPrefix = "";
     }
     void getTargetDefines(const LangOptions &Opts,
                           MacroBuilder &Builder) const override {
diff --git a/tools/clang/lib/CodeGen/BackendUtil.cpp b/tools/clang/lib/CodeGen/BackendUtil.cpp
index cec48f3..8ea5b0c 100644
--- a/tools/clang/lib/CodeGen/BackendUtil.cpp
+++ b/tools/clang/lib/CodeGen/BackendUtil.cpp
@@ -145,6 +145,10 @@ private:
 
 }
 
+static void addAddressSpaceFixPass(const PassManagerBuilder &Builder, PassManagerBase &PM) {
+  PM.add(createAddressSpaceFixPass());
+}
+
 static void addObjCARCAPElimPass(const PassManagerBuilder &Builder, PassManagerBase &PM) {
   if (Builder.OptLevel > 0)
     PM.add(createObjCARCAPElimPass());
@@ -240,6 +244,11 @@ void EmitAssemblyHelper::CreatePasses() {
   PMBuilder.DisableUnrollLoops = !CodeGenOpts.UnrollLoops;
   PMBuilder.RerollLoops = CodeGenOpts.RerollLoops;
 
+  if (LangOpts.OpenCL) {
+    PMBuilder.addExtension(PassManagerBuilder::EP_EarlyAsPossible,
+                           addAddressSpaceFixPass);
+  }
+
   PMBuilder.addExtension(PassManagerBuilder::EP_EarlyAsPossible,
                          addAddDiscriminatorsPass);
 
diff --git a/tools/clang/lib/CodeGen/CGCall.cpp b/tools/clang/lib/CodeGen/CGCall.cpp
index 17c3354..77e0342 100644
--- a/tools/clang/lib/CodeGen/CGCall.cpp
+++ b/tools/clang/lib/CodeGen/CGCall.cpp
@@ -1526,6 +1526,25 @@ void CodeGenFunction::EmitFunctionProlog(const CGFunctionInfo &FI,
               AI->addAttr(llvm::AttributeSet::get(getLLVMContext(),
                                                   AI->getArgNo() + 1,
                                                   llvm::Attribute::NonNull));
+		  }
+
+          const auto *AVAttr = PVD->getAttr<AlignValueAttr>();
+          if (!AVAttr)
+            if (const auto *TOTy = dyn_cast<TypedefType>(OTy))
+              AVAttr = TOTy->getDecl()->getAttr<AlignValueAttr>();
+          if (AVAttr) {
+            llvm::Value *AlignmentValue =
+              EmitScalarExpr(AVAttr->getAlignment());
+            llvm::ConstantInt *AlignmentCI =
+              cast<llvm::ConstantInt>(AlignmentValue);
+            unsigned Alignment =
+              std::min((unsigned) AlignmentCI->getZExtValue(),
+                       +llvm::Value::MaximumAlignment);
+
+            llvm::AttrBuilder Attrs;
+            Attrs.addAlignmentAttr(Alignment);
+            AI->addAttr(llvm::AttributeSet::get(getLLVMContext(),
+                                                AI->getArgNo() + 1, Attrs));
           }
         }
 
@@ -2832,12 +2851,20 @@ RValue CodeGenFunction::EmitCall(const CGFunctionInfo &CallInfo,
         
         // If the argument doesn't match, perform a bitcast to coerce it.  This
         // can happen due to trivial type mismatches.
+		bool ignore_args_check = false;
         if (IRArgNo < IRFuncTy->getNumParams() &&
-            V->getType() != IRFuncTy->getParamType(IRArgNo))
-          V = Builder.CreateBitCast(V, IRFuncTy->getParamType(IRArgNo));
+			V->getType() != IRFuncTy->getParamType(IRArgNo)) {
+			const auto src_as = V->getType()->getPointerAddressSpace();
+			auto param_type = IRFuncTy->getParamType(IRArgNo);
+			if(src_as > 0 && src_as != param_type->getPointerAddressSpace()) {
+				param_type = llvm::PointerType::get(cast<llvm::PointerType>(param_type->getScalarType())->getElementType(), src_as);
+				ignore_args_check = true;
+			}
+			V = Builder.CreateBitCast(V, param_type);
+		}
         Args.push_back(V);
         
-        checkArgMatches(V, IRArgNo, IRFuncTy);
+        if(!ignore_args_check) checkArgMatches(V, IRArgNo, IRFuncTy);
         break;
       }
 
diff --git a/tools/clang/lib/CodeGen/CGDebugInfo.cpp b/tools/clang/lib/CodeGen/CGDebugInfo.cpp
index 048c8f8..c859a82 100644
--- a/tools/clang/lib/CodeGen/CGDebugInfo.cpp
+++ b/tools/clang/lib/CodeGen/CGDebugInfo.cpp
@@ -452,6 +452,24 @@ llvm::DIType CGDebugInfo::CreateType(const BuiltinType *BT) {
   case BuiltinType::OCLImage2dArray:
     return getOrCreateStructPtrType("opencl_image2d_array_t",
                                     OCLImage2dArrayDITy);
+  case BuiltinType::OCLImage2dDepth:
+    return getOrCreateStructPtrType("opencl_image2d_depth_t",
+                                    OCLImage2dDepthDITy);
+  case BuiltinType::OCLImage2dArrayDepth:
+    return getOrCreateStructPtrType("opencl_image2d_array_depth_t",
+                                    OCLImage2dArrayDepthDITy);
+  case BuiltinType::OCLImage2dMSAA:
+    return getOrCreateStructPtrType("opencl_image2d_msaa_t",
+                                    OCLImage2dMSAADITy);
+  case BuiltinType::OCLImage2dArrayMSAA:
+    return getOrCreateStructPtrType("opencl_image2d_array_msaa_t",
+                                    OCLImage2dArrayMSAADITy);
+  case BuiltinType::OCLImage2dMSAADepth:
+    return getOrCreateStructPtrType("opencl_image2d_msaa_depth_t",
+                                    OCLImage2dMSAADepthDITy);
+  case BuiltinType::OCLImage2dArrayMSAADepth:
+    return getOrCreateStructPtrType("opencl_image2d_array_msaa_depth_t",
+                                    OCLImage2dArrayMSAADepthDITy);
   case BuiltinType::OCLImage3d:
     return getOrCreateStructPtrType("opencl_image3d_t",
                                     OCLImage3dDITy);
diff --git a/tools/clang/lib/CodeGen/CGDebugInfo.h b/tools/clang/lib/CodeGen/CGDebugInfo.h
index fc3f434..7e63426 100644
--- a/tools/clang/lib/CodeGen/CGDebugInfo.h
+++ b/tools/clang/lib/CodeGen/CGDebugInfo.h
@@ -59,7 +59,7 @@ class CGDebugInfo {
   llvm::DICompositeType ObjTy;
   llvm::DIType SelTy;
   llvm::DIType OCLImage1dDITy, OCLImage1dArrayDITy, OCLImage1dBufferDITy;
-  llvm::DIType OCLImage2dDITy, OCLImage2dArrayDITy;
+  llvm::DIType OCLImage2dDITy, OCLImage2dArrayDITy, OCLImage2dDepthDITy, OCLImage2dArrayDepthDITy, OCLImage2dMSAADITy, OCLImage2dArrayMSAADITy, OCLImage2dMSAADepthDITy, OCLImage2dArrayMSAADepthDITy;
   llvm::DIType OCLImage3dDITy;
   llvm::DIType OCLEventDITy;
   llvm::DIType BlockLiteralGeneric;
diff --git a/tools/clang/lib/CodeGen/CGExprAgg.cpp b/tools/clang/lib/CodeGen/CGExprAgg.cpp
index 4cf94c0..53f4bb5 100644
--- a/tools/clang/lib/CodeGen/CGExprAgg.cpp
+++ b/tools/clang/lib/CodeGen/CGExprAgg.cpp
@@ -1405,12 +1405,13 @@ void CodeGenFunction::EmitAggregateCopy(llvm::Value *DestPtr,
   if (getLangOpts().CPlusPlus) {
     if (const RecordType *RT = Ty->getAs<RecordType>()) {
       CXXRecordDecl *Record = cast<CXXRecordDecl>(RT->getDecl());
-      assert((Record->hasTrivialCopyConstructor() || 
+	  // TODO: fix this!
+      /*assert((Record->hasTrivialCopyConstructor() ||
               Record->hasTrivialCopyAssignment() ||
               Record->hasTrivialMoveConstructor() ||
               Record->hasTrivialMoveAssignment()) &&
              "Trying to aggregate-copy a type without a trivial copy/move "
-             "constructor or assignment operator");
+             "constructor or assignment operator");*/
       // Ignore empty classes in C++.
       if (Record->isEmpty())
         return;
diff --git a/tools/clang/lib/CodeGen/CGExprCXX.cpp b/tools/clang/lib/CodeGen/CGExprCXX.cpp
index 7aacee4..5c002e0 100644
--- a/tools/clang/lib/CodeGen/CGExprCXX.cpp
+++ b/tools/clang/lib/CodeGen/CGExprCXX.cpp
@@ -24,6 +24,8 @@
 using namespace clang;
 using namespace CodeGen;
 
+// TODO: fix other This uses?
+
 RValue CodeGenFunction::EmitCXXMemberCall(const CXXMethodDecl *MD,
                                           SourceLocation CallLoc,
                                           llvm::Value *Callee,
@@ -46,7 +48,8 @@ RValue CodeGenFunction::EmitCXXMemberCall(const CXXMethodDecl *MD,
   CallArgList Args;
 
   // Push the this ptr.
-  Args.add(RValue::get(This), MD->getThisType(getContext()));
+  auto this_type = getContext().getAddrSpaceQualType(MD->getThisType(getContext()), This->getType()->getPointerAddressSpace());
+  Args.add(RValue::get(This), this_type);
 
   // If there is an implicit parameter (e.g. VTT), emit it.
   if (ImplicitParam) {
diff --git a/tools/clang/lib/CodeGen/CGOpenCLRuntime.cpp b/tools/clang/lib/CodeGen/CGOpenCLRuntime.cpp
index 079ef72..5b0b575 100644
--- a/tools/clang/lib/CodeGen/CGOpenCLRuntime.cpp
+++ b/tools/clang/lib/CodeGen/CGOpenCLRuntime.cpp
@@ -36,32 +36,75 @@ llvm::Type *CGOpenCLRuntime::convertOpenCLSpecificType(const Type *T) {
   llvm::LLVMContext& Ctx = CGM.getLLVMContext();
   uint32_t ImgAddrSpc =
     CGM.getContext().getTargetAddressSpace(LangAS::opencl_global);
-  switch (cast<BuiltinType>(T)->getKind()) {
-  default: 
-    llvm_unreachable("Unexpected opencl builtin type!");
-    return nullptr;
-  case BuiltinType::OCLImage1d:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image1d_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage1dArray:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image1d_array_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage1dBuffer:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image1d_buffer_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage2d:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image2d_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage2dArray:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image2d_array_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage3d:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image3d_t"), ImgAddrSpc);
-  case BuiltinType::OCLSampler:
-    return llvm::IntegerType::get(Ctx, 32);
-  case BuiltinType::OCLEvent:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.event_t"), 0);
+
+  if(!CGM.getCodeGenOpts().EmitAppleCLMetadata) {
+    switch (cast<BuiltinType>(T)->getKind()) {
+      default:
+        llvm_unreachable("Unexpected opencl builtin type!");
+        return nullptr;
+      case BuiltinType::OCLImage1d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image1d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage1dArray:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image1d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage1dBuffer:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image1d_buffer_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image2d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArray:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image2d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dDepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image2d_depth_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayDepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image2d_array_depth_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dMSAA:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image2d_msaa_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayMSAA:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image2d_array_msaa_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dMSAADepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image2d_msaa_depth_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayMSAADepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image2d_array_msaa_depth_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage3d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.image3d_t"), ImgAddrSpc);
+      case BuiltinType::OCLSampler:
+        return llvm::IntegerType::get(Ctx, 32);
+      case BuiltinType::OCLEvent:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "opencl.event_t"), 0);
+    }
+  }
+  else {
+    switch (cast<BuiltinType>(T)->getKind()) {
+      default:
+        llvm_unreachable("Unexpected opencl builtin type!");
+        return nullptr;
+      case BuiltinType::OCLImage1d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image1d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage1dArray:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image1d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage1dBuffer:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image1d_buffer_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image2d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArray:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image2d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dDepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image2d_depth_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayDepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image2d_array_depth_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dMSAA:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image2d_msaa_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayMSAA:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image2d_array_msaa_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dMSAADepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image2d_msaa_depth_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayMSAADepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image2d_array_msaa_depth_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage3d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._image3d_t"), ImgAddrSpc);
+      case BuiltinType::OCLSampler:
+        return llvm::IntegerType::get(Ctx, 32);
+      case BuiltinType::OCLEvent:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._event_t"), 0);
+    }
   }
 }
diff --git a/tools/clang/lib/CodeGen/CodeGenFunction.cpp b/tools/clang/lib/CodeGen/CodeGenFunction.cpp
index 5ca3a78..83b0ceb 100644
--- a/tools/clang/lib/CodeGen/CodeGenFunction.cpp
+++ b/tools/clang/lib/CodeGen/CodeGenFunction.cpp
@@ -429,9 +429,10 @@ static void GenOpenCLArgMetadata(const FunctionDecl *FD, llvm::Function *Fn,
       const OpenCLImageAccessAttr *A = parm->getAttr<OpenCLImageAccessAttr>();
       if (A && A->isWriteOnly())
         accessQuals.push_back(llvm::MDString::get(Context, "write_only"));
+      else if (A && A->isReadWrite())
+        accessQuals.push_back(llvm::MDString::get(Context, "read_write"));
       else
         accessQuals.push_back(llvm::MDString::get(Context, "read_only"));
-      // FIXME: what about read_write?
     } else
       accessQuals.push_back(llvm::MDString::get(Context, "none"));
 
@@ -446,6 +447,331 @@ static void GenOpenCLArgMetadata(const FunctionDecl *FD, llvm::Function *Fn,
   kernelMDArgs.push_back(llvm::MDNode::get(Context, argNames));
 }
 
+static void GenAIRMetadata(const FunctionDecl *FD, llvm::Function *Fn,
+						   CodeGenModule &CGM,llvm::LLVMContext &Context,
+						   SmallVector <llvm::Value*, 5> &kernelMDArgs,
+						   CGBuilderTy& Builder, ASTContext &ASTCtx) {
+	//
+	SmallVector<llvm::Value*, 1> empty_set; // no idea why this is needed or used for
+	SmallVector<llvm::Value*, 8> arg_infos;
+	
+	//
+	const PrintingPolicy &Policy = ASTCtx.getPrintingPolicy();
+	
+	//
+	int i = 0;
+	for(auto arg_iter = Fn->arg_begin(); arg_iter != Fn->arg_end(); ++arg_iter, ++i) {
+		SmallVector<llvm::Value*, 16> arg_info;
+		const auto type = arg_iter->getType();
+		const auto parm = FD->getParamDecl(i);
+		const auto clang_type = parm->getType();
+		
+		// TODO: support all non-pointer types
+		if(!type->isPointerTy()) continue;
+		const auto pointee_type = type->getPointerElementType();
+		const auto clang_unq_ty = clang_type->getPointeeType().getTypePtr()->getBaseElementTypeUnsafe();
+		
+		// #0: param index
+		arg_info.push_back(Builder.getInt32(i));
+		// #1: storage type (buffer, TODO: image/texture/sampler stuff)
+		arg_info.push_back(llvm::MDString::get(Context, "air.buffer"));
+		// #2/#3: location_index
+		arg_info.push_back(llvm::MDString::get(Context, "air.location_index"));
+		// for now: use the same as param idx, TODO: handle texture/image indices and possible other problems
+		arg_info.push_back(Builder.getInt32(i));
+		// #4: unknown? always 1
+		arg_info.push_back(Builder.getInt32(1));
+		// #5: access (read/read_write, TODO: write?)
+		if(type->isPointerTy()) {
+			const auto clang_pointee_type = clang_type->getPointeeType();
+			if(clang_pointee_type.isConstQualified() ||
+			   (clang_pointee_type.getAddressSpace() == LangAS::opencl_constant)) {
+				arg_info.push_back(llvm::MDString::get(Context, "air.read"));
+			}
+			else {
+				arg_info.push_back(llvm::MDString::get(Context, "air.read_write"));
+			}
+		}
+		else if(clang_type->isImageType()) {
+			// TODO: image support
+		}
+		else {
+			// TODO: what else is there?
+		}
+		
+		// TODO: #6/#7: struct info
+		
+		// #8/#9: type size
+		arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_size"));
+		arg_info.push_back(Builder.getInt32(CGM.getDataLayout().getTypeStoreSize(pointee_type)));
+		// #10/#11: type alignment
+		arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_align_size"));
+		arg_info.push_back(Builder.getInt32(CGM.getDataLayout().getTypeAllocSize(pointee_type)));
+		//getPrimitiveSizeInBits
+		// #12/#13: type name, note: air wants the pointed-to/pointee type here, w/o qualifiers
+		// TODO: handle everything else besides buffers/pointers!
+		auto unqualified_type = clang_unq_ty->getCanonicalTypeInternal();
+		auto type_name = unqualified_type.getAsString(Policy);
+		// Turn "unsigned type" to "utype"
+		const auto pos = type_name.find("unsigned");
+		if(pos != std::string::npos) type_name.erase(pos + 1, 8);
+		arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+		arg_info.push_back(llvm::MDString::get(Context, type_name));
+		// #14/#15: arg name
+		arg_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+		arg_info.push_back(llvm::MDString::get(Context, parm->getName()));
+		
+		arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+	}
+	
+	// insert into kernel metadata
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, empty_set));
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, arg_infos));
+}
+
+static void GenAppleCLMetadata(const FunctionDecl *FD, llvm::Function *Fn,
+							   CodeGenModule &CGM,llvm::LLVMContext &Context,
+							   SmallVector <llvm::Value*, 5> &kernelMDArgs,
+							   CGBuilderTy& Builder, ASTContext &ASTCtx) {
+	//
+	SmallVector<llvm::Value*, 8> arg_infos;
+	
+	// always starts with apple.cl.arg_metadata
+	arg_infos.push_back(llvm::MDString::get(Context, "apple.cl.arg_metadata"));
+	
+	//
+	int i = 0;
+	for(auto arg_iter = Fn->arg_begin(); arg_iter != Fn->arg_end(); ++arg_iter, ++i) {
+		SmallVector<llvm::Value*, 3> arg_info;
+		const auto parm = FD->getParamDecl(i);
+		const auto clang_type = parm->getType();
+		
+		// #0: storage type (stream or image)
+		if(clang_type->isPointerType() || clang_type->isReferenceType()) {
+			arg_info.push_back(llvm::MDString::get(Context, "stream"));
+			
+			// #1: access qualifier
+			const auto clang_pointee_type = clang_type->getPointeeType();
+			if(clang_pointee_type.isConstQualified() ||
+			   (clang_pointee_type.getAddressSpace() == LangAS::opencl_constant)) {
+				arg_info.push_back(llvm::MDString::get(Context, "read"));
+			}
+			else {
+				arg_info.push_back(llvm::MDString::get(Context, "write"));
+			}
+			
+			// #2: address space
+			switch(clang_pointee_type.getAddressSpace()) {
+				case LangAS::opencl_global:
+					arg_info.push_back(llvm::MDString::get(Context, "global"));
+					break;
+				case LangAS::opencl_local:
+					arg_info.push_back(llvm::MDString::get(Context, "local"));
+					break;
+				case LangAS::opencl_constant:
+					arg_info.push_back(llvm::MDString::get(Context, "constant"));
+					break;
+			}
+		}
+		else if(clang_type->isImageType()) {
+			arg_info.push_back(llvm::MDString::get(Context, "image"));
+			
+			// #1: access qualifier
+			const OpenCLImageAccessAttr *A = parm->getAttr<OpenCLImageAccessAttr>();
+			if(A && A->isWriteOnly()) {
+				arg_info.push_back(llvm::MDString::get(Context, "write"));
+			}
+			else if(A && A->isReadWrite()) {
+				arg_info.push_back(llvm::MDString::get(Context, "read/write"));
+			}
+			else {
+				arg_info.push_back(llvm::MDString::get(Context, "read"));
+			}
+		}
+		else {
+			// simple kernel parameter (not a buffer) -> don't write anything
+		}
+		
+		arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+	}
+	
+	// insert into kernel metadata
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, arg_infos));
+}
+
+void CodeGenFunction::EmitFloorKernelMetadata(const FunctionDecl *FD,
+											  llvm::Function *Fn,
+											  const FunctionArgList &Args) {
+	if (!FD->hasAttr<OpenCLKernelAttr>() && !FD->hasAttr<CUDAGlobalAttr>()) {
+		return;
+	}
+	
+	llvm::LLVMContext &Context = getLLVMContext();
+	
+	//
+	SmallVector<llvm::Value*, 16> arg_infos;
+	
+	// #0: info version
+	arg_infos.push_back(Builder.getInt32(1));
+	// #1: kernel name
+	arg_infos.push_back(llvm::MDString::get(Context, Fn->getName()));
+	
+	int i = 0;
+	for(auto arg_iter = Fn->arg_begin(); arg_iter != Fn->arg_end(); ++arg_iter, ++i) {
+		if(uint32_t(i) >= FD->param_size()) {
+			// signal that this is _very_ bad
+			CGM.Error(FD->getSourceRange().getBegin(),
+					  StringRef("function argument count mismatch!"));
+			break;
+		}
+		const auto type = arg_iter->getType();
+		const auto parm = FD->getParamDecl(i);
+		const auto clang_type = parm->getType();
+		
+		enum class FLOOR_ARG_INFO : uint64_t {
+			// 0 == invalid!
+			NONE						= (0ull),
+			
+			// sets: 00000000 000000-- -------- 00000xxx 00000000 00000000 00000000 00000000
+			__AS_SHIFT					= (32ull),
+			__AS_MASK					= (0x0000000700000000ull),
+			AS_NONE						= NONE,
+			AS_GLOBAL					= (1ull << __AS_SHIFT),
+			AS_LOCAL					= (2ull << __AS_SHIFT),
+			AS_CONSTANT					= (3ull << __AS_SHIFT),
+			AS_IMAGE					= (4ull << __AS_SHIFT),
+			
+			// sets: 00000000 000000-- xxxxxxxx 00000--- 00000000 00000000 00000000 00000000
+			__IMG_TYPE_SHIFT			= (40ull),
+			__IMG_TYPE_MASK				= (0x0000FF0000000000ull),
+			IMG_1D						= (1ull << __IMG_TYPE_SHIFT),
+			IMG_1D_ARRAY				= (2ull << __IMG_TYPE_SHIFT),
+			IMG_1D_BUFFER				= (3ull << __IMG_TYPE_SHIFT),
+			IMG_2D						= (4ull << __IMG_TYPE_SHIFT),
+			IMG_2D_ARRAY				= (5ull << __IMG_TYPE_SHIFT),
+			IMG_2D_DEPTH				= (6ull << __IMG_TYPE_SHIFT),
+			IMG_2D_ARRAY_DEPTH			= (7ull << __IMG_TYPE_SHIFT),
+			IMG_2D_MSAA					= (8ull << __IMG_TYPE_SHIFT),
+			IMG_2D_ARRAY_MSAA			= (9ull << __IMG_TYPE_SHIFT),
+			IMG_2D_MSAA_DEPTH			= (10ull << __IMG_TYPE_SHIFT),
+			IMG_2D_ARRAY_MSAA_DEPTH		= (11ull << __IMG_TYPE_SHIFT),
+			IMG_3D						= (12ull << __IMG_TYPE_SHIFT),
+			
+			// sets: 00000000 000000xx -------- 00000--- 00000000 00000000 00000000 00000000
+			__IMG_ACCESS_SHIFT			= (48ull),
+			__IMG_ACCESS_MASK			= (0x0003000000000000ull),
+			IMG_ACCESS_READ				= (1ull << __IMG_ACCESS_SHIFT),
+			IMG_ACCESS_WRITE			= (2ull << __IMG_ACCESS_SHIFT),
+			IMG_ACCESS_READ_WRITE		= (IMG_ACCESS_READ | IMG_ACCESS_WRITE),
+		};
+		
+		const auto to_fas = [](const unsigned& addr_space) {
+			if(addr_space == LangAS::opencl_global) {
+				return FLOOR_ARG_INFO::AS_GLOBAL;
+			}
+			else if(addr_space == LangAS::opencl_local) {
+				return FLOOR_ARG_INFO::AS_LOCAL;
+			}
+			else if(addr_space == LangAS::opencl_constant) {
+				return FLOOR_ARG_INFO::AS_CONSTANT;
+			}
+			return FLOOR_ARG_INFO::AS_NONE;
+		};
+		const auto set_image_access = [](const OpenCLImageAccessAttr* access_attr, uint64_t& arg_info) {
+			if(access_attr != nullptr) {
+				if(access_attr->isWriteOnly()) {
+					arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_ACCESS_WRITE;
+				}
+				else if(access_attr->isReadWrite()) {
+					arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_ACCESS_READ_WRITE;
+				}
+				else {
+					arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_ACCESS_READ;
+				}
+			}
+			else {
+				arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_ACCESS_READ;
+			}
+		};
+		
+		// #2+: argument sizes + types
+		// TODO: support all non-pointer types
+		if(clang_type->isPointerType() || clang_type->isReferenceType()) {
+			const auto clang_pointee_type = clang_type->getPointeeType();
+			const auto pointee_type = type->getPointerElementType();
+			
+			uint64_t arg_info = CGM.getDataLayout().getTypeStoreSize(pointee_type);
+			if(getLangOpts().OpenCL) {
+				// else: should be an error
+				arg_info |= (uint64_t)to_fas(clang_pointee_type.getAddressSpace());
+			}
+			else if(getLangOpts().CUDA) {
+				// always pretend this is global
+				arg_info |= (uint64_t)FLOOR_ARG_INFO::AS_GLOBAL;
+			}
+			arg_infos.push_back(Builder.getInt64(arg_info));
+		}
+		// handle image types
+		else if(clang_type->isImageType()) {
+			uint64_t arg_info = (uint64_t)FLOOR_ARG_INFO::AS_IMAGE;
+			
+			if(clang_type->isImage1dT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_1D;
+			else if(clang_type->isImage1dArrayT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_1D_ARRAY;
+			else if(clang_type->isImage1dBufferT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_1D_BUFFER;
+			else if(clang_type->isImage2dT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_2D;
+			else if(clang_type->isImage2dArrayT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_2D_ARRAY;
+			else if(clang_type->isImage2dDepthT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_2D_DEPTH;
+			else if(clang_type->isImage2dArrayDepthT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_2D_ARRAY_DEPTH;
+			else if(clang_type->isImage2dMSAAT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_2D_MSAA;
+			else if(clang_type->isImage2dArrayMSAAT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_2D_ARRAY_MSAA;
+			else if(clang_type->isImage2dMSAADepthT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_2D_MSAA_DEPTH;
+			else if(clang_type->isImage2dArrayMSAADepthT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_2D_ARRAY_MSAA_DEPTH;
+			else if(clang_type->isImage3dT()) arg_info |= (uint64_t)FLOOR_ARG_INFO::IMG_3D;
+			
+			set_image_access(parm->getAttr<OpenCLImageAccessAttr>(), arg_info);
+			
+			arg_infos.push_back(Builder.getInt64(arg_info));
+		}
+		// handle non-pointer parameters
+		else if(getLangOpts().CUDA) {
+			// store the parameter size
+			uint64_t arg_info = CGM.getDataLayout().getTypeStoreSize(type);
+			
+			// check if parameter has image access qualifiers,
+			// if so, it must be an image
+			const OpenCLImageAccessAttr* access_attr = parm->getAttr<OpenCLImageAccessAttr>();
+			if(access_attr != nullptr) {
+				set_image_access(access_attr, arg_info);
+				arg_info |= (uint64_t)FLOOR_ARG_INFO::AS_IMAGE;
+			}
+			// if not, pretend it is constant
+			else {
+				arg_info |= (uint64_t)FLOOR_ARG_INFO::AS_CONSTANT;
+			}
+			
+			arg_infos.push_back(Builder.getInt64(arg_info));
+		}
+		else {
+			// for now: just use the direct type size + no address space
+			uint64_t arg_info = 0;
+			// handle some llvm weirdness? why can this be a pointer still?
+			if(type->isPointerTy()) {
+				arg_info = CGM.getDataLayout().getTypeStoreSize(type->getPointerElementType());
+			}
+			else {
+				arg_info = CGM.getDataLayout().getTypeStoreSize(type);
+			}
+			arg_info |= (uint64_t)to_fas(clang_type.getAddressSpace());
+			arg_infos.push_back(Builder.getInt64(arg_info));
+		}
+	}
+	
+	//
+	llvm::MDNode *kernelMDNode = llvm::MDNode::get(Context, arg_infos);
+	llvm::NamedMDNode *FloorKernelMetadata = CGM.getModule().getOrInsertNamedMetadata("floor.kernels");
+	FloorKernelMetadata->addOperand(kernelMDNode);
+}
+
 void CodeGenFunction::EmitOpenCLKernelMetadata(const FunctionDecl *FD,
                                                llvm::Function *Fn)
 {
@@ -457,10 +783,16 @@ void CodeGenFunction::EmitOpenCLKernelMetadata(const FunctionDecl *FD,
   SmallVector <llvm::Value*, 5> kernelMDArgs;
   kernelMDArgs.push_back(Fn);
 
-  if (CGM.getCodeGenOpts().EmitOpenCLArgMetadata)
+  if (CGM.getCodeGenOpts().EmitOpenCLArgMetadata && !CGM.getCodeGenOpts().EmitAppleCLMetadata)
     GenOpenCLArgMetadata(FD, Fn, CGM, Context, kernelMDArgs,
                          Builder, getContext());
 
+  if (CGM.getCodeGenOpts().EmitAIRMetadata)
+    GenAIRMetadata(FD, Fn, CGM, Context, kernelMDArgs, Builder, getContext());
+
+  if (CGM.getCodeGenOpts().EmitAppleCLMetadata)
+    GenAppleCLMetadata(FD, Fn, CGM, Context, kernelMDArgs, Builder, getContext());
+
   if (const VecTypeHintAttr *A = FD->getAttr<VecTypeHintAttr>()) {
     QualType hintQTy = A->getTypeHint();
     const ExtVectorType *hintEltQTy = hintQTy->getAs<ExtVectorType>();
@@ -499,8 +831,39 @@ void CodeGenFunction::EmitOpenCLKernelMetadata(const FunctionDecl *FD,
 
   llvm::MDNode *kernelMDNode = llvm::MDNode::get(Context, kernelMDArgs);
   llvm::NamedMDNode *OpenCLKernelMetadata =
-    CGM.getModule().getOrInsertNamedMetadata("opencl.kernels");
+	CGM.getModule().getOrInsertNamedMetadata(CGM.getCodeGenOpts().EmitAIRMetadata ?
+											 "air.kernel" : "opencl.kernels");
   OpenCLKernelMetadata->addOperand(kernelMDNode);
+
+  // additional air info
+  if(CGM.getCodeGenOpts().EmitAIRMetadata) {
+	  SmallVector <llvm::Value*, 3> air_version;
+	  air_version.push_back(Builder.getInt32(CGM.getLangOpts().metal_version[0]));
+	  air_version.push_back(Builder.getInt32(CGM.getLangOpts().metal_version[1]));
+	  air_version.push_back(Builder.getInt32(CGM.getLangOpts().metal_version[2]));
+	  
+	  SmallVector <llvm::Value*, 4> air_lang_version;
+	  air_lang_version.push_back(llvm::MDString::get(Context, "METAL"));
+	  air_lang_version.push_back(Builder.getInt32(CGM.getLangOpts().metal_language_version[0]));
+	  air_lang_version.push_back(Builder.getInt32(CGM.getLangOpts().metal_language_version[1]));
+	  air_lang_version.push_back(Builder.getInt32(CGM.getLangOpts().metal_language_version[2]));
+	  
+	  llvm::NamedMDNode *AIRVersion = CGM.getModule().getOrInsertNamedMetadata("air.version");
+	  AIRVersion->addOperand(llvm::MDNode::get(Context, air_version));
+	  
+	  llvm::NamedMDNode *AIRLangVersion = CGM.getModule().getOrInsertNamedMetadata("air.language_version");
+	  AIRLangVersion->addOperand(llvm::MDNode::get(Context, air_lang_version));
+	  
+	  llvm::NamedMDNode *AIRCompOpts = CGM.getModule().getOrInsertNamedMetadata("air.compile_options");
+	  AIRCompOpts->addOperand(llvm::MDNode::get(Context,
+												llvm::MDString::get(Context, "air.compile.denorms_disable")));
+	  AIRCompOpts->addOperand(llvm::MDNode::get(Context,
+												llvm::MDString::get(Context, "air.compile.fast_math_enable")));
+	  AIRCompOpts->addOperand(llvm::MDNode::get(Context,
+												llvm::MDString::get(Context, "air.compile.framebuffer_fetch_disable")));
+	  AIRCompOpts->addOperand(llvm::MDNode::get(Context,
+												llvm::MDString::get(Context, "air.compile.native_double_disable")));
+  }
 }
 
 /// Determine whether the function F ends with a return stmt.
@@ -558,6 +921,11 @@ void CodeGenFunction::StartFunction(GlobalDecl GD,
     if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D))
       EmitOpenCLKernelMetadata(FD, Fn);
   }
+  if (getLangOpts().OpenCL || getLangOpts().CUDA) {
+	// add floor specific metadata for kernel functions
+	if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D))
+	  EmitFloorKernelMetadata(FD, Fn, Args);
+  }
 
   // If we are checking function types, emit a function type signature as
   // prefix data.
@@ -755,6 +1123,83 @@ static void EmitSizedDeallocationFunction(CodeGenFunction &CGF,
   CGF.Builder.CreateCall(Unsized, &*CGF.CurFn->arg_begin());
 }
 
+void CodeGenFunction::EmitAppleCLKernelAnnotation(GlobalDecl& GD, llvm::Function* Fn) {
+	if(!getLangOpts().OpenCL) return;
+	
+	if(const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(GD.getDecl())) {
+		// Add global applecl kernel annotations.
+		if(CGM.getCodeGenOpts().EmitAppleCLMetadata && FD->hasAttr<OpenCLKernelAttr>()) {
+			// go through all local decls and find the local memory decls
+			std::vector<llvm::Constant*> lmem_refs;
+			for(const auto& I : LocalDeclMap) {
+				const Decl* local_decl = I.first;
+				llvm::Value *Addr = I.second;
+				if(dyn_cast<llvm::GlobalValue>(Addr)) {
+					const VarDecl* lmem_VD = cast<VarDecl>(local_decl);
+					if(lmem_VD->getStorageClass() == SC_OpenCLWorkGroupLocal) {
+						lmem_refs.push_back(CGM.getStaticLocalDeclAddress(lmem_VD));
+					}
+				}
+			}
+			
+			// go through kernel arguments and set info
+			// "global float* a, global const float* b, constant float* c, constant const float* d, local float* e,
+			//  float f, const float g, read_only image2d_t h, write_only image2d_t i, read_write image2d_t j"
+			// -> "218890056a"
+			// TODO: sampler is "4" (NOTE: all other "numbers/chars" are unused)
+			int i = 0;
+			std::string arg_info = "";
+			for(auto arg_iter = Fn->arg_begin(); arg_iter != Fn->arg_end(); ++arg_iter, ++i) {
+				const auto parm = FD->getParamDecl(i);
+				const auto clang_type = parm->getType();
+				
+				// storage type (stream or image)
+				if(clang_type->isPointerType() || clang_type->isReferenceType()) {
+					// access qualifier
+					const auto clang_pointee_type = clang_type->getPointeeType();
+					bool read_only = false;
+					if(clang_pointee_type.isConstQualified() ||
+					   (clang_pointee_type.getAddressSpace() == LangAS::opencl_constant)) {
+						read_only = true;
+					}
+					
+					// address space
+					switch(clang_pointee_type.getAddressSpace()) {
+						case LangAS::opencl_global:
+							arg_info += (read_only ? "1" : "2");
+							break;
+						case LangAS::opencl_local:
+							arg_info += "9";
+							break;
+						case LangAS::opencl_constant:
+							arg_info += "8";
+							break;
+					}
+				}
+				else if(clang_type->isImageType()) {
+					// access qualifier
+					const OpenCLImageAccessAttr *A = parm->getAttr<OpenCLImageAccessAttr>();
+					if(A && A->isWriteOnly()) {
+						arg_info += "6";
+					}
+					else if(A && A->isReadWrite()) {
+						arg_info += "a";
+					}
+					else {
+						arg_info += "5";
+					}
+				}
+				else {
+					// simple kernel parameter (not a buffer)
+					arg_info += "0";
+				}
+			}
+			
+			CGM.AddAppleCLKernelAnnotation(Fn, arg_info, lmem_refs);
+		}
+	}
+}
+
 void CodeGenFunction::GenerateCode(GlobalDecl GD, llvm::Function *Fn,
                                    const CGFunctionInfo &FnInfo) {
   const FunctionDecl *FD = cast<FunctionDecl>(GD.getDecl());
@@ -858,6 +1303,10 @@ void CodeGenFunction::GenerateCode(GlobalDecl GD, llvm::Function *Fn,
   // Emit the standard function epilogue.
   FinishFunction(BodyRange.getEnd());
 
+  // emit applecl metadata and global annotations
+  // note that this must be done at the end, because we need access to local memory declarations
+  EmitAppleCLKernelAnnotation(GD, Fn);
+
   // If we haven't marked the function nothrow through other means, do
   // a quick pass now to see if we can.
   if (!CurFn->doesNotThrow())
diff --git a/tools/clang/lib/CodeGen/CodeGenFunction.h b/tools/clang/lib/CodeGen/CodeGenFunction.h
index 59cc30d..11cf78e 100644
--- a/tools/clang/lib/CodeGen/CodeGenFunction.h
+++ b/tools/clang/lib/CodeGen/CodeGenFunction.h
@@ -989,7 +989,13 @@ private:
   ///   "reqd_work_group_size", and three 32-bit integers X, Y and Z.
   void EmitOpenCLKernelMetadata(const FunctionDecl *FD, 
                                 llvm::Function *Fn);
+	
+  void EmitFloorKernelMetadata(const FunctionDecl *FD,
+                               llvm::Function *Fn,
+                               const FunctionArgList &Args);
 
+  void EmitAppleCLKernelAnnotation(GlobalDecl& GD, llvm::Function* Fn);
+	
 public:
   CodeGenFunction(CodeGenModule &cgm, bool suppressNewContext=false);
   ~CodeGenFunction();
diff --git a/tools/clang/lib/CodeGen/CodeGenModule.cpp b/tools/clang/lib/CodeGen/CodeGenModule.cpp
index 48823be..a537874 100644
--- a/tools/clang/lib/CodeGen/CodeGenModule.cpp
+++ b/tools/clang/lib/CodeGen/CodeGenModule.cpp
@@ -1147,6 +1147,39 @@ void CodeGenModule::AddGlobalAnnotations(const ValueDecl *D,
     Annotations.push_back(EmitAnnotateAttr(GV, I, D->getLocation()));
 }
 
+void CodeGenModule::AddAppleCLKernelAnnotation(llvm::Function* Fn, const std::string& sgv_str,
+											   std::vector<llvm::Constant*> lmem_refs) {
+	// sgv contains the argument type information
+	llvm::Constant* sgv_data = llvm::ConstantDataArray::getString(getLLVMContext(), sgv_str);
+	llvm::Constant* sgv = new llvm::GlobalVariable(getModule(), sgv_data->getType(), true,
+												   llvm::GlobalValue::InternalLinkage, sgv_data, "sgv");
+	
+	// fgv is always empty (would usually contain the file name)
+	llvm::Constant* fgv_data = llvm::ConstantDataArray::getString(getLLVMContext(), "", false);
+	llvm::Constant* fgv = new llvm::GlobalVariable(getModule(), fgv_data->getType(), true,
+												   llvm::GlobalValue::InternalLinkage, fgv_data, "fgv");
+	
+	// lvgv contains the pointers to local memory decls
+	std::vector<llvm::Constant*> lvgv_data;
+	for(const auto& lmem : lmem_refs) {
+		lvgv_data.push_back(llvm::ConstantExpr::getBitCast(lmem, Int8PtrTy));
+	}
+	llvm::Constant* lvgv_container = llvm::ConstantArray::get(llvm::ArrayType::get(Int8PtrTy, lmem_refs.size()), lvgv_data);
+	llvm::Constant* lvgv = new llvm::GlobalVariable(getModule(), lvgv_container->getType(), true,
+													llvm::GlobalValue::InternalLinkage, lvgv_container, "lvgv");
+	
+	// Create the ConstantStruct for the global annotation.
+	llvm::Constant *Fields[5] = {
+		llvm::ConstantExpr::getBitCast(Fn, Int8PtrTy),
+		llvm::ConstantExpr::getBitCast(sgv, Int8PtrTy),
+		llvm::ConstantExpr::getBitCast(fgv, Int8PtrTy),
+		llvm::ConstantExpr::getBitCast(lvgv, Int8PtrTy),
+		// always 0?
+		llvm::ConstantInt::get(Int32Ty, 0)
+	};
+	Annotations.push_back(llvm::ConstantStruct::getAnon(Fields));
+}
+
 bool CodeGenModule::MayDeferGeneration(const ValueDecl *Global) {
   // Never defer when EmitAllDecls is specified.
   if (LangOpts.EmitAllDecls)
@@ -1218,23 +1251,6 @@ void CodeGenModule::EmitGlobal(GlobalDecl GD) {
   if (Global->hasAttr<AliasAttr>())
     return EmitAliasDefinition(GD);
 
-  // If this is CUDA, be selective about which declarations we emit.
-  if (LangOpts.CUDA) {
-    if (CodeGenOpts.CUDAIsDevice) {
-      if (!Global->hasAttr<CUDADeviceAttr>() &&
-          !Global->hasAttr<CUDAGlobalAttr>() &&
-          !Global->hasAttr<CUDAConstantAttr>() &&
-          !Global->hasAttr<CUDASharedAttr>())
-        return;
-    } else {
-      if (!Global->hasAttr<CUDAHostAttr>() && (
-            Global->hasAttr<CUDADeviceAttr>() ||
-            Global->hasAttr<CUDAConstantAttr>() ||
-            Global->hasAttr<CUDASharedAttr>()))
-        return;
-    }
-  }
-
   // Ignore declarations, they will be emitted on their first use.
   if (const auto *FD = dyn_cast<FunctionDecl>(Global)) {
     // Forward declarations are emitted lazily on first use.
diff --git a/tools/clang/lib/CodeGen/CodeGenModule.h b/tools/clang/lib/CodeGen/CodeGenModule.h
index 9533a8d..d53d4e3 100644
--- a/tools/clang/lib/CodeGen/CodeGenModule.h
+++ b/tools/clang/lib/CodeGen/CodeGenModule.h
@@ -1009,6 +1009,9 @@ public:
   /// annotations are emitted during finalization of the LLVM code.
   void AddGlobalAnnotations(const ValueDecl *D, llvm::GlobalValue *GV);
 
+  void AddAppleCLKernelAnnotation(llvm::Function* Fn, const std::string& arg_info,
+                                  std::vector<llvm::Constant*> lmem_refs);
+
   const SanitizerBlacklist &getSanitizerBlacklist() const {
     return SanitizerBL;
   }
diff --git a/tools/clang/lib/CodeGen/CodeGenTypes.cpp b/tools/clang/lib/CodeGen/CodeGenTypes.cpp
index d4e2262..0c3f96f 100644
--- a/tools/clang/lib/CodeGen/CodeGenTypes.cpp
+++ b/tools/clang/lib/CodeGen/CodeGenTypes.cpp
@@ -380,6 +380,12 @@ llvm::Type *CodeGenTypes::ConvertType(QualType T) {
     case BuiltinType::OCLImage1dBuffer:
     case BuiltinType::OCLImage2d:
     case BuiltinType::OCLImage2dArray:
+    case BuiltinType::OCLImage2dDepth:
+    case BuiltinType::OCLImage2dArrayDepth:
+    case BuiltinType::OCLImage2dMSAA:
+    case BuiltinType::OCLImage2dArrayMSAA:
+    case BuiltinType::OCLImage2dMSAADepth:
+    case BuiltinType::OCLImage2dArrayMSAADepth:
     case BuiltinType::OCLImage3d:
     case BuiltinType::OCLSampler:
     case BuiltinType::OCLEvent:
diff --git a/tools/clang/lib/CodeGen/ItaniumCXXABI.cpp b/tools/clang/lib/CodeGen/ItaniumCXXABI.cpp
index d7e61f0..1bb799e 100644
--- a/tools/clang/lib/CodeGen/ItaniumCXXABI.cpp
+++ b/tools/clang/lib/CodeGen/ItaniumCXXABI.cpp
@@ -2173,6 +2173,12 @@ static bool TypeInfoIsInStandardLibrary(const BuiltinType *Ty) {
     case BuiltinType::OCLImage1dBuffer:
     case BuiltinType::OCLImage2d:
     case BuiltinType::OCLImage2dArray:
+    case BuiltinType::OCLImage2dDepth:
+    case BuiltinType::OCLImage2dArrayDepth:
+    case BuiltinType::OCLImage2dMSAA:
+    case BuiltinType::OCLImage2dArrayMSAA:
+    case BuiltinType::OCLImage2dMSAADepth:
+    case BuiltinType::OCLImage2dArrayMSAADepth:
     case BuiltinType::OCLImage3d:
     case BuiltinType::OCLSampler:
     case BuiltinType::OCLEvent:
diff --git a/tools/clang/lib/Frontend/CompilerInvocation.cpp b/tools/clang/lib/Frontend/CompilerInvocation.cpp
index ce61a46..6870297 100644
--- a/tools/clang/lib/Frontend/CompilerInvocation.cpp
+++ b/tools/clang/lib/Frontend/CompilerInvocation.cpp
@@ -474,6 +474,8 @@ static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
   Opts.InstrumentFunctions = Args.hasArg(OPT_finstrument_functions);
   Opts.InstrumentForProfiling = Args.hasArg(OPT_pg);
   Opts.EmitOpenCLArgMetadata = Args.hasArg(OPT_cl_kernel_arg_info);
+  Opts.EmitAIRMetadata = Args.hasArg(OPT_metal_air);
+  Opts.EmitAppleCLMetadata = Args.hasArg(OPT_applecl_kernel_info);
   Opts.CompressDebugSections = Args.hasArg(OPT_compress_debug_sections);
   Opts.DebugCompilationDir = Args.getLastArgValue(OPT_fdebug_compilation_dir);
   Opts.LinkBitcodeFile = Args.getLastArgValue(OPT_mlink_bitcode_file);
@@ -1276,7 +1278,7 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
             << A->getAsString(Args) << "C++/ObjC++";
         break;
       case IK_OpenCL:
-        if (!Std.isC99())
+        if (!Std.isC99() && !Std.isCPlusPlus())
           Diags.Report(diag::err_drv_argument_not_allowed_with)
             << A->getAsString(Args) << "OpenCL";
         break;
@@ -1311,6 +1313,32 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
   
   CompilerInvocation::setLangDefaults(Opts, IK, LangStd);
 
+  // extract the metal version and metal language version from the cli option
+  if (const Arg *A = Args.getLastArg(OPT_metal_air)) {
+    StringRef metal_versions = A->getValue();
+    // expecting "major,minor,rev,major,minor,rev" -> 5 commas
+    if(metal_versions.count(',') != 5) {
+      Diags.Report(diag::err_drv_invalid_value)
+      << A->getAsString(Args) << A->getValue();
+    }
+    else {
+      std::vector<std::string> versions;
+      size_t pos = 0, old_pos = 0;
+      while((pos = metal_versions.find(',', old_pos)) != std::string::npos) {
+        versions.emplace_back(metal_versions.substr(old_pos, pos - old_pos));
+        old_pos = pos + 1;
+      }
+      versions.emplace_back(metal_versions.substr(old_pos, pos - old_pos));
+      
+      Opts.metal_version[0] = std::stoul(versions[0]);
+      Opts.metal_version[1] = std::stoul(versions[1]);
+      Opts.metal_version[2] = std::stoul(versions[2]);
+      Opts.metal_language_version[0] = std::stoul(versions[3]);
+      Opts.metal_language_version[1] = std::stoul(versions[4]);
+      Opts.metal_language_version[2] = std::stoul(versions[5]);
+    }
+  }
+
   // We abuse '-f[no-]gnu-keywords' to force overriding all GNU-extension
   // keywords. This behavior is provided by GCC's poorly named '-fasm' flag,
   // while a subset (the non-C++ GNU keywords) is provided by GCC's
diff --git a/tools/clang/lib/Index/USRGeneration.cpp b/tools/clang/lib/Index/USRGeneration.cpp
index e08b85e..6d987b8 100644
--- a/tools/clang/lib/Index/USRGeneration.cpp
+++ b/tools/clang/lib/Index/USRGeneration.cpp
@@ -592,6 +592,12 @@ void USRGenerator::VisitType(QualType T) {
         case BuiltinType::OCLImage1dBuffer:
         case BuiltinType::OCLImage2d:
         case BuiltinType::OCLImage2dArray:
+        case BuiltinType::OCLImage2dDepth:
+        case BuiltinType::OCLImage2dArrayDepth:
+        case BuiltinType::OCLImage2dMSAA:
+        case BuiltinType::OCLImage2dArrayMSAA:
+        case BuiltinType::OCLImage2dMSAADepth:
+        case BuiltinType::OCLImage2dArrayMSAADepth:
         case BuiltinType::OCLImage3d:
         case BuiltinType::OCLEvent:
         case BuiltinType::OCLSampler:
diff --git a/tools/clang/lib/Lex/PPDirectives.cpp b/tools/clang/lib/Lex/PPDirectives.cpp
index 1741c30..2236e48 100644
--- a/tools/clang/lib/Lex/PPDirectives.cpp
+++ b/tools/clang/lib/Lex/PPDirectives.cpp
@@ -1807,7 +1807,7 @@ bool Preprocessor::ReadMacroDefinitionArgList(MacroInfo *MI, Token &Tok) {
              diag::ext_variadic_macro);
 
       // OpenCL v1.2 s6.9.e: variadic macros are not supported.
-      if (LangOpts.OpenCL) {
+      if (LangOpts.OpenCL && !LangOpts.CPlusPlus) {
         Diag(Tok, diag::err_pp_opencl_variadic_macros);
         return true;
       }
diff --git a/tools/clang/lib/Sema/Sema.cpp b/tools/clang/lib/Sema/Sema.cpp
index 2c65332..30bb730 100644
--- a/tools/clang/lib/Sema/Sema.cpp
+++ b/tools/clang/lib/Sema/Sema.cpp
@@ -206,6 +206,12 @@ void Sema::Initialize() {
     addImplicitTypedef("image1d_buffer_t", Context.OCLImage1dBufferTy);
     addImplicitTypedef("image2d_t", Context.OCLImage2dTy);
     addImplicitTypedef("image2d_array_t", Context.OCLImage2dArrayTy);
+    addImplicitTypedef("image2d_depth_t", Context.OCLImage2dDepthTy);
+    addImplicitTypedef("image2d_array_depth_t", Context.OCLImage2dArrayDepthTy);
+    addImplicitTypedef("image2d_msaa_t", Context.OCLImage2dMSAATy);
+    addImplicitTypedef("image2d_array_msaa_t", Context.OCLImage2dArrayMSAATy);
+    addImplicitTypedef("image2d_msaa_depth_t", Context.OCLImage2dMSAADepthTy);
+    addImplicitTypedef("image2d_array_msaa_depth_t", Context.OCLImage2dArrayMSAADepthTy);
     addImplicitTypedef("image3d_t", Context.OCLImage3dTy);
     addImplicitTypedef("sampler_t", Context.OCLSamplerTy);
     addImplicitTypedef("event_t", Context.OCLEventTy);
diff --git a/tools/clang/lib/Sema/SemaChecking.cpp b/tools/clang/lib/Sema/SemaChecking.cpp
index 66be962..59f659c 100644
--- a/tools/clang/lib/Sema/SemaChecking.cpp
+++ b/tools/clang/lib/Sema/SemaChecking.cpp
@@ -327,6 +327,14 @@ Sema::CheckBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall) {
     // so ensure that they are declared.
     DeclareGlobalNewDelete();
     break;
+  case Builtin::BI__builtin_image_type_compare:
+    if (checkArgCount(*this, TheCall, 3)) return true;
+    TheCall->setType(Context.IntTy);
+    break;
+  case Builtin::BI__builtin_image_type_extract:
+    if (checkArgCount(*this, TheCall, 2)) return true;
+    TheCall->setType(Context.IntTy);
+    break;
   }
 
   // Since the target specific builtins for each arch overlap, only check those
diff --git a/tools/clang/lib/Sema/SemaDecl.cpp b/tools/clang/lib/Sema/SemaDecl.cpp
index 8716227..93df749 100644
--- a/tools/clang/lib/Sema/SemaDecl.cpp
+++ b/tools/clang/lib/Sema/SemaDecl.cpp
@@ -5994,9 +5994,21 @@ void Sema::CheckVariableDeclarationType(VarDecl *NewVD) {
   if (getLangOpts().OpenCL && NewVD->isFileVarDecl()
       && T.getAddressSpace() != LangAS::opencl_constant
       && !T->isSamplerT()){
-    Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space);
-    NewVD->setInvalidDecl();
-    return;
+    // if the variable doesn't have an address space, but is a global static const variable,
+    // automatically add the constant address space
+    if(T.getAddressSpace() == 0 &&
+       (NewVD->isStaticDataMember() || NewVD->hasGlobalStorage()) &&
+       T.isConstQualified()) {
+      QualType constant_T = Context.getAddrSpaceQualType(T, LangAS::opencl_constant);
+      TypeSourceInfo* constant_Tinfo = Context.getTrivialTypeSourceInfo(constant_T);
+      NewVD->setType(constant_Tinfo->getType());
+      NewVD->setTypeSourceInfo(constant_Tinfo);
+    }
+    else {
+      Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space);
+      NewVD->setInvalidDecl();
+      return;
+    }
   }
   
   // OpenCL v1.2 s6.8 -- The static qualifier is valid only in program
diff --git a/tools/clang/lib/Sema/SemaDeclAttr.cpp b/tools/clang/lib/Sema/SemaDeclAttr.cpp
index 61683cd..e472879 100644
--- a/tools/clang/lib/Sema/SemaDeclAttr.cpp
+++ b/tools/clang/lib/Sema/SemaDeclAttr.cpp
@@ -2679,6 +2679,58 @@ static void handleAnnotateAttr(Sema &S, Decl *D, const AttributeList &Attr) {
                           Attr.getAttributeSpellingListIndex()));
 }
 
+static void handleAlignValueAttr(Sema &S, Decl *D,
+                                 const AttributeList &Attr) {
+  S.AddAlignValueAttr(Attr.getRange(), D, Attr.getArgAsExpr(0),
+                      Attr.getAttributeSpellingListIndex());
+}
+
+void Sema::AddAlignValueAttr(SourceRange AttrRange, Decl *D, Expr *E,
+                             unsigned SpellingListIndex) {
+  AlignValueAttr TmpAttr(AttrRange, Context, E, SpellingListIndex);
+  SourceLocation AttrLoc = AttrRange.getBegin();
+
+  QualType T;
+  if (TypedefNameDecl *TD = dyn_cast<TypedefNameDecl>(D))
+    T = TD->getUnderlyingType();
+  else if (ValueDecl *VD = dyn_cast<ValueDecl>(D))
+    T = VD->getType();
+  else
+    llvm_unreachable("Unknown decl type for align_value");
+
+  if (!T->isDependentType() && !T->isAnyPointerType() &&
+      !T->isReferenceType() && !T->isMemberPointerType()) {
+    Diag(AttrLoc, diag::warn_attribute_pointer_or_reference_only)
+      << &TmpAttr /*TmpAttr.getName()*/ << T << D->getSourceRange();
+    return;
+  }
+
+  if (!E->isValueDependent()) {
+    llvm::APSInt Alignment(32);
+    ExprResult ICE
+      = VerifyIntegerConstantExpression(E, &Alignment,
+          diag::err_align_value_attribute_argument_not_int,
+            /*AllowFold*/ false);
+    if (ICE.isInvalid())
+      return;
+
+    if (!Alignment.isPowerOf2()) {
+      Diag(AttrLoc, diag::err_alignment_not_power_of_two)
+        << E->getSourceRange();
+      return;
+    }
+
+    D->addAttr(::new (Context)
+               AlignValueAttr(AttrRange, Context, ICE.get(),
+               SpellingListIndex));
+    return;
+  }
+
+  // Save dependent expressions in the AST to be instantiated.
+  D->addAttr(::new (Context) AlignValueAttr(TmpAttr));
+  return;
+}
+
 static void handleAlignedAttr(Sema &S, Decl *D, const AttributeList &Attr) {
   // check the attribute arguments.
   if (Attr.getNumArgs() > 1) {
@@ -4102,6 +4154,9 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   case AttributeList::AT_Aligned:
     handleAlignedAttr(S, D, Attr);
     break;
+  case AttributeList::AT_AlignValue:
+    handleAlignValueAttr(S, D, Attr);
+    break;
   case AttributeList::AT_AlwaysInline:
     handleAlwaysInlineAttr(S, D, Attr);
     break;
diff --git a/tools/clang/lib/Sema/SemaDeclCXX.cpp b/tools/clang/lib/Sema/SemaDeclCXX.cpp
index c5cd83d..7084757 100644
--- a/tools/clang/lib/Sema/SemaDeclCXX.cpp
+++ b/tools/clang/lib/Sema/SemaDeclCXX.cpp
@@ -13026,21 +13026,13 @@ Sema::checkExceptionSpecification(ExceptionSpecificationType EST,
 
 /// IdentifyCUDATarget - Determine the CUDA compilation target for this function
 Sema::CUDAFunctionTarget Sema::IdentifyCUDATarget(const FunctionDecl *D) {
-  // Implicitly declared functions (e.g. copy constructors) are
-  // __host__ __device__
-  if (D->isImplicit())
-    return CFT_HostDevice;
-
   if (D->hasAttr<CUDAGlobalAttr>())
     return CFT_Global;
 
-  if (D->hasAttr<CUDADeviceAttr>()) {
-    if (D->hasAttr<CUDAHostAttr>())
-      return CFT_HostDevice;
-    return CFT_Device;
-  }
-
-  return CFT_Host;
+  // if not a kernel, always default to device
+  // this is IMO a much saner approach and doesn't require to add the __device__
+  // attribute to _all_ functions
+  return CFT_Device;
 }
 
 bool Sema::CheckCUDATarget(CUDAFunctionTarget CallerTarget,
diff --git a/tools/clang/lib/Sema/SemaExpr.cpp b/tools/clang/lib/Sema/SemaExpr.cpp
index 35dad82..bd249ab 100644
--- a/tools/clang/lib/Sema/SemaExpr.cpp
+++ b/tools/clang/lib/Sema/SemaExpr.cpp
@@ -444,7 +444,7 @@ ExprResult Sema::DefaultFunctionArrayConversion(Expr *E) {
   if (Ty->isFunctionType()) {
     // If we are here, we are not calling a function but taking
     // its address (which is not allowed in OpenCL v1.0 s6.8.a.3).
-    if (getLangOpts().OpenCL) {
+    if (getLangOpts().OpenCL && !LangOpts.CPlusPlus) {
       Diag(E->getExprLoc(), diag::err_opencl_taking_function_address);
       return ExprError();
     }
@@ -8953,7 +8953,7 @@ QualType Sema::CheckAddressOfOperand(ExprResult &OrigOp, SourceLocation OpLoc) {
   Expr *op = OrigOp.get()->IgnoreParens();
 
   // OpenCL v1.0 s6.8.a.3: Pointers to functions are not allowed.
-  if (LangOpts.OpenCL && op->getType()->isFunctionType()) {
+  if (LangOpts.OpenCL && !LangOpts.CPlusPlus && op->getType()->isFunctionType()) {
     Diag(op->getExprLoc(), diag::err_opencl_taking_function_address);
     return QualType();
   }
diff --git a/tools/clang/lib/Sema/SemaInit.cpp b/tools/clang/lib/Sema/SemaInit.cpp
index 06ca9ae..a517db4 100644
--- a/tools/clang/lib/Sema/SemaInit.cpp
+++ b/tools/clang/lib/Sema/SemaInit.cpp
@@ -3970,6 +3970,7 @@ static void TryReferenceInitializationCore(Sema &S,
   //         where "cv1 T1" is reference-compatible with "cv3 T3",
   //
   // DR1287 removes the "implicitly" here.
+  bool isOpenCLASRef = false;
   if (T2->isRecordType()) {
     if (RefRelationship == Sema::Ref_Incompatible) {
       ConvOvlResult = TryRefInitWithConversionFunction(
@@ -3990,8 +3991,15 @@ static void TryReferenceInitializationCore(Sema &S,
       return;
     }
 
-    Sequence.SetFailed(InitializationSequence::FK_ReferenceInitDropsQualifiers);
-    return;
+    if(S.getLangOpts().OpenCL &&
+       ((cv1T1.getAddressSpace() == 0 && cv2T2.getAddressSpace() != 0) ||
+        (cv1T1.getAddressSpace() != 0 && cv2T2.getAddressSpace() == 0))) {
+      isOpenCLASRef = true;
+    }
+    if(!isOpenCLASRef) {
+      Sequence.SetFailed(InitializationSequence::FK_ReferenceInitDropsQualifiers);
+      return;
+    }
   }
 
   //      - Otherwise, a temporary of type "cv1 T1" is created and initialized
@@ -4721,13 +4729,18 @@ void InitializationSequence::InitializeFrom(Sema &S,
         tryObjCWritebackConversion(S, *this, Entity, Initializer)) {
       return;
     }
+  }
 
+  // need to try these two when using C++ with OpenCL
+  if (!S.getLangOpts().CPlusPlus || S.getLangOpts().OpenCL) {
     if (TryOCLSamplerInitialization(S, *this, DestType, Initializer))
       return;
 
     if (TryOCLZeroEventInitialization(S, *this, DestType, Initializer))
       return;
+  }
 
+  if (!S.getLangOpts().CPlusPlus) {
     // Handle initialization in C
     AddCAssignmentStep(DestType);
     MaybeProduceObjCObject(S, *this, Entity);
@@ -5926,7 +5939,10 @@ InitializationSequence::Perform(Sema &S,
 
     case SK_BindReferenceToTemporary: {
       // Make sure the "temporary" is actually an rvalue.
-      assert(CurInit.get()->isRValue() && "not a temporary");
+      // TODO: fix this!
+      //if(CurInit.get()->getType()) {
+      //assert(CurInit.get()->isRValue() && "not a temporary");
+      //}
 
       // Check exception specifications
       if (S.CheckExceptionSpecCompatibility(CurInit.get(), DestType))
diff --git a/tools/clang/lib/Sema/SemaOverload.cpp b/tools/clang/lib/Sema/SemaOverload.cpp
index 03001d8..8678e01 100644
--- a/tools/clang/lib/Sema/SemaOverload.cpp
+++ b/tools/clang/lib/Sema/SemaOverload.cpp
@@ -4387,8 +4387,20 @@ TryReferenceInit(Sema &S, Expr *Init, QualType DeclType,
     T1Quals.removeObjCLifetime();
     T2Quals.removeObjCGCAttr();
     T2Quals.removeObjCLifetime();
-    if (!T1Quals.compatiblyIncludes(T2Quals))
+    if(S.getLangOpts().OpenCL) {
+		bool dropped_as = false;
+		if(T1Quals.hasAddressSpace()) {
+			T1Quals.removeAddressSpace();
+			dropped_as = true;
+		}
+		if(T2Quals.hasAddressSpace()) {
+			T2Quals.removeAddressSpace();
+			dropped_as = true;
+		}
+	}
+	if (!T1Quals.compatiblyIncludes(T2Quals)) {
       return ICS;
+	}
   }
 
   // If at least one of the types is a class type, the types are not
diff --git a/tools/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp b/tools/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
index accec95..d1095d9 100644
--- a/tools/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
+++ b/tools/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp
@@ -129,6 +129,17 @@ static void instantiateDependentAlignedAttr(
   }
 }
 
+static void instantiateDependentAlignValueAttr(
+    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,
+    const AlignValueAttr *Aligned, Decl *New) {
+  // The alignment expression is a constant expression.
+  EnterExpressionEvaluationContext Unevaluated(S, Sema::ConstantEvaluated);
+  ExprResult Result = S.SubstExpr(Aligned->getAlignment(), TemplateArgs);
+  if (!Result.isInvalid())
+    S.AddAlignValueAttr(Aligned->getLocation(), New, Result.getAs<Expr>(),
+                        Aligned->getSpellingListIndex());
+}
+
 static void instantiateDependentEnableIfAttr(
     Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,
     const EnableIfAttr *A, const Decl *Tmpl, Decl *New) {
@@ -176,6 +187,12 @@ void Sema::InstantiateAttrs(const MultiLevelTemplateArgumentList &TemplateArgs,
       continue;
     }
 
+    const AlignValueAttr *AlignValue = dyn_cast<AlignValueAttr>(TmplAttr);
+    if (AlignValue) {
+      instantiateDependentAlignValueAttr(*this, TemplateArgs, AlignValue, New);
+      continue;
+    }
+
     const EnableIfAttr *EnableIf = dyn_cast<EnableIfAttr>(TmplAttr);
     if (EnableIf && EnableIf->getCond()->isValueDependent()) {
       instantiateDependentEnableIfAttr(*this, TemplateArgs, EnableIf, Tmpl,
diff --git a/tools/clang/lib/Serialization/ASTCommon.cpp b/tools/clang/lib/Serialization/ASTCommon.cpp
index ad046ff..c3f5f66 100644
--- a/tools/clang/lib/Serialization/ASTCommon.cpp
+++ b/tools/clang/lib/Serialization/ASTCommon.cpp
@@ -66,6 +66,12 @@ serialization::TypeIdxFromBuiltin(const BuiltinType *BT) {
   case BuiltinType::OCLImage1dBuffer: ID = PREDEF_TYPE_IMAGE1D_BUFF_ID; break;
   case BuiltinType::OCLImage2d:       ID = PREDEF_TYPE_IMAGE2D_ID;      break;
   case BuiltinType::OCLImage2dArray:  ID = PREDEF_TYPE_IMAGE2D_ARR_ID;  break;
+  case BuiltinType::OCLImage2dDepth:  ID = PREDEF_TYPE_IMAGE2D_DEPTH_ID;  break;
+  case BuiltinType::OCLImage2dArrayDepth:  ID = PREDEF_TYPE_IMAGE2D_ARR_DEPTH_ID;  break;
+  case BuiltinType::OCLImage2dMSAA:  ID = PREDEF_TYPE_IMAGE2D_MSAA_ID;  break;
+  case BuiltinType::OCLImage2dArrayMSAA:  ID = PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID;  break;
+  case BuiltinType::OCLImage2dMSAADepth:  ID = PREDEF_TYPE_IMAGE2D_MSAA_DEPTH_ID;  break;
+  case BuiltinType::OCLImage2dArrayMSAADepth:  ID = PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID;  break;
   case BuiltinType::OCLImage3d:       ID = PREDEF_TYPE_IMAGE3D_ID;      break;
   case BuiltinType::OCLSampler:       ID = PREDEF_TYPE_SAMPLER_ID;      break;
   case BuiltinType::OCLEvent:         ID = PREDEF_TYPE_EVENT_ID;        break;
diff --git a/tools/clang/lib/Serialization/ASTReader.cpp b/tools/clang/lib/Serialization/ASTReader.cpp
index ae41654..9ce8807 100644
--- a/tools/clang/lib/Serialization/ASTReader.cpp
+++ b/tools/clang/lib/Serialization/ASTReader.cpp
@@ -5836,6 +5836,12 @@ QualType ASTReader::GetType(TypeID ID) {
     case PREDEF_TYPE_IMAGE1D_BUFF_ID: T = Context.OCLImage1dBufferTy; break;
     case PREDEF_TYPE_IMAGE2D_ID:    T = Context.OCLImage2dTy;       break;
     case PREDEF_TYPE_IMAGE2D_ARR_ID: T = Context.OCLImage2dArrayTy; break;
+    case PREDEF_TYPE_IMAGE2D_DEPTH_ID:    T = Context.OCLImage2dDepthTy; break;
+    case PREDEF_TYPE_IMAGE2D_ARR_DEPTH_ID: T = Context.OCLImage2dArrayDepthTy; break;
+    case PREDEF_TYPE_IMAGE2D_MSAA_ID:    T = Context.OCLImage2dMSAATy; break;
+    case PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID: T = Context.OCLImage2dArrayMSAATy; break;
+    case PREDEF_TYPE_IMAGE2D_MSAA_DEPTH_ID:    T = Context.OCLImage2dMSAADepthTy; break;
+    case PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID: T = Context.OCLImage2dArrayMSAADepthTy; break;
     case PREDEF_TYPE_IMAGE3D_ID:    T = Context.OCLImage3dTy;       break;
     case PREDEF_TYPE_SAMPLER_ID:    T = Context.OCLSamplerTy;       break;
     case PREDEF_TYPE_EVENT_ID:      T = Context.OCLEventTy;         break;
diff --git a/tools/clang/tools/libclang/CIndex.cpp b/tools/clang/tools/libclang/CIndex.cpp
index fc8703a..4968a35 100644
--- a/tools/clang/tools/libclang/CIndex.cpp
+++ b/tools/clang/tools/libclang/CIndex.cpp
@@ -1418,6 +1418,12 @@ bool CursorVisitor::VisitBuiltinTypeLoc(BuiltinTypeLoc TL) {
   case BuiltinType::OCLImage1dBuffer:
   case BuiltinType::OCLImage2d:
   case BuiltinType::OCLImage2dArray:
+  case BuiltinType::OCLImage2dDepth:
+  case BuiltinType::OCLImage2dArrayDepth:
+  case BuiltinType::OCLImage2dMSAA:
+  case BuiltinType::OCLImage2dArrayMSAA:
+  case BuiltinType::OCLImage2dMSAADepth:
+  case BuiltinType::OCLImage2dArrayMSAADepth:
   case BuiltinType::OCLImage3d:
   case BuiltinType::OCLSampler:
   case BuiltinType::OCLEvent:
