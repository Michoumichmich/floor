diff --git a/include/__functional_base b/include/__functional_base
index 6766793..6dfb843 100644
--- a/include/__functional_base
+++ b/include/__functional_base
@@ -13,9 +13,11 @@
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
 #include <exception>
 #include <new>
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #pragma GCC system_header
diff --git a/include/algorithm b/include/algorithm
index 3b74a6b..fff2d34 100644
--- a/include/algorithm
+++ b/include/algorithm
@@ -623,7 +623,9 @@ template <class BidirectionalIterator, class Compare>
 #include <__config>
 #include <initializer_list>
 #include <type_traits>
+#if 0
 #include <cstring>
+#endif
 #include <utility>
 #include <memory>
 #include <iterator>
@@ -1759,7 +1761,7 @@ typename enable_if
 __copy(_Tp* __first, _Tp* __last, _Up* __result)
 {
     const size_t __n = static_cast<size_t>(__last - __first);
-    _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+    __builtin_memmove(__result, __first, __n * sizeof(_Up));
     return __result + __n;
 }
 
@@ -1795,7 +1797,7 @@ __copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
 {
     const size_t __n = static_cast<size_t>(__last - __first);
     __result -= __n;
-    _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+    __builtin_memmove(__result, __first, __n * sizeof(_Up));
     return __result;
 }
 
@@ -1888,7 +1890,7 @@ typename enable_if
 __move(_Tp* __first, _Tp* __last, _Up* __result)
 {
     const size_t __n = static_cast<size_t>(__last - __first);
-    _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+    __builtin_memmove(__result, __first, __n * sizeof(_Up));
     return __result + __n;
 }
 
@@ -1924,7 +1926,7 @@ __move_backward(_Tp* __first, _Tp* __last, _Up* __result)
 {
     const size_t __n = static_cast<size_t>(__last - __first);
     __result -= __n;
-    _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+    __builtin_memmove(__result, __first, __n * sizeof(_Up));
     return __result;
 }
 
@@ -2044,7 +2046,7 @@ typename enable_if
 __fill_n(_Tp* __first, _Size __n,_Up __value_)
 {
     if (__n > 0)
-        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));
+        __builtin_memset(__first, (unsigned char)__value_, (size_t)(__n));
     return __first + __n;
 }
 
@@ -3045,13 +3047,14 @@ uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p
     return static_cast<result_type>(__u + __p.a());
 }
 
+#if 0 // this is not supported
 class _LIBCPP_TYPE_VIS __rs_default;
 
 _LIBCPP_FUNC_VIS __rs_default __rs_get();
 
 class _LIBCPP_TYPE_VIS __rs_default
 {
-    static unsigned __c_;
+    static constant unsigned __c_ { 0u };
 
     __rs_default();
 public:
@@ -3093,6 +3096,7 @@ random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
         }
     }
 }
+#endif
 
 template <class _RandomAccessIterator, class _RandomNumberGenerator>
 void
@@ -3348,6 +3352,7 @@ __second_half_done:
     //         |
 }
 
+#if 0
 struct __return_temporary_buffer
 {
     template <class _Tp>
@@ -3384,6 +3389,7 @@ __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate
     return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                              (__first, __last, __pred, __len, __p, forward_iterator_tag());
 }
+#endif
 
 template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
 _BidirectionalIterator
@@ -3493,6 +3499,7 @@ __second_half_done:
     //         |
 }
 
+#if 0
 template <class _Predicate, class _BidirectionalIterator>
 _BidirectionalIterator
 __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
@@ -3532,6 +3539,7 @@ __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last
     return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                              (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
 }
+#endif
 
 template <class _ForwardIterator, class _Predicate>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -3836,188 +3844,30 @@ __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __c
     typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
     const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                     is_trivially_copy_assignable<value_type>::value ? 30 : 6;
-    while (true)
+
+    // compute note: keep the special cases if len <= 5, but always fallback to using
+    //               __insertion_sort_3 for len > 5 as it doesn't require recursion
+    difference_type __len = __last - __first;
+    switch (__len)
     {
-    __restart:
-        difference_type __len = __last - __first;
-        switch (__len)
-        {
-        case 0:
-        case 1:
-            return;
-        case 2:
-            if (__comp(*--__last, *__first))
-                swap(*__first, *__last);
-            return;
-        case 3:
-            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);
-            return;
-        case 4:
-            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
-            return;
-        case 5:
-            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
-            return;
-        }
-        if (__len <= __limit)
-        {
-            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);
-            return;
-        }
-        // __len > 5
-        _RandomAccessIterator __m = __first;
-        _RandomAccessIterator __lm1 = __last;
-        --__lm1;
-        unsigned __n_swaps;
-        {
-        difference_type __delta;
-        if (__len >= 1000)
-        {
-            __delta = __len/2;
-            __m += __delta;
-            __delta /= 2;
-            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
-        }
-        else
-        {
-            __delta = __len/2;
-            __m += __delta;
-            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);
-        }
-        }
-        // *__m is median
-        // partition [__first, __m) < *__m and *__m <= [__m, __last)
-        // (this inhibits tossing elements equivalent to __m around unnecessarily)
-        _RandomAccessIterator __i = __first;
-        _RandomAccessIterator __j = __lm1;
-        // j points beyond range to be tested, *__m is known to be <= *__lm1
-        // The search going up is known to be guarded but the search coming down isn't.
-        // Prime the downward search with a guard.
-        if (!__comp(*__i, *__m))  // if *__first == *__m
-        {
-            // *__first == *__m, *__first doesn't go in first part
-            // manually guard downward moving __j against __i
-            while (true)
-            {
-                if (__i == --__j)
-                {
-                    // *__first == *__m, *__m <= all other elements
-                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)
-                    ++__i;  // __first + 1
-                    __j = __last;
-                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)
-                    {
-                        while (true)
-                        {
-                            if (__i == __j)
-                                return;  // [__first, __last) all equivalent elements
-                            if (__comp(*__first, *__i))
-                            {
-                                swap(*__i, *__j);
-                                ++__n_swaps;
-                                ++__i;
-                                break;
-                            }
-                            ++__i;
-                        }
-                    }
-                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
-                    if (__i == __j)
-                        return;
-                    while (true)
-                    {
-                        while (!__comp(*__first, *__i))
-                            ++__i;
-                        while (__comp(*__first, *--__j))
-                            ;
-                        if (__i >= __j)
-                            break;
-                        swap(*__i, *__j);
-                        ++__n_swaps;
-                        ++__i;
-                    }
-                    // [__first, __i) == *__first and *__first < [__i, __last)
-                    // The first part is sorted, sort the secod part
-                    // _VSTD::__sort<_Compare>(__i, __last, __comp);
-                    __first = __i;
-                    goto __restart;
-                }
-                if (__comp(*__j, *__m))
-                {
-                    swap(*__i, *__j);
-                    ++__n_swaps;
-                    break;  // found guard for downward moving __j, now use unguarded partition
-                }
-            }
-        }
-        // It is known that *__i < *__m
-        ++__i;
-        // j points beyond range to be tested, *__m is known to be <= *__lm1
-        // if not yet partitioned...
-        if (__i < __j)
-        {
-            // known that *(__i - 1) < *__m
-            // known that __i <= __m
-            while (true)
-            {
-                // __m still guards upward moving __i
-                while (__comp(*__i, *__m))
-                    ++__i;
-                // It is now known that a guard exists for downward moving __j
-                while (!__comp(*--__j, *__m))
-                    ;
-                if (__i > __j)
-                    break;
-                swap(*__i, *__j);
-                ++__n_swaps;
-                // It is known that __m != __j
-                // If __m just moved, follow it
-                if (__m == __i)
-                    __m = __j;
-                ++__i;
-            }
-        }
-        // [__first, __i) < *__m and *__m <= [__i, __last)
-        if (__i != __m && __comp(*__m, *__i))
-        {
-            swap(*__i, *__m);
-            ++__n_swaps;
-        }
-        // [__first, __i) < *__i and *__i <= [__i+1, __last)
-        // If we were given a perfect partition, see if insertion sort is quick...
-        if (__n_swaps == 0)
-        {
-            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
-            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
-            {
-                if (__fs)
-                    return;
-                __last = __i;
-                continue;
-            }
-            else
-            {
-                if (__fs)
-                {
-                    __first = ++__i;
-                    continue;
-                }
-            }
-        }
-        // sort smaller range with recursive call and larger with tail recursion elimination
-        if (__i - __first < __last - __i)
-        {
-            _VSTD::__sort<_Compare>(__first, __i, __comp);
-            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);
-            __first = ++__i;
-        }
-        else
-        {
-            _VSTD::__sort<_Compare>(__i+1, __last, __comp);
-            // _VSTD::__sort<_Compare>(__first, __i, __comp);
-            __last = __i;
-        }
+    case 0:
+    case 1:
+        return;
+    case 2:
+        if (__comp(*--__last, *__first))
+            swap(*__first, *__last);
+        return;
+    case 3:
+        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);
+        return;
+    case 4:
+        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
+        return;
+    case 5:
+        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
+        return;
     }
+    _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);
 }
 
 // This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare
@@ -4488,6 +4338,7 @@ struct __inplace_merge_switch
     static const unsigned value = is_trivially_copy_assignable<_Tp>::value;
 };
 
+#if 0
 template <class _BidirectionalIterator, class _Compare>
 inline _LIBCPP_INLINE_VISIBILITY
 void
@@ -4517,6 +4368,7 @@ inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _
                                             __buf.first, __buf.second);
 #endif  // _LIBCPP_DEBUG
 }
+#endif
 
 template <class _BidirectionalIterator>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -4702,6 +4554,7 @@ __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp
     __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
 }
 
+#if 0
 template <class _RandomAccessIterator, class _Compare>
 inline _LIBCPP_INLINE_VISIBILITY
 void
@@ -4726,6 +4579,7 @@ stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compar
     __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
 #endif  // _LIBCPP_DEBUG
 }
+#endif
 
 template <class _RandomAccessIterator>
 inline _LIBCPP_INLINE_VISIBILITY
diff --git a/include/atomic b/include/atomic
index f6ab1cb..63e9dd5 100644
--- a/include/atomic
+++ b/include/atomic
@@ -526,7 +526,9 @@ void atomic_signal_fence(memory_order m) noexcept;
 
 #include <__config>
 #include <cstddef>
+#if 0
 #include <cstdint>
+#endif
 #include <type_traits>
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
@@ -539,11 +541,7 @@ _LIBCPP_BEGIN_NAMESPACE_STD
 #error <atomic> is not implemented
 #else
 
-typedef enum memory_order
-{
-    memory_order_relaxed, memory_order_consume, memory_order_acquire,
-    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
-} memory_order;
+// NOTE: memory_order defined externally
 
 template <class _Tp>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -555,135 +553,113 @@ kill_dependency(_Tp __y) _NOEXCEPT
 
 // general atomic<T>
 
-template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
+template <class _Tp, class _TpAS = global _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
 struct __atomic_base  // false
 {
-    mutable _Atomic(_Tp) __a_;
+    typedef volatile _TpAS* _ptr_type;
+    
+    mutable volatile _Tp __a_;
 
     _LIBCPP_INLINE_VISIBILITY
     bool is_lock_free() const volatile _NOEXCEPT
-        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
+        {return floor_atomic_is_lock_free(sizeof(_Tp));}
     _LIBCPP_INLINE_VISIBILITY
     bool is_lock_free() const _NOEXCEPT
-        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
+        {return floor_atomic_is_lock_free(sizeof(_Tp));}
     _LIBCPP_INLINE_VISIBILITY
-    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {__c11_atomic_store(&__a_, __d, __m);}
+    void store(_Tp __d, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {floor_atomic_store(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    void store(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {__c11_atomic_store(&__a_, __d, __m);}
+    void store(_Tp __d, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {floor_atomic_store(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp load(memory_order __m = memory_order_seq_cst) const volatile _NOEXCEPT
-        {return __c11_atomic_load(&__a_, __m);}
+    _Tp load(memory_order __m = memory_order_relaxed) const volatile _NOEXCEPT
+        {return floor_atomic_load(reinterpret_cast<_ptr_type>(&__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp load(memory_order __m = memory_order_seq_cst) const _NOEXCEPT
-        {return __c11_atomic_load(&__a_, __m);}
+    _Tp load(memory_order __m = memory_order_relaxed) const _NOEXCEPT
+        {return floor_atomic_load(reinterpret_cast<_ptr_type>(&__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
     operator _Tp() const volatile _NOEXCEPT {return load();}
     _LIBCPP_INLINE_VISIBILITY
     operator _Tp() const _NOEXCEPT          {return load();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, __d, __m);}
+    _Tp exchange(_Tp __d, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_exchange(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, __d, __m);}
+    _Tp exchange(_Tp __d, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_exchange(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
                                memory_order __s, memory_order __f) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
                                memory_order __s, memory_order __f) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                                 memory_order __s, memory_order __f) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                                 memory_order __s, memory_order __f) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
-                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
+                              memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __m, __m);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
-                               memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
+                               memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __m, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                                 memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
 
     _LIBCPP_INLINE_VISIBILITY
-#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
     __atomic_base() _NOEXCEPT = default;
-#else
-    __atomic_base() _NOEXCEPT : __a_() {}
-#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
 
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __a_(__d) {}
-#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
     __atomic_base(const __atomic_base&) = delete;
     __atomic_base& operator=(const __atomic_base&) = delete;
     __atomic_base& operator=(const __atomic_base&) volatile = delete;
-#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
-private:
-    __atomic_base(const __atomic_base&);
-    __atomic_base& operator=(const __atomic_base&);
-    __atomic_base& operator=(const __atomic_base&) volatile;
-#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
 };
 
 // atomic<Integral>
 
-template <class _Tp>
-struct __atomic_base<_Tp, true>
-    : public __atomic_base<_Tp, false>
+template <class _Tp, class _TpAS>
+struct __atomic_base<_Tp, _TpAS, true>
+    : public __atomic_base<_Tp, _TpAS, false>
 {
-    typedef __atomic_base<_Tp, false> __base;
+    typedef volatile _TpAS* _ptr_type;
+    typedef __atomic_base<_Tp, _TpAS, false> __base;
     _LIBCPP_INLINE_VISIBILITY
     __atomic_base() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __base(__d) {}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_and(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_and(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_or(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_or(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_xor(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_xor(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
 
     _LIBCPP_INLINE_VISIBILITY
     _Tp operator++(int) volatile _NOEXCEPT      {return fetch_add(_Tp(1));}
@@ -725,11 +701,11 @@ struct __atomic_base<_Tp, true>
 
 // atomic<T>
 
-template <class _Tp>
+template <class _Tp, class _TpAS = global _Tp>
 struct atomic
-    : public __atomic_base<_Tp>
+    : public __atomic_base<_Tp, _TpAS>
 {
-    typedef __atomic_base<_Tp> __base;
+    typedef __atomic_base<_Tp, _TpAS> __base;
     _LIBCPP_INLINE_VISIBILITY
     atomic() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
@@ -745,709 +721,70 @@ struct atomic
 
 // atomic<T*>
 
-template <class _Tp>
+template <class _Tp, class _TpAS>
 struct atomic<_Tp*>
-    : public __atomic_base<_Tp*>
+    : public __atomic_base<_Tp*, _TpAS*>
 {
+    typedef volatile _TpAS* _ptr_type;
     typedef __atomic_base<_Tp*> __base;
+    
     _LIBCPP_INLINE_VISIBILITY
     atomic() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
-    _LIBCPP_CONSTEXPR atomic(_Tp* __d) _NOEXCEPT : __base(__d) {}
+    _LIBCPP_CONSTEXPR atomic(_ptr_type __d) _NOEXCEPT : __base(__d) {}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator=(_Tp* __d) volatile _NOEXCEPT
+    _ptr_type operator=(_ptr_type __d) volatile _NOEXCEPT
         {__base::store(__d); return __d;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator=(_Tp* __d) _NOEXCEPT
+    _ptr_type operator=(_ptr_type __d) _NOEXCEPT
         {__base::store(__d); return __d;}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
+    _ptr_type fetch_add(ptrdiff_t __op, memory_order __m = memory_order_relaxed)
                                                                         volatile _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _ptr_type fetch_add(ptrdiff_t __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
+    _ptr_type fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_relaxed)
                                                                         volatile _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _ptr_type fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}
+    _ptr_type operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++(int) _NOEXCEPT                     {return fetch_add(1);}
+    _ptr_type operator++(int) _NOEXCEPT                     {return fetch_add(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}
+    _ptr_type operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--(int) _NOEXCEPT                     {return fetch_sub(1);}
+    _ptr_type operator--(int) _NOEXCEPT                     {return fetch_sub(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}
+    _ptr_type operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}
+    _ptr_type operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}
+    _ptr_type operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}
+    _ptr_type operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
+    _ptr_type operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
+    _ptr_type operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
+    _ptr_type operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
+    _ptr_type operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
 };
 
-// atomic_is_lock_free
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_is_lock_free(const volatile atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->is_lock_free();
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_is_lock_free(const atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->is_lock_free();
-}
-
-// atomic_init
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_init(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __c11_atomic_init(&__o->__a_, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_init(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __c11_atomic_init(&__o->__a_, __d);
-}
-
-// atomic_store
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __o->store(__d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __o->store(__d);
-}
-
-// atomic_store_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    __o->store(__d, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    __o->store(__d, __m);
-}
-
-// atomic_load
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load(const volatile atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->load();
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load(const atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->load();
-}
-
-// atomic_load_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->load(__m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->load(__m);
-}
-
-// atomic_exchange
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    return __o->exchange(__d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    return __o->exchange(__d);
-}
-
-// atomic_exchange_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    return __o->exchange(__d, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    return __o->exchange(__d, __m);
-}
-
-// atomic_compare_exchange_weak
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d);
-}
-
-// atomic_compare_exchange_strong
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d);
-}
-
-// atomic_compare_exchange_weak_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
-                                      _Tp __d,
-                                      memory_order __s, memory_order __f) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d, __s, __f);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
-                                      memory_order __s, memory_order __f) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d, __s, __f);
-}
-
-// atomic_compare_exchange_strong_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
-                                        _Tp* __e, _Tp __d,
-                                        memory_order __s, memory_order __f) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d, __s, __f);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
-                                        _Tp __d,
-                                        memory_order __s, memory_order __f) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d, __s, __f);
-}
-
-// atomic_fetch_add
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-// atomic_fetch_add_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
-                          memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-// atomic_fetch_sub
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-// atomic_fetch_sub_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
-                          memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-// atomic_fetch_and
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_and(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_and(__op);
-}
-
-// atomic_fetch_and_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_and(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_and(__op, __m);
-}
-
-// atomic_fetch_or
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_or(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_or(__op);
-}
-
-// atomic_fetch_or_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_or(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_or(__op, __m);
-}
+// NOTE: freestanding atomic<*> functions are not supported, either use the corresponding member functions,
+// or use the freestanding floor atomic functions, which operate on raw global/local type pointers
 
-// atomic_fetch_xor
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_xor(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_xor(__op);
-}
-
-// atomic_fetch_xor_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_xor(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_xor(__op, __m);
-}
-
-// flag type and operations
-
-typedef struct atomic_flag
-{
-    _Atomic(bool) __a_;
-
-    _LIBCPP_INLINE_VISIBILITY
-    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, true, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool test_and_set(memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, true, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    void clear(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {__c11_atomic_store(&__a_, false, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    void clear(memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {__c11_atomic_store(&__a_, false, __m);}
-
-    _LIBCPP_INLINE_VISIBILITY
-#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
-    atomic_flag() _NOEXCEPT = default;
-#else
-    atomic_flag() _NOEXCEPT : __a_() {}
-#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
-
-    _LIBCPP_INLINE_VISIBILITY
-    atomic_flag(bool __b) _NOEXCEPT : __a_(__b) {}
-
-#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
-    atomic_flag(const atomic_flag&) = delete;
-    atomic_flag& operator=(const atomic_flag&) = delete;
-    atomic_flag& operator=(const atomic_flag&) volatile = delete;
-#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
-private:
-    atomic_flag(const atomic_flag&);
-    atomic_flag& operator=(const atomic_flag&);
-    atomic_flag& operator=(const atomic_flag&) volatile;
-#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
-} atomic_flag;
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set(volatile atomic_flag* __o) _NOEXCEPT
-{
-    return __o->test_and_set();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set(atomic_flag* __o) _NOEXCEPT
-{
-    return __o->test_and_set();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->test_and_set(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->test_and_set(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear(volatile atomic_flag* __o) _NOEXCEPT
-{
-    __o->clear();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear(atomic_flag* __o) _NOEXCEPT
-{
-    __o->clear();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    __o->clear(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    __o->clear(__m);
-}
+// NOTE: atomic_flag is not supported, use an appropriate atomic<uint32_t> instead
 
 // fences
 
@@ -1455,47 +792,48 @@ inline _LIBCPP_INLINE_VISIBILITY
 void
 atomic_thread_fence(memory_order __m) _NOEXCEPT
 {
-    __c11_atomic_thread_fence(__m);
+    floor_atomic_thread_fence(__m);
 }
 
 inline _LIBCPP_INLINE_VISIBILITY
 void
 atomic_signal_fence(memory_order __m) _NOEXCEPT
 {
-    __c11_atomic_signal_fence(__m);
+    floor_atomic_signal_fence(__m);
 }
 
 // Atomics for standard typedef types
 
-typedef atomic<bool>               atomic_bool;
-typedef atomic<char>               atomic_char;
-typedef atomic<signed char>        atomic_schar;
-typedef atomic<unsigned char>      atomic_uchar;
-typedef atomic<short>              atomic_short;
-typedef atomic<unsigned short>     atomic_ushort;
+// NOTE: commented out types are not supported!
+//typedef atomic<bool>               atomic_bool;
+//typedef atomic<char>               atomic_char;
+//typedef atomic<signed char>        atomic_schar;
+//typedef atomic<unsigned char>      atomic_uchar;
+//typedef atomic<short>              atomic_short;
+//typedef atomic<unsigned short>     atomic_ushort;
 typedef atomic<int>                atomic_int;
 typedef atomic<unsigned int>       atomic_uint;
 typedef atomic<long>               atomic_long;
 typedef atomic<unsigned long>      atomic_ulong;
 typedef atomic<long long>          atomic_llong;
 typedef atomic<unsigned long long> atomic_ullong;
-typedef atomic<char16_t>           atomic_char16_t;
+//typedef atomic<char16_t>           atomic_char16_t;
 typedef atomic<char32_t>           atomic_char32_t;
-typedef atomic<wchar_t>            atomic_wchar_t;
+//typedef atomic<wchar_t>            atomic_wchar_t;
 
-typedef atomic<int_least8_t>   atomic_int_least8_t;
-typedef atomic<uint_least8_t>  atomic_uint_least8_t;
-typedef atomic<int_least16_t>  atomic_int_least16_t;
-typedef atomic<uint_least16_t> atomic_uint_least16_t;
+//typedef atomic<int_least8_t>   atomic_int_least8_t;
+//typedef atomic<uint_least8_t>  atomic_uint_least8_t;
+//typedef atomic<int_least16_t>  atomic_int_least16_t;
+//typedef atomic<uint_least16_t> atomic_uint_least16_t;
 typedef atomic<int_least32_t>  atomic_int_least32_t;
 typedef atomic<uint_least32_t> atomic_uint_least32_t;
 typedef atomic<int_least64_t>  atomic_int_least64_t;
 typedef atomic<uint_least64_t> atomic_uint_least64_t;
 
-typedef atomic<int_fast8_t>   atomic_int_fast8_t;
-typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
-typedef atomic<int_fast16_t>  atomic_int_fast16_t;
-typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
+//typedef atomic<int_fast8_t>   atomic_int_fast8_t;
+//typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
+//typedef atomic<int_fast16_t>  atomic_int_fast16_t;
+//typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
 typedef atomic<int_fast32_t>  atomic_int_fast32_t;
 typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
 typedef atomic<int_fast64_t>  atomic_int_fast64_t;
@@ -1508,21 +846,21 @@ typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
 typedef atomic<intmax_t>  atomic_intmax_t;
 typedef atomic<uintmax_t> atomic_uintmax_t;
 
-#define ATOMIC_FLAG_INIT {false}
+#define ATOMIC_FLAG_INIT {0u}
 #define ATOMIC_VAR_INIT(__v) {__v}
 
 // lock-free property
 
-#define ATOMIC_BOOL_LOCK_FREE      __GCC_ATOMIC_BOOL_LOCK_FREE
-#define ATOMIC_CHAR_LOCK_FREE      __GCC_ATOMIC_CHAR_LOCK_FREE
-#define ATOMIC_CHAR16_T_LOCK_FREE  __GCC_ATOMIC_CHAR16_T_LOCK_FREE
-#define ATOMIC_CHAR32_T_LOCK_FREE  __GCC_ATOMIC_CHAR32_T_LOCK_FREE
-#define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE
-#define ATOMIC_SHORT_LOCK_FREE     __GCC_ATOMIC_SHORT_LOCK_FREE
-#define ATOMIC_INT_LOCK_FREE       __GCC_ATOMIC_INT_LOCK_FREE
-#define ATOMIC_LONG_LOCK_FREE      __GCC_ATOMIC_LONG_LOCK_FREE
-#define ATOMIC_LLONG_LOCK_FREE     __GCC_ATOMIC_LLONG_LOCK_FREE
-#define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE
+#define ATOMIC_BOOL_LOCK_FREE      false
+#define ATOMIC_CHAR_LOCK_FREE      false
+#define ATOMIC_CHAR16_T_LOCK_FREE  false
+#define ATOMIC_CHAR32_T_LOCK_FREE  true
+#define ATOMIC_WCHAR_T_LOCK_FREE   false
+#define ATOMIC_SHORT_LOCK_FREE     false
+#define ATOMIC_INT_LOCK_FREE       true
+#define ATOMIC_LONG_LOCK_FREE      FLOOR_ATOMIC_LONG_LOCK_FREE
+#define ATOMIC_LLONG_LOCK_FREE     FLOOR_ATOMIC_LLONG_LOCK_FREE
+#define ATOMIC_POINTER_LOCK_FREE   FLOOR_ATOMIC_POINTER_LOCK_FREE
 
 #endif  //  !__has_feature(cxx_atomic)
 
diff --git a/include/functional b/include/functional
index 416a9a9..656b1da 100644
--- a/include/functional
+++ b/include/functional
@@ -472,8 +472,10 @@ POLICY:  For non-variadic implementations, the number of arguments is limited
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
 #include <exception>
+#endif
 #include <memory>
 #include <tuple>
 
@@ -1828,16 +1830,16 @@ namespace placeholders
 
 template <int _Np> struct __ph {};
 
-_LIBCPP_FUNC_VIS extern __ph<1>   _1;
-_LIBCPP_FUNC_VIS extern __ph<2>   _2;
-_LIBCPP_FUNC_VIS extern __ph<3>   _3;
-_LIBCPP_FUNC_VIS extern __ph<4>   _4;
-_LIBCPP_FUNC_VIS extern __ph<5>   _5;
-_LIBCPP_FUNC_VIS extern __ph<6>   _6;
-_LIBCPP_FUNC_VIS extern __ph<7>   _7;
-_LIBCPP_FUNC_VIS extern __ph<8>   _8;
-_LIBCPP_FUNC_VIS extern __ph<9>   _9;
-_LIBCPP_FUNC_VIS extern __ph<10> _10;
+_LIBCPP_FUNC_VIS extern constant __ph<1>   _1;
+_LIBCPP_FUNC_VIS extern constant __ph<2>   _2;
+_LIBCPP_FUNC_VIS extern constant __ph<3>   _3;
+_LIBCPP_FUNC_VIS extern constant __ph<4>   _4;
+_LIBCPP_FUNC_VIS extern constant __ph<5>   _5;
+_LIBCPP_FUNC_VIS extern constant __ph<6>   _6;
+_LIBCPP_FUNC_VIS extern constant __ph<7>   _7;
+_LIBCPP_FUNC_VIS extern constant __ph<8>   _8;
+_LIBCPP_FUNC_VIS extern constant __ph<9>   _9;
+_LIBCPP_FUNC_VIS extern constant __ph<10> _10;
 
 }  // placeholders
 
diff --git a/include/iosfwd b/include/iosfwd
index d24c227..03eb1ed 100644
--- a/include/iosfwd
+++ b/include/iosfwd
@@ -87,7 +87,12 @@ typedef fpos<char_traits<wchar_t>::state_type> wstreampos;
 */
 
 #include <__config>
+#if 0
 #include <wchar.h>  // for mbstate_t
+#else
+// NOTE: not supported!
+typedef size_t mbstate_t;
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #pragma GCC system_header
diff --git a/include/limits b/include/limits
index 2216966..ebe5575 100644
--- a/include/limits
+++ b/include/limits
@@ -327,8 +327,8 @@ protected:
     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valf();}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf("");}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf("");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf((const char*)"");}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __FLT_DENORM_MIN__;}
 
     static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
@@ -373,8 +373,8 @@ protected:
     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_val();}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan("");}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans("");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans((const char*)"");}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __DBL_DENORM_MIN__;}
 
     static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
@@ -419,8 +419,8 @@ protected:
     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_vall();}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl("");}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl("");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl((const char*)"");}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __LDBL_DENORM_MIN__;}
 
 #if (defined(__ppc__) || defined(__ppc64__))
@@ -436,6 +436,54 @@ protected:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
 };
 
+#if defined(FLOOR_COMPUTE)
+template <>
+class __libcpp_numeric_limits<__fp16, true>
+{
+protected:
+    typedef __fp16 type;
+
+    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
+
+    static _LIBCPP_CONSTEXPR const bool is_signed = true;
+    static _LIBCPP_CONSTEXPR const int  digits = __HALF_MANT_DIG__;
+    static _LIBCPP_CONSTEXPR const int  digits10 = __HALF_DIG__;
+    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __HALF_MIN__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __HALF_MAX__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
+
+    static _LIBCPP_CONSTEXPR const bool is_integer = false;
+    static _LIBCPP_CONSTEXPR const bool is_exact = false;
+    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __HALF_EPSILON__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5h;}
+
+    static _LIBCPP_CONSTEXPR const int  min_exponent = __HALF_MIN_EXP__;
+    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __HALF_MIN_10_EXP__;
+    static _LIBCPP_CONSTEXPR const int  max_exponent = __HALF_MAX_EXP__;
+    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __HALF_MAX_10_EXP__;
+
+    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
+    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
+    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;
+    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
+    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valh();}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanh((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansh((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __HALF_DENORM_MIN__;}
+
+    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
+    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
+    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
+
+    static _LIBCPP_CONSTEXPR const bool traps = false;
+    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
+    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
+};
+#endif
+
 template <class _Tp>
 class _LIBCPP_TYPE_VIS_ONLY numeric_limits
     : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
@@ -482,6 +530,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_specialized;
 template <class _Tp>
@@ -528,6 +577,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<_Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TYPE_VIS_ONLY numeric_limits<const _Tp>
@@ -575,6 +625,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_specialized;
 template <class _Tp>
@@ -621,6 +672,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const _Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TYPE_VIS_ONLY numeric_limits<volatile _Tp>
@@ -668,6 +720,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_specialized;
 template <class _Tp>
@@ -714,6 +767,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<volatile _Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TYPE_VIS_ONLY numeric_limits<const volatile _Tp>
@@ -761,6 +815,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_specialized;
 template <class _Tp>
@@ -807,6 +862,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;
+#endif
 
 _LIBCPP_END_NAMESPACE_STD
 
diff --git a/include/memory b/include/memory
index dc9aeba..889e751 100644
--- a/include/memory
+++ b/include/memory
@@ -595,9 +595,13 @@ void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
+#endif
 #include <cstddef>
+#if 0
 #include <cstdint>
+#endif
 #include <new>
 #include <utility>
 #include <limits>
@@ -605,10 +609,12 @@ void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
 #include <__functional_base>
 #include <iosfwd>
 #include <tuple>
+#if 0
 #include <cstring>
 #if defined(_LIBCPP_NO_EXCEPTIONS)
     #include <cassert>
 #endif
+#endif
 
 #if __has_feature(cxx_atomic)
 #  include <atomic>
@@ -1520,7 +1526,7 @@ struct _LIBCPP_TYPE_VIS_ONLY allocator_traits
         __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
         {
             ptrdiff_t _Np = __end1 - __begin1;
-            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
+            __builtin_memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
             __begin2 += _Np;
         }
 
@@ -1551,7 +1557,7 @@ struct _LIBCPP_TYPE_VIS_ONLY allocator_traits
         {
             ptrdiff_t _Np = __end1 - __begin1;
             __end2 -= _Np;
-            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
+            __builtin_memcpy(__end2, __begin1, _Np * sizeof(_Tp));
         }
 
 private:
@@ -1818,6 +1824,7 @@ public:
         {raw_storage_iterator __t(*this); ++__x_; return __t;}
 };
 
+#if 0
 template <class _Tp>
 pair<_Tp*, ptrdiff_t>
 get_temporary_buffer(ptrdiff_t __n) _NOEXCEPT
@@ -1844,6 +1851,7 @@ get_temporary_buffer(ptrdiff_t __n) _NOEXCEPT
 template <class _Tp>
 inline _LIBCPP_INLINE_VISIBILITY
 void return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}
+#endif
 
 template <class _Tp>
 struct auto_ptr_ref
@@ -3070,7 +3078,7 @@ _Size
 __loadword(const void* __p)
 {
     _Size __r;
-    std::memcpy(&__r, __p, sizeof(__r));
+    __builtin_memcpy(&__r, __p, sizeof(__r));
     return __r;
 }
 
diff --git a/include/type_traits b/include/type_traits
index 371a15e..6f30679 100644
--- a/include/type_traits
+++ b/include/type_traits
@@ -244,8 +244,8 @@ struct _LIBCPP_TYPE_VIS_ONLY integral_constant
 #endif
 };
 
-template <class _Tp, _Tp __v>
-_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
+//template <class _Tp, _Tp __v>
+//_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
 
 typedef integral_constant<bool, true>  true_type;
 typedef integral_constant<bool, false> false_type;
@@ -339,6 +339,9 @@ template <class _Tp> struct __libcpp_is_floating_point              : public fal
 template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
 template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
 template <>          struct __libcpp_is_floating_point<long double> : public true_type {};
+#if defined(FLOOR_COMPUTE)
+template <>          struct __libcpp_is_floating_point<__fp16>      : public true_type {};
+#endif
 
 template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point
     : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
