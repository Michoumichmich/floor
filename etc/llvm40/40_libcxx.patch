diff --git a/include/__bit_reference b/include/__bit_reference
index 5659ed0..4c192be 100644
--- a/include/__bit_reference
+++ b/include/__bit_reference
@@ -337,7 +337,7 @@ __fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
     }
     // do middle whole words
     __storage_type __nw = __n / __bits_per_word;
-    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
+    __builtin_memset(_VSTD::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
     __n -= __nw * __bits_per_word;
     // do last partial word
     if (__n > 0)
@@ -367,7 +367,7 @@ __fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
     }
     // do middle whole words
     __storage_type __nw = __n / __bits_per_word;
-    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
+    __builtin_memset(_VSTD::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
     __n -= __nw * __bits_per_word;
     // do last partial word
     if (__n > 0)
@@ -434,9 +434,9 @@ __copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsCon
         // __first.__ctz_ == 0;
         // do middle words
         __storage_type __nw = __n / __bits_per_word;
-        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),
-                       _VSTD::__to_raw_pointer(__first.__seg_),
-                       __nw * sizeof(__storage_type));
+        __builtin_memmove(_VSTD::__to_raw_pointer(__result.__seg_),
+                          _VSTD::__to_raw_pointer(__first.__seg_),
+                          __nw * sizeof(__storage_type));
         __n -= __nw * __bits_per_word;
         __result.__seg_ += __nw;
         // do last word
@@ -575,9 +575,9 @@ __copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_C
         __storage_type __nw = __n / __bits_per_word;
         __result.__seg_ -= __nw;
         __last.__seg_ -= __nw;
-        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),
-                       _VSTD::__to_raw_pointer(__last.__seg_),
-                       __nw * sizeof(__storage_type));
+        __builtin_memmove(_VSTD::__to_raw_pointer(__result.__seg_),
+                          _VSTD::__to_raw_pointer(__last.__seg_),
+                          __nw * sizeof(__storage_type));
         __n -= __nw * __bits_per_word;
         // do last word
         if (__n > 0)
diff --git a/include/__config b/include/__config
index 353ca10..006ea8b 100644
--- a/include/__config
+++ b/include/__config
@@ -875,8 +875,6 @@ extern "C" void __sanitizer_annotate_contiguous_container(
 
 #if __has_feature(cxx_atomic) || __has_extension(c_atomic)
 #define _LIBCPP_HAS_C_ATOMIC_IMP
-#elif _GNUC_VER > 407
-#define _LIBCPP_HAS_GCC_ATOMIC_IMP
 #endif
 
 #if (!defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)) \
diff --git a/include/__functional_base b/include/__functional_base
index 1a08ea2..90a9e4a 100644
--- a/include/__functional_base
+++ b/include/__functional_base
@@ -13,9 +13,11 @@
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
 #include <exception>
 #include <new>
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #pragma GCC system_header
diff --git a/include/algorithm b/include/algorithm
index cf03d66..da25c8f 100644
--- a/include/algorithm
+++ b/include/algorithm
@@ -629,7 +629,9 @@ template <class BidirectionalIterator, class Compare>
 #include <__config>
 #include <initializer_list>
 #include <type_traits>
+#if 0
 #include <cstring>
+#endif
 #include <utility> // needed to provide swap_ranges.
 #include <memory>
 #include <iterator>
@@ -1767,7 +1769,7 @@ __copy(_Tp* __first, _Tp* __last, _Up* __result)
 {
     const size_t __n = static_cast<size_t>(__last - __first);
     if (__n > 0)
-        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+        __builtin_memmove(__result, __first, __n * sizeof(_Up));
     return __result + __n;
 }
 
@@ -1805,7 +1807,7 @@ __copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
     if (__n > 0)
     {
         __result -= __n;
-        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+        __builtin_memmove(__result, __first, __n * sizeof(_Up));
     }
     return __result;
 }
@@ -1904,7 +1906,7 @@ __move(_Tp* __first, _Tp* __last, _Up* __result)
 {
     const size_t __n = static_cast<size_t>(__last - __first);
     if (__n > 0)
-        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+        __builtin_memmove(__result, __first, __n * sizeof(_Up));
     return __result + __n;
 }
 
@@ -1942,7 +1944,7 @@ __move_backward(_Tp* __first, _Tp* __last, _Up* __result)
     if (__n > 0)
     {
         __result -= __n;
-        _VSTD::memmove(__result, __first, __n * sizeof(_Up));
+        __builtin_memmove(__result, __first, __n * sizeof(_Up));
     }
     return __result;
 }
@@ -2063,7 +2065,7 @@ typename enable_if
 __fill_n(_Tp* __first, _Size __n,_Up __value_)
 {
     if (__n > 0)
-        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));
+        __builtin_memset(__first, (unsigned char)__value_, (size_t)(__n));
     return __first + __n;
 }
 
@@ -3072,13 +3074,14 @@ uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p
     return static_cast<result_type>(__u + __p.a());
 }
 
+#if 0 // this is not supported
 class _LIBCPP_TYPE_VIS __rs_default;
 
 _LIBCPP_FUNC_VIS __rs_default __rs_get();
 
 class _LIBCPP_TYPE_VIS __rs_default
 {
-    static unsigned __c_;
+    static constant unsigned __c_ { 0u };
 
     __rs_default();
 public:
@@ -3120,6 +3123,7 @@ random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
         }
     }
 }
+#endif
 
 template <class _RandomAccessIterator, class _RandomNumberGenerator>
 void
@@ -3378,6 +3382,7 @@ __second_half_done:
     //         |
 }
 
+#if 0
 struct __return_temporary_buffer
 {
     template <class _Tp>
@@ -3414,6 +3419,7 @@ __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate
     return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                              (__first, __last, __pred, __len, __p, forward_iterator_tag());
 }
+#endif
 
 template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
 _BidirectionalIterator
@@ -3523,6 +3529,7 @@ __second_half_done:
     //         |
 }
 
+#if 0
 template <class _Predicate, class _BidirectionalIterator>
 _BidirectionalIterator
 __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
@@ -3562,6 +3569,7 @@ __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last
     return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                              (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
 }
+#endif
 
 template <class _ForwardIterator, class _Predicate>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -3866,188 +3874,30 @@ __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __c
     typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
     const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                     is_trivially_copy_assignable<value_type>::value ? 30 : 6;
-    while (true)
+
+    // compute note: keep the special cases if len <= 5, but always fallback to using
+    //               __insertion_sort_3 for len > 5 as it doesn't require recursion
+    difference_type __len = __last - __first;
+    switch (__len)
     {
-    __restart:
-        difference_type __len = __last - __first;
-        switch (__len)
-        {
-        case 0:
-        case 1:
-            return;
-        case 2:
-            if (__comp(*--__last, *__first))
-                swap(*__first, *__last);
-            return;
-        case 3:
-            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);
-            return;
-        case 4:
-            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
-            return;
-        case 5:
-            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
-            return;
-        }
-        if (__len <= __limit)
-        {
-            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);
-            return;
-        }
-        // __len > 5
-        _RandomAccessIterator __m = __first;
-        _RandomAccessIterator __lm1 = __last;
-        --__lm1;
-        unsigned __n_swaps;
-        {
-        difference_type __delta;
-        if (__len >= 1000)
-        {
-            __delta = __len/2;
-            __m += __delta;
-            __delta /= 2;
-            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
-        }
-        else
-        {
-            __delta = __len/2;
-            __m += __delta;
-            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);
-        }
-        }
-        // *__m is median
-        // partition [__first, __m) < *__m and *__m <= [__m, __last)
-        // (this inhibits tossing elements equivalent to __m around unnecessarily)
-        _RandomAccessIterator __i = __first;
-        _RandomAccessIterator __j = __lm1;
-        // j points beyond range to be tested, *__m is known to be <= *__lm1
-        // The search going up is known to be guarded but the search coming down isn't.
-        // Prime the downward search with a guard.
-        if (!__comp(*__i, *__m))  // if *__first == *__m
-        {
-            // *__first == *__m, *__first doesn't go in first part
-            // manually guard downward moving __j against __i
-            while (true)
-            {
-                if (__i == --__j)
-                {
-                    // *__first == *__m, *__m <= all other elements
-                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)
-                    ++__i;  // __first + 1
-                    __j = __last;
-                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)
-                    {
-                        while (true)
-                        {
-                            if (__i == __j)
-                                return;  // [__first, __last) all equivalent elements
-                            if (__comp(*__first, *__i))
-                            {
-                                swap(*__i, *__j);
-                                ++__n_swaps;
-                                ++__i;
-                                break;
-                            }
-                            ++__i;
-                        }
-                    }
-                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1
-                    if (__i == __j)
-                        return;
-                    while (true)
-                    {
-                        while (!__comp(*__first, *__i))
-                            ++__i;
-                        while (__comp(*__first, *--__j))
-                            ;
-                        if (__i >= __j)
-                            break;
-                        swap(*__i, *__j);
-                        ++__n_swaps;
-                        ++__i;
-                    }
-                    // [__first, __i) == *__first and *__first < [__i, __last)
-                    // The first part is sorted, sort the secod part
-                    // _VSTD::__sort<_Compare>(__i, __last, __comp);
-                    __first = __i;
-                    goto __restart;
-                }
-                if (__comp(*__j, *__m))
-                {
-                    swap(*__i, *__j);
-                    ++__n_swaps;
-                    break;  // found guard for downward moving __j, now use unguarded partition
-                }
-            }
-        }
-        // It is known that *__i < *__m
-        ++__i;
-        // j points beyond range to be tested, *__m is known to be <= *__lm1
-        // if not yet partitioned...
-        if (__i < __j)
-        {
-            // known that *(__i - 1) < *__m
-            // known that __i <= __m
-            while (true)
-            {
-                // __m still guards upward moving __i
-                while (__comp(*__i, *__m))
-                    ++__i;
-                // It is now known that a guard exists for downward moving __j
-                while (!__comp(*--__j, *__m))
-                    ;
-                if (__i > __j)
-                    break;
-                swap(*__i, *__j);
-                ++__n_swaps;
-                // It is known that __m != __j
-                // If __m just moved, follow it
-                if (__m == __i)
-                    __m = __j;
-                ++__i;
-            }
-        }
-        // [__first, __i) < *__m and *__m <= [__i, __last)
-        if (__i != __m && __comp(*__m, *__i))
-        {
-            swap(*__i, *__m);
-            ++__n_swaps;
-        }
-        // [__first, __i) < *__i and *__i <= [__i+1, __last)
-        // If we were given a perfect partition, see if insertion sort is quick...
-        if (__n_swaps == 0)
-        {
-            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
-            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
-            {
-                if (__fs)
-                    return;
-                __last = __i;
-                continue;
-            }
-            else
-            {
-                if (__fs)
-                {
-                    __first = ++__i;
-                    continue;
-                }
-            }
-        }
-        // sort smaller range with recursive call and larger with tail recursion elimination
-        if (__i - __first < __last - __i)
-        {
-            _VSTD::__sort<_Compare>(__first, __i, __comp);
-            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);
-            __first = ++__i;
-        }
-        else
-        {
-            _VSTD::__sort<_Compare>(__i+1, __last, __comp);
-            // _VSTD::__sort<_Compare>(__first, __i, __comp);
-            __last = __i;
-        }
+    case 0:
+    case 1:
+        return;
+    case 2:
+        if (__comp(*--__last, *__first))
+            swap(*__first, *__last);
+        return;
+    case 3:
+        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);
+        return;
+    case 4:
+        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
+        return;
+    case 5:
+        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
+        return;
     }
+    _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);
 }
 
 // This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare
@@ -4531,6 +4381,7 @@ __inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle,
     }
 }
 
+#if 0
 template <class _BidirectionalIterator, class _Compare>
 inline _LIBCPP_INLINE_VISIBILITY
 void
@@ -4556,6 +4407,7 @@ inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _
                                             __buf.first, __buf.second);
 #endif  // _LIBCPP_DEBUG
 }
+#endif
 
 template <class _BidirectionalIterator>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -4741,6 +4593,7 @@ __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp
     __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
 }
 
+#if 0
 template <class _RandomAccessIterator, class _Compare>
 inline _LIBCPP_INLINE_VISIBILITY
 void
@@ -4765,6 +4618,7 @@ stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compar
     __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
 #endif  // _LIBCPP_DEBUG
 }
+#endif
 
 template <class _RandomAccessIterator>
 inline _LIBCPP_INLINE_VISIBILITY
diff --git a/include/atomic b/include/atomic
index a25b5bf..7153214 100644
--- a/include/atomic
+++ b/include/atomic
@@ -542,17 +542,21 @@ void atomic_signal_fence(memory_order m) noexcept;
 
 #include <__config>
 #include <cstddef>
+#if 0
 #include <cstdint>
+#endif
 #include <type_traits>
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #pragma GCC system_header
 #endif
 
+#if 0
 #ifdef _LIBCPP_HAS_NO_THREADS
 #error <atomic> is not supported on this single threaded system
 #endif
-#if !defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
+#endif
+#if !defined(_LIBCPP_HAS_C_ATOMIC_IMP)
 #error <atomic> is not implemented
 #endif
 
@@ -562,280 +566,7 @@ void atomic_signal_fence(memory_order m) noexcept;
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
-typedef enum memory_order
-{
-    memory_order_relaxed, memory_order_consume, memory_order_acquire,
-    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
-} memory_order;
-
-#if defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
-namespace __gcc_atomic {
-template <typename _Tp>
-struct __gcc_atomic_t {
-
-#if _GNUC_VER >= 501
-    static_assert(is_trivially_copyable<_Tp>::value,
-      "std::atomic<Tp> requires that 'Tp' be a trivially copyable type");
-#endif
-
-  _LIBCPP_INLINE_VISIBILITY
-#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
-    __gcc_atomic_t() _NOEXCEPT = default;
-#else
-    __gcc_atomic_t() _NOEXCEPT : __a_value() {}
-#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
-  _LIBCPP_CONSTEXPR explicit __gcc_atomic_t(_Tp value) _NOEXCEPT
-    : __a_value(value) {}
-  _Tp __a_value;
-};
-#define _Atomic(x) __gcc_atomic::__gcc_atomic_t<x>
-
-template <typename _Tp> _Tp __create();
-
-template <typename _Tp, typename _Td>
-typename enable_if<sizeof(_Tp()->__a_value = __create<_Td>()), char>::type
-    __test_atomic_assignable(int);
-template <typename _Tp, typename _Up>
-__two __test_atomic_assignable(...);
-
-template <typename _Tp, typename _Td>
-struct __can_assign {
-  static const bool value =
-      sizeof(__test_atomic_assignable<_Tp, _Td>(1)) == sizeof(char);
-};
-
-static inline _LIBCPP_CONSTEXPR int __to_gcc_order(memory_order __order) {
-  // Avoid switch statement to make this a constexpr.
-  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:
-         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:
-          (__order == memory_order_release ? __ATOMIC_RELEASE:
-           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:
-            (__order == memory_order_acq_rel ? __ATOMIC_ACQ_REL:
-              __ATOMIC_CONSUME))));
-}
-
-static inline _LIBCPP_CONSTEXPR int __to_gcc_failure_order(memory_order __order) {
-  // Avoid switch statement to make this a constexpr.
-  return __order == memory_order_relaxed ? __ATOMIC_RELAXED:
-         (__order == memory_order_acquire ? __ATOMIC_ACQUIRE:
-          (__order == memory_order_release ? __ATOMIC_RELAXED:
-           (__order == memory_order_seq_cst ? __ATOMIC_SEQ_CST:
-            (__order == memory_order_acq_rel ? __ATOMIC_ACQUIRE:
-              __ATOMIC_CONSUME))));
-}
-
-} // namespace __gcc_atomic
-
-template <typename _Tp>
-static inline
-typename enable_if<
-    __gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value>::type
-__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {
-  __a->__a_value = __val;
-}
-
-template <typename _Tp>
-static inline
-typename enable_if<
-    !__gcc_atomic::__can_assign<volatile _Atomic(_Tp)*, _Tp>::value &&
-     __gcc_atomic::__can_assign<         _Atomic(_Tp)*, _Tp>::value>::type
-__c11_atomic_init(volatile _Atomic(_Tp)* __a,  _Tp __val) {
-  // [atomics.types.generic]p1 guarantees _Tp is trivially copyable. Because
-  // the default operator= in an object is not volatile, a byte-by-byte copy
-  // is required.
-  volatile char* to = reinterpret_cast<volatile char*>(&__a->__a_value);
-  volatile char* end = to + sizeof(_Tp);
-  char* from = reinterpret_cast<char*>(&__val);
-  while (to != end) {
-    *to++ = *from++;
-  }
-}
-
-template <typename _Tp>
-static inline void __c11_atomic_init(_Atomic(_Tp)* __a,  _Tp __val) {
-  __a->__a_value = __val;
-}
-
-static inline void __c11_atomic_thread_fence(memory_order __order) {
-  __atomic_thread_fence(__gcc_atomic::__to_gcc_order(__order));
-}
-
-static inline void __c11_atomic_signal_fence(memory_order __order) {
-  __atomic_signal_fence(__gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline void __c11_atomic_store(volatile _Atomic(_Tp)* __a,  _Tp __val,
-                                      memory_order __order) {
-  return __atomic_store(&__a->__a_value, &__val,
-                        __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline void __c11_atomic_store(_Atomic(_Tp)* __a,  _Tp __val,
-                                      memory_order __order) {
-  __atomic_store(&__a->__a_value, &__val,
-                 __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_load(volatile _Atomic(_Tp)* __a,
-                                    memory_order __order) {
-  _Tp __ret;
-  __atomic_load(&__a->__a_value, &__ret,
-                __gcc_atomic::__to_gcc_order(__order));
-  return __ret;
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_load(_Atomic(_Tp)* __a, memory_order __order) {
-  _Tp __ret;
-  __atomic_load(&__a->__a_value, &__ret,
-                __gcc_atomic::__to_gcc_order(__order));
-  return __ret;
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_exchange(volatile _Atomic(_Tp)* __a,
-                                        _Tp __value, memory_order __order) {
-  _Tp __ret;
-  __atomic_exchange(&__a->__a_value, &__value, &__ret,
-                    __gcc_atomic::__to_gcc_order(__order));
-  return __ret;
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_exchange(_Atomic(_Tp)* __a, _Tp __value,
-                                        memory_order __order) {
-  _Tp __ret;
-  __atomic_exchange(&__a->__a_value, &__value, &__ret,
-                    __gcc_atomic::__to_gcc_order(__order));
-  return __ret;
-}
-
-template <typename _Tp>
-static inline bool __c11_atomic_compare_exchange_strong(
-    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,
-    memory_order __success, memory_order __failure) {
-  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
-                                   false,
-                                   __gcc_atomic::__to_gcc_order(__success),
-                                   __gcc_atomic::__to_gcc_failure_order(__failure));
-}
-
-template <typename _Tp>
-static inline bool __c11_atomic_compare_exchange_strong(
-    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,
-    memory_order __failure) {
-  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
-                                   false,
-                                   __gcc_atomic::__to_gcc_order(__success),
-                                   __gcc_atomic::__to_gcc_failure_order(__failure));
-}
-
-template <typename _Tp>
-static inline bool __c11_atomic_compare_exchange_weak(
-    volatile _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value,
-    memory_order __success, memory_order __failure) {
-  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
-                                   true,
-                                   __gcc_atomic::__to_gcc_order(__success),
-                                   __gcc_atomic::__to_gcc_failure_order(__failure));
-}
-
-template <typename _Tp>
-static inline bool __c11_atomic_compare_exchange_weak(
-    _Atomic(_Tp)* __a, _Tp* __expected, _Tp __value, memory_order __success,
-    memory_order __failure) {
-  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
-                                   true,
-                                   __gcc_atomic::__to_gcc_order(__success),
-                                   __gcc_atomic::__to_gcc_failure_order(__failure));
-}
-
-template <typename _Tp>
-struct __skip_amt { enum {value = 1}; };
-
-template <typename _Tp>
-struct __skip_amt<_Tp*> { enum {value = sizeof(_Tp)}; };
-
-// FIXME: Haven't figured out what the spec says about using arrays with
-// atomic_fetch_add. Force a failure rather than creating bad behavior.
-template <typename _Tp>
-struct __skip_amt<_Tp[]> { };
-template <typename _Tp, int n>
-struct __skip_amt<_Tp[n]> { };
-
-template <typename _Tp, typename _Td>
-static inline _Tp __c11_atomic_fetch_add(volatile _Atomic(_Tp)* __a,
-                                         _Td __delta, memory_order __order) {
-  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp, typename _Td>
-static inline _Tp __c11_atomic_fetch_add(_Atomic(_Tp)* __a, _Td __delta,
-                                         memory_order __order) {
-  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp, typename _Td>
-static inline _Tp __c11_atomic_fetch_sub(volatile _Atomic(_Tp)* __a,
-                                         _Td __delta, memory_order __order) {
-  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp, typename _Td>
-static inline _Tp __c11_atomic_fetch_sub(_Atomic(_Tp)* __a, _Td __delta,
-                                         memory_order __order) {
-  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_and(volatile _Atomic(_Tp)* __a,
-                                         _Tp __pattern, memory_order __order) {
-  return __atomic_fetch_and(&__a->__a_value, __pattern,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_and(_Atomic(_Tp)* __a,
-                                         _Tp __pattern, memory_order __order) {
-  return __atomic_fetch_and(&__a->__a_value, __pattern,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_or(volatile _Atomic(_Tp)* __a,
-                                        _Tp __pattern, memory_order __order) {
-  return __atomic_fetch_or(&__a->__a_value, __pattern,
-                           __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_or(_Atomic(_Tp)* __a, _Tp __pattern,
-                                        memory_order __order) {
-  return __atomic_fetch_or(&__a->__a_value, __pattern,
-                           __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_xor(volatile _Atomic(_Tp)* __a,
-                                         _Tp __pattern, memory_order __order) {
-  return __atomic_fetch_xor(&__a->__a_value, __pattern,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-
-template <typename _Tp>
-static inline _Tp __c11_atomic_fetch_xor(_Atomic(_Tp)* __a, _Tp __pattern,
-                                         memory_order __order) {
-  return __atomic_fetch_xor(&__a->__a_value, __pattern,
-                            __gcc_atomic::__to_gcc_order(__order));
-}
-#endif // _LIBCPP_HAS_GCC_ATOMIC_IMP
+// NOTE: memory_order defined externally
 
 template <class _Tp>
 inline _LIBCPP_INLINE_VISIBILITY
@@ -845,23 +576,25 @@ kill_dependency(_Tp __y) _NOEXCEPT
     return __y;
 }
 
-#define ATOMIC_BOOL_LOCK_FREE      __GCC_ATOMIC_BOOL_LOCK_FREE
-#define ATOMIC_CHAR_LOCK_FREE      __GCC_ATOMIC_CHAR_LOCK_FREE
-#define ATOMIC_CHAR16_T_LOCK_FREE  __GCC_ATOMIC_CHAR16_T_LOCK_FREE
-#define ATOMIC_CHAR32_T_LOCK_FREE  __GCC_ATOMIC_CHAR32_T_LOCK_FREE
-#define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE
-#define ATOMIC_SHORT_LOCK_FREE     __GCC_ATOMIC_SHORT_LOCK_FREE
-#define ATOMIC_INT_LOCK_FREE       __GCC_ATOMIC_INT_LOCK_FREE
-#define ATOMIC_LONG_LOCK_FREE      __GCC_ATOMIC_LONG_LOCK_FREE
-#define ATOMIC_LLONG_LOCK_FREE     __GCC_ATOMIC_LLONG_LOCK_FREE
-#define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE
+#define ATOMIC_BOOL_LOCK_FREE      false
+#define ATOMIC_CHAR_LOCK_FREE      false
+#define ATOMIC_CHAR16_T_LOCK_FREE  false
+#define ATOMIC_CHAR32_T_LOCK_FREE  true
+#define ATOMIC_WCHAR_T_LOCK_FREE   false
+#define ATOMIC_SHORT_LOCK_FREE     false
+#define ATOMIC_INT_LOCK_FREE       true
+#define ATOMIC_LONG_LOCK_FREE      FLOOR_ATOMIC_LONG_LOCK_FREE
+#define ATOMIC_LLONG_LOCK_FREE     FLOOR_ATOMIC_LLONG_LOCK_FREE
+#define ATOMIC_POINTER_LOCK_FREE   FLOOR_ATOMIC_POINTER_LOCK_FREE
 
 // general atomic<T>
 
-template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
+template <class _Tp, class _TpAS = global _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
 struct __atomic_base  // false
 {
-    mutable _Atomic(_Tp) __a_;
+    typedef volatile _TpAS* _ptr_type;
+    
+    mutable volatile _Tp __a_;
 
 #if defined(__cpp_lib_atomic_is_always_lock_free)
   static _LIBCPP_CONSTEXPR bool is_always_lock_free = __atomic_always_lock_free(sizeof(__a_), 0);
@@ -869,90 +602,57 @@ struct __atomic_base  // false
 
     _LIBCPP_INLINE_VISIBILITY
     bool is_lock_free() const volatile _NOEXCEPT
-    {
-#if defined(_LIBCPP_HAS_C_ATOMIC_IMP)
-    return __c11_atomic_is_lock_free(sizeof(_Tp));
-#else
-    return __atomic_is_lock_free(sizeof(_Tp), 0);
-#endif
-    }
+        {return floor_atomic_is_lock_free(sizeof(_Tp));}
     _LIBCPP_INLINE_VISIBILITY
     bool is_lock_free() const _NOEXCEPT
-        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
+        {return floor_atomic_is_lock_free(sizeof(_Tp));}
     _LIBCPP_INLINE_VISIBILITY
-    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {__c11_atomic_store(&__a_, __d, __m);}
+    void store(_Tp __d, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {floor_atomic_store(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    void store(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {__c11_atomic_store(&__a_, __d, __m);}
+    void store(_Tp __d, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {floor_atomic_store(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp load(memory_order __m = memory_order_seq_cst) const volatile _NOEXCEPT
-        {return __c11_atomic_load(&__a_, __m);}
+    _Tp load(memory_order __m = memory_order_relaxed) const volatile _NOEXCEPT
+        {return floor_atomic_load(reinterpret_cast<_ptr_type>(&__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp load(memory_order __m = memory_order_seq_cst) const _NOEXCEPT
-        {return __c11_atomic_load(&__a_, __m);}
+    _Tp load(memory_order __m = memory_order_relaxed) const _NOEXCEPT
+        {return floor_atomic_load(reinterpret_cast<_ptr_type>(&__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
     operator _Tp() const volatile _NOEXCEPT {return load();}
     _LIBCPP_INLINE_VISIBILITY
     operator _Tp() const _NOEXCEPT          {return load();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, __d, __m);}
+    _Tp exchange(_Tp __d, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_exchange(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, __d, __m);}
+    _Tp exchange(_Tp __d, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_exchange(reinterpret_cast<_ptr_type>(&__a_), __d, __m);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
                                memory_order __s, memory_order __f) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
                                memory_order __s, memory_order __f) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                                 memory_order __s, memory_order __f) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                                 memory_order __s, memory_order __f) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __s, __f);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
-                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
+                              memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __m, __m);}
     _LIBCPP_INLINE_VISIBILITY
     bool compare_exchange_weak(_Tp& __e, _Tp __d,
-                               memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                              memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool compare_exchange_strong(_Tp& __e, _Tp __d,
-                                 memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
+                               memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_compare_exchange_weak(reinterpret_cast<_ptr_type>(&__a_), &__e, __d, __m, __m);}
 
     _LIBCPP_INLINE_VISIBILITY
-#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
     __atomic_base() _NOEXCEPT = default;
-#else
-    __atomic_base() _NOEXCEPT : __a_() {}
-#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
 
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __a_(__d) {}
-#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
     __atomic_base(const __atomic_base&) = delete;
     __atomic_base& operator=(const __atomic_base&) = delete;
     __atomic_base& operator=(const __atomic_base&) volatile = delete;
-#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
-private:
-    __atomic_base(const __atomic_base&);
-    __atomic_base& operator=(const __atomic_base&);
-    __atomic_base& operator=(const __atomic_base&) volatile;
-#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
 };
 
 #if defined(__cpp_lib_atomic_is_always_lock_free)
@@ -962,63 +662,78 @@ _LIBCPP_CONSTEXPR bool __atomic_base<_Tp, __b>::is_always_lock_free;
 
 // atomic<Integral>
 
-template <class _Tp>
-struct __atomic_base<_Tp, true>
-    : public __atomic_base<_Tp, false>
+template <class _Tp, class _TpAS>
+struct __atomic_base<_Tp, _TpAS, true>
+    : public __atomic_base<_Tp, _TpAS, false>
 {
-    typedef __atomic_base<_Tp, false> __base;
+    typedef volatile _TpAS* _ptr_type;
+    typedef __atomic_base<_Tp, _TpAS, false> __base;
     _LIBCPP_INLINE_VISIBILITY
     __atomic_base() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __base(__d) {}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_and(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_and(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_or(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
+    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_or(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_xor(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
+    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_xor(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
+
+    // non-standard inc/dec
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp _fetch_inc(memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_inc(reinterpret_cast<_ptr_type>(&this->__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
+    _Tp _fetch_inc(memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_inc(reinterpret_cast<_ptr_type>(&this->__a_), __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
+    _Tp _fetch_dec(memory_order __m = memory_order_relaxed) volatile _NOEXCEPT
+        {return floor_atomic_fetch_dec(reinterpret_cast<_ptr_type>(&this->__a_), __m);}
+    _LIBCPP_INLINE_VISIBILITY
+    _Tp _fetch_dec(memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_dec(reinterpret_cast<_ptr_type>(&this->__a_), __m);}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator++(int) volatile _NOEXCEPT      {return fetch_add(_Tp(1));}
+    _Tp operator++(int) volatile _NOEXCEPT      {return _fetch_inc();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator++(int) _NOEXCEPT               {return fetch_add(_Tp(1));}
+    _Tp operator++(int) _NOEXCEPT               {return _fetch_inc();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator--(int) volatile _NOEXCEPT      {return fetch_sub(_Tp(1));}
+    _Tp operator--(int) volatile _NOEXCEPT      {return _fetch_dec();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator--(int) _NOEXCEPT               {return fetch_sub(_Tp(1));}
+    _Tp operator--(int) _NOEXCEPT               {return _fetch_dec();}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator++() volatile _NOEXCEPT         {return fetch_add(_Tp(1)) + _Tp(1);}
+    _Tp operator++() volatile _NOEXCEPT         {return _fetch_inc() + _Tp(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator++() _NOEXCEPT                  {return fetch_add(_Tp(1)) + _Tp(1);}
+    _Tp operator++() _NOEXCEPT                  {return _fetch_inc() + _Tp(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator--() volatile _NOEXCEPT         {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _Tp operator--() volatile _NOEXCEPT         {return _fetch_dec() - _Tp(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp operator--() _NOEXCEPT                  {return fetch_sub(_Tp(1)) - _Tp(1);}
+    _Tp operator--() _NOEXCEPT                  {return _fetch_dec() - _Tp(1);}
     _LIBCPP_INLINE_VISIBILITY
     _Tp operator+=(_Tp __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
     _LIBCPP_INLINE_VISIBILITY
@@ -1043,11 +758,11 @@ struct __atomic_base<_Tp, true>
 
 // atomic<T>
 
-template <class _Tp>
+template <class _Tp, class _TpAS = global _Tp>
 struct atomic
-    : public __atomic_base<_Tp>
+    : public __atomic_base<_Tp, _TpAS>
 {
-    typedef __atomic_base<_Tp> __base;
+    typedef __atomic_base<_Tp, _TpAS> __base;
     _LIBCPP_INLINE_VISIBILITY
     atomic() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
@@ -1063,709 +778,70 @@ struct atomic
 
 // atomic<T*>
 
-template <class _Tp>
+template <class _Tp, class _TpAS>
 struct atomic<_Tp*>
-    : public __atomic_base<_Tp*>
+    : public __atomic_base<_Tp*, _TpAS*>
 {
+    typedef volatile _TpAS* _ptr_type;
     typedef __atomic_base<_Tp*> __base;
+    
     _LIBCPP_INLINE_VISIBILITY
     atomic() _NOEXCEPT _LIBCPP_DEFAULT
     _LIBCPP_INLINE_VISIBILITY
-    _LIBCPP_CONSTEXPR atomic(_Tp* __d) _NOEXCEPT : __base(__d) {}
+    _LIBCPP_CONSTEXPR atomic(_ptr_type __d) _NOEXCEPT : __base(__d) {}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator=(_Tp* __d) volatile _NOEXCEPT
+    _ptr_type operator=(_ptr_type __d) volatile _NOEXCEPT
         {__base::store(__d); return __d;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator=(_Tp* __d) _NOEXCEPT
+    _ptr_type operator=(_ptr_type __d) _NOEXCEPT
         {__base::store(__d); return __d;}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
+    _ptr_type fetch_add(ptrdiff_t __op, memory_order __m = memory_order_relaxed)
                                                                         volatile _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
+    _ptr_type fetch_add(ptrdiff_t __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_add(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
+    _ptr_type fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_relaxed)
                                                                         volatile _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
+    _ptr_type fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_relaxed) _NOEXCEPT
+        {return floor_atomic_fetch_sub(reinterpret_cast<_ptr_type>(&this->__a_), __op, __m);}
 
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}
+    _ptr_type operator++(int) volatile _NOEXCEPT            {return fetch_add(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++(int) _NOEXCEPT                     {return fetch_add(1);}
+    _ptr_type operator++(int) _NOEXCEPT                     {return fetch_add(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}
+    _ptr_type operator--(int) volatile _NOEXCEPT            {return fetch_sub(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--(int) _NOEXCEPT                     {return fetch_sub(1);}
+    _ptr_type operator--(int) _NOEXCEPT                     {return fetch_sub(1);}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}
+    _ptr_type operator++() volatile _NOEXCEPT               {return fetch_add(1) + 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}
+    _ptr_type operator++() _NOEXCEPT                        {return fetch_add(1) + 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}
+    _ptr_type operator--() volatile _NOEXCEPT               {return fetch_sub(1) - 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}
+    _ptr_type operator--() _NOEXCEPT                        {return fetch_sub(1) - 1;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
+    _ptr_type operator+=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_add(__op) + __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
+    _ptr_type operator+=(ptrdiff_t __op) _NOEXCEPT          {return fetch_add(__op) + __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
+    _ptr_type operator-=(ptrdiff_t __op) volatile _NOEXCEPT {return fetch_sub(__op) - __op;}
     _LIBCPP_INLINE_VISIBILITY
-    _Tp* operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
+    _ptr_type operator-=(ptrdiff_t __op) _NOEXCEPT          {return fetch_sub(__op) - __op;}
 };
 
-// atomic_is_lock_free
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_is_lock_free(const volatile atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->is_lock_free();
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_is_lock_free(const atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->is_lock_free();
-}
-
-// atomic_init
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_init(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __c11_atomic_init(&__o->__a_, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_init(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __c11_atomic_init(&__o->__a_, __d);
-}
-
-// atomic_store
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __o->store(__d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    __o->store(__d);
-}
-
-// atomic_store_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    __o->store(__d, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    __o->store(__d, __m);
-}
-
-// atomic_load
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load(const volatile atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->load();
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load(const atomic<_Tp>* __o) _NOEXCEPT
-{
-    return __o->load();
-}
-
-// atomic_load_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->load(__m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->load(__m);
-}
-
-// atomic_exchange
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    return __o->exchange(__d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT
-{
-    return __o->exchange(__d);
-}
-
-// atomic_exchange_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    return __o->exchange(__d, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp
-atomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT
-{
-    return __o->exchange(__d, __m);
-}
-
-// atomic_compare_exchange_weak
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d);
-}
-
-// atomic_compare_exchange_strong
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d);
-}
-
-// atomic_compare_exchange_weak_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
-                                      _Tp __d,
-                                      memory_order __s, memory_order __f) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d, __s, __f);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
-                                      memory_order __s, memory_order __f) _NOEXCEPT
-{
-    return __o->compare_exchange_weak(*__e, __d, __s, __f);
-}
-
-// atomic_compare_exchange_strong_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
-                                        _Tp* __e, _Tp __d,
-                                        memory_order __s, memory_order __f) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d, __s, __f);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
-                                        _Tp __d,
-                                        memory_order __s, memory_order __f) _NOEXCEPT
-{
-    return __o->compare_exchange_strong(*__e, __d, __s, __f);
-}
-
-// atomic_fetch_add
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_add(__op);
-}
-
-// atomic_fetch_add_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
-                          memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_add(__op, __m);
-}
-
-// atomic_fetch_sub
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) _NOEXCEPT
-{
-    return __o->fetch_sub(__op);
-}
-
-// atomic_fetch_sub_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
-                          memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-_Tp*
-atomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_sub(__op, __m);
-}
-
-// atomic_fetch_and
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_and(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_and(__op);
-}
-
-// atomic_fetch_and_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_and(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_and(__op, __m);
-}
-
-// atomic_fetch_or
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_or(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_or(__op);
-}
-
-// atomic_fetch_or_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_or(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_or(__op, __m);
-}
-
-// atomic_fetch_xor
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_xor(__op);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT
-{
-    return __o->fetch_xor(__op);
-}
-
-// atomic_fetch_xor_explicit
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_xor(__op, __m);
-}
-
-template <class _Tp>
-inline _LIBCPP_INLINE_VISIBILITY
-typename enable_if
-<
-    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
-    _Tp
->::type
-atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT
-{
-    return __o->fetch_xor(__op, __m);
-}
-
-// flag type and operations
-
-typedef struct atomic_flag
-{
-    _Atomic(bool) __a_;
-
-    _LIBCPP_INLINE_VISIBILITY
-    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, true, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    bool test_and_set(memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {return __c11_atomic_exchange(&__a_, true, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    void clear(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT
-        {__c11_atomic_store(&__a_, false, __m);}
-    _LIBCPP_INLINE_VISIBILITY
-    void clear(memory_order __m = memory_order_seq_cst) _NOEXCEPT
-        {__c11_atomic_store(&__a_, false, __m);}
-
-    _LIBCPP_INLINE_VISIBILITY
-#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
-    atomic_flag() _NOEXCEPT = default;
-#else
-    atomic_flag() _NOEXCEPT : __a_() {}
-#endif // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
-
-    _LIBCPP_INLINE_VISIBILITY
-    atomic_flag(bool __b) _NOEXCEPT : __a_(__b) {} // EXTENSION
-
-#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
-    atomic_flag(const atomic_flag&) = delete;
-    atomic_flag& operator=(const atomic_flag&) = delete;
-    atomic_flag& operator=(const atomic_flag&) volatile = delete;
-#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
-private:
-    atomic_flag(const atomic_flag&);
-    atomic_flag& operator=(const atomic_flag&);
-    atomic_flag& operator=(const atomic_flag&) volatile;
-#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
-} atomic_flag;
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set(volatile atomic_flag* __o) _NOEXCEPT
-{
-    return __o->test_and_set();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set(atomic_flag* __o) _NOEXCEPT
-{
-    return __o->test_and_set();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->test_and_set(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-bool
-atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    return __o->test_and_set(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear(volatile atomic_flag* __o) _NOEXCEPT
-{
-    __o->clear();
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear(atomic_flag* __o) _NOEXCEPT
-{
-    __o->clear();
-}
+// NOTE: freestanding atomic<*> functions are not supported, either use the corresponding member functions,
+// or use the freestanding floor atomic functions, which operate on raw global/local type pointers
 
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    __o->clear(__m);
-}
-
-inline _LIBCPP_INLINE_VISIBILITY
-void
-atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT
-{
-    __o->clear(__m);
-}
+// NOTE: atomic_flag is not supported, use an appropriate atomic<uint32_t> instead
 
 // fences
 
@@ -1773,47 +849,48 @@ inline _LIBCPP_INLINE_VISIBILITY
 void
 atomic_thread_fence(memory_order __m) _NOEXCEPT
 {
-    __c11_atomic_thread_fence(__m);
+    floor_atomic_thread_fence(__m);
 }
 
 inline _LIBCPP_INLINE_VISIBILITY
 void
 atomic_signal_fence(memory_order __m) _NOEXCEPT
 {
-    __c11_atomic_signal_fence(__m);
+    floor_atomic_signal_fence(__m);
 }
 
 // Atomics for standard typedef types
 
-typedef atomic<bool>               atomic_bool;
-typedef atomic<char>               atomic_char;
-typedef atomic<signed char>        atomic_schar;
-typedef atomic<unsigned char>      atomic_uchar;
-typedef atomic<short>              atomic_short;
-typedef atomic<unsigned short>     atomic_ushort;
+// NOTE: commented out types are not supported!
+//typedef atomic<bool>               atomic_bool;
+//typedef atomic<char>               atomic_char;
+//typedef atomic<signed char>        atomic_schar;
+//typedef atomic<unsigned char>      atomic_uchar;
+//typedef atomic<short>              atomic_short;
+//typedef atomic<unsigned short>     atomic_ushort;
 typedef atomic<int>                atomic_int;
 typedef atomic<unsigned int>       atomic_uint;
 typedef atomic<long>               atomic_long;
 typedef atomic<unsigned long>      atomic_ulong;
 typedef atomic<long long>          atomic_llong;
 typedef atomic<unsigned long long> atomic_ullong;
-typedef atomic<char16_t>           atomic_char16_t;
+//typedef atomic<char16_t>           atomic_char16_t;
 typedef atomic<char32_t>           atomic_char32_t;
-typedef atomic<wchar_t>            atomic_wchar_t;
+//typedef atomic<wchar_t>            atomic_wchar_t;
 
-typedef atomic<int_least8_t>   atomic_int_least8_t;
-typedef atomic<uint_least8_t>  atomic_uint_least8_t;
-typedef atomic<int_least16_t>  atomic_int_least16_t;
-typedef atomic<uint_least16_t> atomic_uint_least16_t;
+//typedef atomic<int_least8_t>   atomic_int_least8_t;
+//typedef atomic<uint_least8_t>  atomic_uint_least8_t;
+//typedef atomic<int_least16_t>  atomic_int_least16_t;
+//typedef atomic<uint_least16_t> atomic_uint_least16_t;
 typedef atomic<int_least32_t>  atomic_int_least32_t;
 typedef atomic<uint_least32_t> atomic_uint_least32_t;
 typedef atomic<int_least64_t>  atomic_int_least64_t;
 typedef atomic<uint_least64_t> atomic_uint_least64_t;
 
-typedef atomic<int_fast8_t>   atomic_int_fast8_t;
-typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
-typedef atomic<int_fast16_t>  atomic_int_fast16_t;
-typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
+//typedef atomic<int_fast8_t>   atomic_int_fast8_t;
+//typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;
+//typedef atomic<int_fast16_t>  atomic_int_fast16_t;
+//typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
 typedef atomic<int_fast32_t>  atomic_int_fast32_t;
 typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
 typedef atomic<int_fast64_t>  atomic_int_fast64_t;
@@ -1835,7 +912,7 @@ typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
 typedef atomic<intmax_t>  atomic_intmax_t;
 typedef atomic<uintmax_t> atomic_uintmax_t;
 
-#define ATOMIC_FLAG_INIT {false}
+#define ATOMIC_FLAG_INIT {0u}
 #define ATOMIC_VAR_INIT(__v) {__v}
 
 _LIBCPP_END_NAMESPACE_STD
diff --git a/include/cstddef b/include/cstddef
index edd106c..2a6df0c 100644
--- a/include/cstddef
+++ b/include/cstddef
@@ -39,8 +39,7 @@ Types:
 #pragma GCC system_header
 #endif
 
-// Don't include our own <stddef.h>; we don't want to declare ::nullptr_t.
-#include_next <stddef.h>
+#include <stddef.h>
 #include <__nullptr>
 
 _LIBCPP_BEGIN_NAMESPACE_STD
diff --git a/include/exception b/include/exception
index 186d379..d4efd74 100644
--- a/include/exception
+++ b/include/exception
@@ -80,10 +80,12 @@ template <class E> void rethrow_if_nested(const E& e);
 #include <__config>
 #include <cstddef>
 #include <type_traits>
+#if 0
 #if defined(_LIBCPP_NO_EXCEPTIONS)
 #include <cstdio>
 #include <cstdlib>
 #endif
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #pragma GCC system_header
@@ -263,9 +265,11 @@ inline void __libcpp_throw(_Exception const& __e) {
 #ifndef _LIBCPP_NO_EXCEPTIONS
     throw __e;
 #else
+#if 0
     _VSTD::fprintf(stderr, "%s\n", __e.what());
     _VSTD::abort();
 #endif
+#endif
 }
 
 _LIBCPP_END_NAMESPACE_STD
diff --git a/include/float.h b/include/float.h
deleted file mode 100644
index 1acfdc6..0000000
--- a/include/float.h
+++ /dev/null
@@ -1,83 +0,0 @@
-// -*- C++ -*-
-//===--------------------------- float.h ----------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef _LIBCPP_FLOAT_H
-#define _LIBCPP_FLOAT_H
-
-/*
-    float.h synopsis
-
-Macros:
-
-    FLT_ROUNDS
-    FLT_EVAL_METHOD     // C99
-    FLT_RADIX
-
-    FLT_MANT_DIG
-    DBL_MANT_DIG
-    LDBL_MANT_DIG
-
-    DECIMAL_DIG         // C99
-
-    FLT_DIG
-    DBL_DIG
-    LDBL_DIG
-
-    FLT_MIN_EXP
-    DBL_MIN_EXP
-    LDBL_MIN_EXP
-
-    FLT_MIN_10_EXP
-    DBL_MIN_10_EXP
-    LDBL_MIN_10_EXP
-
-    FLT_MAX_EXP
-    DBL_MAX_EXP
-    LDBL_MAX_EXP
-
-    FLT_MAX_10_EXP
-    DBL_MAX_10_EXP
-    LDBL_MAX_10_EXP
-
-    FLT_MAX
-    DBL_MAX
-    LDBL_MAX
-
-    FLT_EPSILON
-    DBL_EPSILON
-    LDBL_EPSILON
-
-    FLT_MIN
-    DBL_MIN
-    LDBL_MIN
-
-*/
-
-#include <__config>
-
-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-#pragma GCC system_header
-#endif
-
-#include_next <float.h>
-
-#ifdef __cplusplus
-
-#ifndef FLT_EVAL_METHOD
-#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
-#endif
-
-#ifndef DECIMAL_DIG
-#define DECIMAL_DIG __DECIMAL_DIG__
-#endif
-
-#endif // __cplusplus
-
-#endif  // _LIBCPP_FLOAT_H
diff --git a/include/functional b/include/functional
index 2056ffe..ad5f592 100644
--- a/include/functional
+++ b/include/functional
@@ -474,8 +474,10 @@ POLICY:  For non-variadic implementations, the number of arguments is limited
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
 #include <exception>
+#endif
 #include <memory>
 #include <tuple>
 
@@ -1972,16 +1974,16 @@ namespace placeholders
 template <int _Np> struct __ph {};
 
 #if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)
-_LIBCPP_FUNC_VIS extern const __ph<1>   _1;
-_LIBCPP_FUNC_VIS extern const __ph<2>   _2;
-_LIBCPP_FUNC_VIS extern const __ph<3>   _3;
-_LIBCPP_FUNC_VIS extern const __ph<4>   _4;
-_LIBCPP_FUNC_VIS extern const __ph<5>   _5;
-_LIBCPP_FUNC_VIS extern const __ph<6>   _6;
-_LIBCPP_FUNC_VIS extern const __ph<7>   _7;
-_LIBCPP_FUNC_VIS extern const __ph<8>   _8;
-_LIBCPP_FUNC_VIS extern const __ph<9>   _9;
-_LIBCPP_FUNC_VIS extern const __ph<10> _10;
+_LIBCPP_FUNC_VIS extern constant __ph<1>   _1;
+_LIBCPP_FUNC_VIS extern constant __ph<2>   _2;
+_LIBCPP_FUNC_VIS extern constant __ph<3>   _3;
+_LIBCPP_FUNC_VIS extern constant __ph<4>   _4;
+_LIBCPP_FUNC_VIS extern constant __ph<5>   _5;
+_LIBCPP_FUNC_VIS extern constant __ph<6>   _6;
+_LIBCPP_FUNC_VIS extern constant __ph<7>   _7;
+_LIBCPP_FUNC_VIS extern constant __ph<8>   _8;
+_LIBCPP_FUNC_VIS extern constant __ph<9>   _9;
+_LIBCPP_FUNC_VIS extern constant __ph<10> _10;
 #else
 constexpr __ph<1>   _1{};
 constexpr __ph<2>   _2{};
diff --git a/include/inttypes.h b/include/inttypes.h
deleted file mode 100644
index 5c5618b..0000000
--- a/include/inttypes.h
+++ /dev/null
@@ -1,251 +0,0 @@
-// -*- C++ -*-
-//===--------------------------- inttypes.h -------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef _LIBCPP_INTTYPES_H
-#define _LIBCPP_INTTYPES_H
-
-/*
-    inttypes.h synopsis
-
-This entire header is C99 / C++0X
-
-#include <stdint.h>  // <cinttypes> includes <cstdint>
-
-Macros:
-
-    PRId8
-    PRId16
-    PRId32
-    PRId64
-
-    PRIdLEAST8
-    PRIdLEAST16
-    PRIdLEAST32
-    PRIdLEAST64
-
-    PRIdFAST8
-    PRIdFAST16
-    PRIdFAST32
-    PRIdFAST64
-
-    PRIdMAX
-    PRIdPTR
-
-    PRIi8
-    PRIi16
-    PRIi32
-    PRIi64
-
-    PRIiLEAST8
-    PRIiLEAST16
-    PRIiLEAST32
-    PRIiLEAST64
-
-    PRIiFAST8
-    PRIiFAST16
-    PRIiFAST32
-    PRIiFAST64
-
-    PRIiMAX
-    PRIiPTR
-
-    PRIo8
-    PRIo16
-    PRIo32
-    PRIo64
-
-    PRIoLEAST8
-    PRIoLEAST16
-    PRIoLEAST32
-    PRIoLEAST64
-
-    PRIoFAST8
-    PRIoFAST16
-    PRIoFAST32
-    PRIoFAST64
-
-    PRIoMAX
-    PRIoPTR
-
-    PRIu8
-    PRIu16
-    PRIu32
-    PRIu64
-
-    PRIuLEAST8
-    PRIuLEAST16
-    PRIuLEAST32
-    PRIuLEAST64
-
-    PRIuFAST8
-    PRIuFAST16
-    PRIuFAST32
-    PRIuFAST64
-
-    PRIuMAX
-    PRIuPTR
-
-    PRIx8
-    PRIx16
-    PRIx32
-    PRIx64
-
-    PRIxLEAST8
-    PRIxLEAST16
-    PRIxLEAST32
-    PRIxLEAST64
-
-    PRIxFAST8
-    PRIxFAST16
-    PRIxFAST32
-    PRIxFAST64
-
-    PRIxMAX
-    PRIxPTR
-
-    PRIX8
-    PRIX16
-    PRIX32
-    PRIX64
-
-    PRIXLEAST8
-    PRIXLEAST16
-    PRIXLEAST32
-    PRIXLEAST64
-
-    PRIXFAST8
-    PRIXFAST16
-    PRIXFAST32
-    PRIXFAST64
-
-    PRIXMAX
-    PRIXPTR
-
-    SCNd8
-    SCNd16
-    SCNd32
-    SCNd64
-
-    SCNdLEAST8
-    SCNdLEAST16
-    SCNdLEAST32
-    SCNdLEAST64
-
-    SCNdFAST8
-    SCNdFAST16
-    SCNdFAST32
-    SCNdFAST64
-
-    SCNdMAX
-    SCNdPTR
-
-    SCNi8
-    SCNi16
-    SCNi32
-    SCNi64
-
-    SCNiLEAST8
-    SCNiLEAST16
-    SCNiLEAST32
-    SCNiLEAST64
-
-    SCNiFAST8
-    SCNiFAST16
-    SCNiFAST32
-    SCNiFAST64
-
-    SCNiMAX
-    SCNiPTR
-
-    SCNo8
-    SCNo16
-    SCNo32
-    SCNo64
-
-    SCNoLEAST8
-    SCNoLEAST16
-    SCNoLEAST32
-    SCNoLEAST64
-
-    SCNoFAST8
-    SCNoFAST16
-    SCNoFAST32
-    SCNoFAST64
-
-    SCNoMAX
-    SCNoPTR
-
-    SCNu8
-    SCNu16
-    SCNu32
-    SCNu64
-
-    SCNuLEAST8
-    SCNuLEAST16
-    SCNuLEAST32
-    SCNuLEAST64
-
-    SCNuFAST8
-    SCNuFAST16
-    SCNuFAST32
-    SCNuFAST64
-
-    SCNuMAX
-    SCNuPTR
-
-    SCNx8
-    SCNx16
-    SCNx32
-    SCNx64
-
-    SCNxLEAST8
-    SCNxLEAST16
-    SCNxLEAST32
-    SCNxLEAST64
-
-    SCNxFAST8
-    SCNxFAST16
-    SCNxFAST32
-    SCNxFAST64
-
-    SCNxMAX
-    SCNxPTR
-
-Types:
-
-    imaxdiv_t
-
-intmax_t  imaxabs(intmax_t j);
-imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
-intmax_t  strtoimax(const char* restrict nptr, char** restrict endptr, int base);
-uintmax_t strtoumax(const char* restrict nptr, char** restrict endptr, int base);
-intmax_t  wcstoimax(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
-uintmax_t wcstoumax(const wchar_t* restrict nptr, wchar_t** restrict endptr, int base);
-
-*/
-
-#include <__config>
-
-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-#pragma GCC system_header
-#endif
-
-#include_next <inttypes.h>
-
-#ifdef __cplusplus
-
-#include <stdint.h>
-
-#undef imaxabs
-#undef imaxdiv
-
-#endif // __cplusplus
-
-#endif  // _LIBCPP_INTTYPES_H
diff --git a/include/iosfwd b/include/iosfwd
index e4149ef..d621ecd 100644
--- a/include/iosfwd
+++ b/include/iosfwd
@@ -87,7 +87,12 @@ typedef fpos<char_traits<wchar_t>::state_type> wstreampos;
 */
 
 #include <__config>
+#if 0
 #include <wchar.h>  // for mbstate_t
+#else
+// NOTE: not supported!
+typedef size_t mbstate_t;
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #pragma GCC system_header
diff --git a/include/limits b/include/limits
index 80a1be4..8f8a657 100644
--- a/include/limits
+++ b/include/limits
@@ -328,8 +328,8 @@ protected:
     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valf();}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf("");}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf("");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf((const char*)"");}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __FLT_DENORM_MIN__;}
 
     static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
@@ -374,8 +374,8 @@ protected:
     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_val();}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan("");}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans("");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans((const char*)"");}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __DBL_DENORM_MIN__;}
 
     static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
@@ -420,8 +420,8 @@ protected:
     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_vall();}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl("");}
-    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl("");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl((const char*)"");}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __LDBL_DENORM_MIN__;}
 
 #if (defined(__ppc__) || defined(__ppc64__))
@@ -437,6 +437,54 @@ protected:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
 };
 
+#if defined(FLOOR_COMPUTE)
+template <>
+class __libcpp_numeric_limits<__fp16, true>
+{
+protected:
+    typedef __fp16 type;
+
+    static _LIBCPP_CONSTEXPR const bool is_specialized = true;
+
+    static _LIBCPP_CONSTEXPR const bool is_signed = true;
+    static _LIBCPP_CONSTEXPR const int  digits = __HALF_MANT_DIG__;
+    static _LIBCPP_CONSTEXPR const int  digits10 = __HALF_DIG__;
+    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __HALF_MIN__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __HALF_MAX__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}
+
+    static _LIBCPP_CONSTEXPR const bool is_integer = false;
+    static _LIBCPP_CONSTEXPR const bool is_exact = false;
+    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __HALF_EPSILON__;}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5h;}
+
+    static _LIBCPP_CONSTEXPR const int  min_exponent = __HALF_MIN_EXP__;
+    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __HALF_MIN_10_EXP__;
+    static _LIBCPP_CONSTEXPR const int  max_exponent = __HALF_MAX_EXP__;
+    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __HALF_MAX_10_EXP__;
+
+    static _LIBCPP_CONSTEXPR const bool has_infinity = true;
+    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;
+    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;
+    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;
+    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valh();}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanh((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansh((const char*)"");}
+    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __HALF_DENORM_MIN__;}
+
+    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;
+    static _LIBCPP_CONSTEXPR const bool is_bounded = true;
+    static _LIBCPP_CONSTEXPR const bool is_modulo = false;
+
+    static _LIBCPP_CONSTEXPR const bool traps = false;
+    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;
+    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;
+};
+#endif
+
 template <class _Tp>
 class _LIBCPP_TYPE_VIS_ONLY numeric_limits
     : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
@@ -483,6 +531,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_specialized;
 template <class _Tp>
@@ -529,6 +578,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<_Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TYPE_VIS_ONLY numeric_limits<const _Tp>
@@ -576,6 +626,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_specialized;
 template <class _Tp>
@@ -622,6 +673,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const _Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TYPE_VIS_ONLY numeric_limits<volatile _Tp>
@@ -669,6 +721,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_specialized;
 template <class _Tp>
@@ -715,6 +768,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<volatile _Tp>::round_style;
+#endif
 
 template <class _Tp>
 class _LIBCPP_TYPE_VIS_ONLY numeric_limits<const volatile _Tp>
@@ -762,6 +816,7 @@ public:
     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;
 };
 
+#if 0
 template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_specialized;
 template <class _Tp>
@@ -808,6 +863,7 @@ template <class _Tp>
     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;
 template <class _Tp>
     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;
+#endif
 
 _LIBCPP_END_NAMESPACE_STD
 
diff --git a/include/memory b/include/memory
index 5cdb60f..d56fc3d 100644
--- a/include/memory
+++ b/include/memory
@@ -625,9 +625,13 @@ void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
 
 #include <__config>
 #include <type_traits>
+#if 0
 #include <typeinfo>
+#endif
 #include <cstddef>
+#if 0
 #include <cstdint>
+#endif
 #include <new>
 #include <utility>
 #include <limits>
@@ -636,10 +640,12 @@ void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
 #include <iosfwd>
 #include <tuple>
 #include <stdexcept>
+#if 0
 #include <cstring>
 #if defined(_LIBCPP_NO_EXCEPTIONS)
     #include <cassert>
 #endif
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
 #  include <atomic>
@@ -1600,7 +1606,7 @@ struct _LIBCPP_TYPE_VIS_ONLY allocator_traits
             ptrdiff_t _Np = __end1 - __begin1;
             if (_Np > 0)
             {
-                _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
+                __builtin_memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
                 __begin2 += _Np;
             }
         }
@@ -1631,7 +1637,7 @@ struct _LIBCPP_TYPE_VIS_ONLY allocator_traits
             ptrdiff_t _Np = __end1 - __begin1;
             if (_Np > 0)
             {
-                _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));
+                __builtin_memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));
                 __begin2 += _Np;
             }
         }
@@ -1664,7 +1670,7 @@ struct _LIBCPP_TYPE_VIS_ONLY allocator_traits
             ptrdiff_t _Np = __end1 - __begin1;
             __end2 -= _Np;
             if (_Np > 0)
-                _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
+                __builtin_memcpy(__end2, __begin1, _Np * sizeof(_Tp));
         }
 
 private:
@@ -1960,6 +1966,7 @@ public:
 #endif
 };
 
+#if 0
 template <class _Tp>
 pair<_Tp*, ptrdiff_t>
 get_temporary_buffer(ptrdiff_t __n) _NOEXCEPT
@@ -1986,6 +1993,7 @@ get_temporary_buffer(ptrdiff_t __n) _NOEXCEPT
 template <class _Tp>
 inline _LIBCPP_INLINE_VISIBILITY
 void return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}
+#endif
 
 template <class _Tp>
 struct auto_ptr_ref
@@ -3198,7 +3206,7 @@ _Size
 __loadword(const void* __p)
 {
     _Size __r;
-    std::memcpy(&__r, __p, sizeof(__r));
+    __builtin_memcpy(&__r, __p, sizeof(__r));
     return __r;
 }
 
diff --git a/include/new b/include/new
index d2b2ae6..6e59f21 100644
--- a/include/new
+++ b/include/new
@@ -115,7 +115,7 @@ public:
 _LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec
 
 struct _LIBCPP_TYPE_VIS nothrow_t {};
-extern _LIBCPP_FUNC_VIS const nothrow_t nothrow;
+_LIBCPP_FUNC_VIS const nothrow_t nothrow {};
 typedef void (*new_handler)();
 _LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;
 _LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;
diff --git a/include/stddef.h b/include/stddef.h
deleted file mode 100644
index 8841bbe..0000000
--- a/include/stddef.h
+++ /dev/null
@@ -1,62 +0,0 @@
-// -*- C++ -*-
-//===--------------------------- stddef.h ---------------------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is dual licensed under the MIT and the University of Illinois Open
-// Source Licenses. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
-    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)
-
-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-#pragma GCC system_header
-#endif
-
-#include_next <stddef.h>
-
-#elif !defined(_LIBCPP_STDDEF_H)
-#define _LIBCPP_STDDEF_H
-
-/*
-    stddef.h synopsis
-
-Macros:
-
-    offsetof(type,member-designator)
-    NULL
-
-Types:
-
-    ptrdiff_t
-    size_t
-    max_align_t
-    nullptr_t
-
-*/
-
-#include <__config>
-
-#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
-#pragma GCC system_header
-#endif
-
-#include_next <stddef.h>
-
-#ifdef __cplusplus
-
-extern "C++" {
-#include <__nullptr>
-using std::nullptr_t;
-}
-
-// Re-use the compiler's <stddef.h> max_align_t where possible.
-#if !defined(__CLANG_MAX_ALIGN_T_DEFINED) && !defined(_GCC_MAX_ALIGN_T)
-typedef long double max_align_t;
-#endif
-
-#endif
-
-#endif  // _LIBCPP_STDDEF_H
diff --git a/include/stdexcept b/include/stdexcept
index 4218b13..fe44b95 100644
--- a/include/stdexcept
+++ b/include/stdexcept
@@ -54,9 +54,9 @@ public:
 _LIBCPP_BEGIN_NAMESPACE_STD
 class _LIBCPP_HIDDEN __libcpp_refstring {
 #ifdef __clang__
-    const char *__imp_ __attribute__((__unused__)); // only clang emits a warning
+    const constant char *__imp_ __attribute__((__unused__)); // only clang emits a warning
 #else
-    const char *__imp_;
+    const constant char *__imp_;
 #endif
 };
 _LIBCPP_END_NAMESPACE_STD
@@ -72,7 +72,7 @@ private:
     _VSTD::__libcpp_refstring __imp_;
 public:
     explicit logic_error(const string&);
-    explicit logic_error(const char*);
+    explicit logic_error(const constant char*);
 
     logic_error(const logic_error&) _NOEXCEPT;
     logic_error& operator=(const logic_error&) _NOEXCEPT;
@@ -89,7 +89,7 @@ private:
     _VSTD::__libcpp_refstring __imp_;
 public:
     explicit runtime_error(const string&);
-    explicit runtime_error(const char*);
+    explicit runtime_error(const constant char*);
 
     runtime_error(const runtime_error&) _NOEXCEPT;
     runtime_error& operator=(const runtime_error&) _NOEXCEPT;
@@ -104,7 +104,7 @@ class _LIBCPP_EXCEPTION_ABI domain_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const constant char* __s)   : logic_error(__s) {}
 
     virtual ~domain_error() _NOEXCEPT;
 };
@@ -114,7 +114,7 @@ class _LIBCPP_EXCEPTION_ABI invalid_argument
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const constant char* __s)   : logic_error(__s) {}
 
     virtual ~invalid_argument() _NOEXCEPT;
 };
@@ -124,7 +124,7 @@ class _LIBCPP_EXCEPTION_ABI length_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit length_error(const constant char* __s)   : logic_error(__s) {}
 
     virtual ~length_error() _NOEXCEPT;
 };
@@ -134,7 +134,7 @@ class _LIBCPP_EXCEPTION_ABI out_of_range
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const constant char* __s)   : logic_error(__s) {}
 
     virtual ~out_of_range() _NOEXCEPT;
 };
@@ -144,7 +144,7 @@ class _LIBCPP_EXCEPTION_ABI range_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit range_error(const constant char* __s)   : runtime_error(__s) {}
 
     virtual ~range_error() _NOEXCEPT;
 };
@@ -154,7 +154,7 @@ class _LIBCPP_EXCEPTION_ABI overflow_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const constant char* __s)   : runtime_error(__s) {}
 
     virtual ~overflow_error() _NOEXCEPT;
 };
@@ -164,7 +164,7 @@ class _LIBCPP_EXCEPTION_ABI underflow_error
 {
 public:
     _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}
-    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}
+    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const constant char* __s)   : runtime_error(__s) {}
 
     virtual ~underflow_error() _NOEXCEPT;
 };
diff --git a/include/type_traits b/include/type_traits
index 0d578bb..85f75a5 100644
--- a/include/type_traits
+++ b/include/type_traits
@@ -506,8 +506,8 @@ struct _LIBCPP_TYPE_VIS_ONLY integral_constant
 #endif
 };
 
-template <class _Tp, _Tp __v>
-_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
+//template <class _Tp, _Tp __v>
+//_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
 
 #if _LIBCPP_STD_VER > 14
 template <bool __b>
@@ -711,6 +711,9 @@ template <class _Tp> struct __libcpp_is_floating_point              : public fal
 template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
 template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
 template <>          struct __libcpp_is_floating_point<long double> : public true_type {};
+#if defined(FLOOR_COMPUTE)
+template <>          struct __libcpp_is_floating_point<__fp16>      : public true_type {};
+#endif
 
 template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point
     : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
