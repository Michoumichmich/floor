diff -rduBE llvm_rel35/include/llvm/CodeGen/AsmPrinter.h llvm/include/llvm/CodeGen/AsmPrinter.h
--- llvm_rel35/include/llvm/CodeGen/AsmPrinter.h
+++ llvm/include/llvm/CodeGen/AsmPrinter.h
@@ -232,7 +232,7 @@
   /// requested, it will override the alignment request if required for
   /// correctness.
   ///
-  void EmitAlignment(unsigned NumBits, const GlobalObject *GO = nullptr) const;
+  virtual void EmitAlignment(unsigned NumBits, const GlobalObject *GO = nullptr) const;
 
   /// This method prints the label for the specified MachineBasicBlock, an
   /// alignment (if present) and a comment describing it if appropriate.
@@ -496,7 +496,7 @@
   void EmitVisibility(MCSymbol *Sym, unsigned Visibility,
                       bool IsDefinition = true) const;
 
-  void EmitLinkage(const GlobalValue *GV, MCSymbol *GVSym) const;
+  virtual void EmitLinkage(const GlobalValue *GV, MCSymbol *GVSym) const;
 
   void EmitJumpTableEntry(const MachineJumpTableInfo *MJTI,
                           const MachineBasicBlock *MBB, unsigned uid) const;
diff -rduBE llvm_rel35/lib/Target/NVPTX/NVPTXAsmPrinter.h llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
--- llvm_rel35/lib/Target/NVPTX/NVPTXAsmPrinter.h
+++ llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h
@@ -202,6 +202,12 @@
   void EmitFunctionBodyEnd() override;
   void emitImplicitDef(const MachineInstr *MI) const override;
 
+  /// superfluous function header fix: nop these three functions
+  void EmitGlobalVariable(const GlobalVariable *GV) override {}
+  void EmitLinkage(const GlobalValue *GV, MCSymbol *GVSym) const override {}
+  void EmitAlignment(unsigned NumBits, const GlobalObject *GO = nullptr) const override {}
+  ///
+
   void EmitInstruction(const MachineInstr *) override;
   void lowerToMCInst(const MachineInstr *MI, MCInst &OutMI);
   bool lowerOperand(const MachineOperand &MO, MCOperand &MCOp);
diff -rduBE llvm_rel35/lib/Target/NVPTX/NVPTXInstrInfo.td llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
--- llvm_rel35/lib/Target/NVPTX/NVPTXInstrInfo.td
+++ llvm/lib/Target/NVPTX/NVPTXInstrInfo.td
@@ -1659,12 +1659,12 @@
             (SET_f64ir fpimm:$a, Float64Regs:$b, Mode)>;
 }
 
-defm FSetGT : FSET_FORMAT<setogt, CmpGT, CmpGT_FTZ>;
-defm FSetLT : FSET_FORMAT<setolt, CmpLT, CmpLT_FTZ>;
-defm FSetGE : FSET_FORMAT<setoge, CmpGE, CmpGE_FTZ>;
-defm FSetLE : FSET_FORMAT<setole, CmpLE, CmpLE_FTZ>;
-defm FSetEQ : FSET_FORMAT<setoeq, CmpEQ, CmpEQ_FTZ>;
-defm FSetNE : FSET_FORMAT<setone, CmpNE, CmpNE_FTZ>;
+defm FSetOGT : FSET_FORMAT<setogt, CmpGT, CmpGT_FTZ>;
+defm FSetOLT : FSET_FORMAT<setolt, CmpLT, CmpLT_FTZ>;
+defm FSetOGE : FSET_FORMAT<setoge, CmpGE, CmpGE_FTZ>;
+defm FSetOLE : FSET_FORMAT<setole, CmpLE, CmpLE_FTZ>;
+defm FSetOEQ : FSET_FORMAT<setoeq, CmpEQ, CmpEQ_FTZ>;
+defm FSetONE : FSET_FORMAT<setone, CmpNE, CmpNE_FTZ>;
 
 defm FSetUGT : FSET_FORMAT<setugt, CmpGTU, CmpGTU_FTZ>;
 defm FSetULT : FSET_FORMAT<setult, CmpLTU, CmpLTU_FTZ>;
@@ -1673,6 +1673,13 @@
 defm FSetUEQ : FSET_FORMAT<setueq, CmpEQU, CmpEQU_FTZ>;
 defm FSetUNE : FSET_FORMAT<setune, CmpNEU, CmpNEU_FTZ>;
 
+defm FSetGT : FSET_FORMAT<setgt, CmpGT, CmpGT_FTZ>;
+defm FSetLT : FSET_FORMAT<setlt, CmpLT, CmpLT_FTZ>;
+defm FSetGE : FSET_FORMAT<setge, CmpGE, CmpGE_FTZ>;
+defm FSetLE : FSET_FORMAT<setle, CmpLE, CmpLE_FTZ>;
+defm FSetEQ : FSET_FORMAT<seteq, CmpEQ, CmpEQ_FTZ>;
+defm FSetNE : FSET_FORMAT<setne, CmpNE, CmpNE_FTZ>;
+
 defm FSetNUM : FSET_FORMAT<seto, CmpNUM, CmpNUM_FTZ>;
 defm FSetNAN : FSET_FORMAT<setuo, CmpNAN, CmpNAN_FTZ>;

diff -rduBE llvm_rel35/tools/clang/include/clang/Basic/Attr.td llvm/tools/clang/include/clang/Basic/Attr.td
--- llvm_rel35/tools/clang/include/clang/Basic/Attr.td
+++ llvm/tools/clang/include/clang/Basic/Attr.td
@@ -514,7 +514,7 @@
 }
 
 def CUDAConstant : InheritableAttr {
-  let Spellings = [GNU<"constant">];
+  let Spellings = [GNU<"constant">, GNU<"cuda_constant">];
   let Subjects = SubjectList<[Var]>;
   let LangOpts = [CUDA];
   let Documentation = [Undocumented];
@@ -528,7 +528,7 @@
 }
 
 def CUDAGlobal : InheritableAttr {
-  let Spellings = [GNU<"global">];
+  let Spellings = [GNU<"global">, GNU<"cuda_kernel">];
   let Subjects = SubjectList<[Function]>;
   let LangOpts = [CUDA];
   let Documentation = [Undocumented];
@@ -574,7 +574,7 @@
 }
 
 def OpenCLKernel : InheritableAttr {
-  let Spellings = [Keyword<"__kernel">, Keyword<"kernel">];
+  let Spellings = [Keyword<"__kernel">];
   let Subjects = SubjectList<[Function], ErrorDiag>;
   let Documentation = [Undocumented];
 }
@@ -596,22 +596,22 @@
 }
 
 def OpenCLPrivateAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__private">, Keyword<"private">];
+  let Spellings = [Keyword<"__private">];
   let Documentation = [Undocumented];
 }
 
 def OpenCLGlobalAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__global">, Keyword<"global">];
+  let Spellings = [Keyword<"__global">];
   let Documentation = [Undocumented];
 }
 
 def OpenCLLocalAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__local">, Keyword<"local">];
+  let Spellings = [Keyword<"__local">];
   let Documentation = [Undocumented];
 }
 
 def OpenCLConstantAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__constant">, Keyword<"constant">];
+  let Spellings = [Keyword<"__constant">];
   let Documentation = [Undocumented];
 }
 
diff -rduBE llvm_rel35/tools/clang/include/clang/Basic/TokenKinds.def llvm/tools/clang/include/clang/Basic/TokenKinds.def
--- llvm_rel35/tools/clang/include/clang/Basic/TokenKinds.def
+++ llvm/tools/clang/include/clang/Basic/TokenKinds.def
@@ -461,27 +461,27 @@
 KEYWORD(__unaligned                 , KEYMS)
 
 // OpenCL address space qualifiers
-KEYWORD(__global                    , KEYOPENCL)
-KEYWORD(__local                     , KEYOPENCL)
-KEYWORD(__constant                  , KEYOPENCL)
-KEYWORD(__private                   , KEYOPENCL)
-ALIAS("global", __global            , KEYOPENCL)
-ALIAS("local", __local              , KEYOPENCL)
-ALIAS("constant", __constant        , KEYOPENCL)
-ALIAS("private", __private          , KEYOPENCL)
+KEYWORD(__global                    , KEYCXX|KEYOPENCL)
+KEYWORD(__local                     , KEYCXX|KEYOPENCL)
+KEYWORD(__constant                  , KEYCXX|KEYOPENCL)
+KEYWORD(__private                   , KEYCXX|KEYOPENCL)
+//ALIAS("global", __global            , KEYOPENCL)
+//ALIAS("local", __local              , KEYOPENCL)
+//ALIAS("constant", __constant        , KEYOPENCL)
+//ALIAS("private", __private          , KEYOPENCL)
 // OpenCL function qualifiers
-KEYWORD(__kernel                    , KEYOPENCL)
-ALIAS("kernel", __kernel            , KEYOPENCL)
+KEYWORD(__kernel                    , KEYCXX|KEYOPENCL)
+//ALIAS("kernel", __kernel            , KEYOPENCL)
 // OpenCL access qualifiers
-KEYWORD(__read_only                 , KEYOPENCL)
-KEYWORD(__write_only                , KEYOPENCL)
-KEYWORD(__read_write                , KEYOPENCL)
+KEYWORD(__read_only                 , KEYCXX|KEYOPENCL)
+KEYWORD(__write_only                , KEYCXX|KEYOPENCL)
+KEYWORD(__read_write                , KEYCXX|KEYOPENCL)
 ALIAS("read_only", __read_only      , KEYOPENCL)
 ALIAS("write_only", __write_only    , KEYOPENCL)
 ALIAS("read_write", __read_write    , KEYOPENCL)
 // OpenCL builtins
-KEYWORD(__builtin_astype            , KEYOPENCL)
-KEYWORD(vec_step                    , KEYOPENCL|KEYALTIVEC)
+KEYWORD(__builtin_astype            , KEYCXX|KEYOPENCL)
+KEYWORD(vec_step                    , KEYCXX|KEYOPENCL|KEYALTIVEC)
 
 // Borland Extensions.
 KEYWORD(__pascal                    , KEYALL)
diff -rduBE llvm_rel35/tools/clang/include/clang/Frontend/LangStandards.def llvm/tools/clang/include/clang/Frontend/LangStandards.def
--- llvm_rel35/tools/clang/include/clang/Frontend/LangStandards.def
+++ llvm/tools/clang/include/clang/Frontend/LangStandards.def
@@ -134,17 +134,21 @@
 // OpenCL
 LANGSTANDARD(opencl, "cl",
              "OpenCL 1.0",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus1y | CPlusPlus1z |
+             Digraphs | GNUMode)
 LANGSTANDARD(opencl11, "CL1.1",
              "OpenCL 1.1",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus1y | CPlusPlus1z |
+             Digraphs | GNUMode)
 LANGSTANDARD(opencl12, "CL1.2",
              "OpenCL 1.2",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus1y | CPlusPlus1z |
+             Digraphs | GNUMode)
 
 // CUDA
 LANGSTANDARD(cuda, "cuda",
              "NVIDIA CUDA(tm)",
-             LineComment | CPlusPlus | Digraphs)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus1y | CPlusPlus1z |
+             Digraphs | GNUMode)
 
 #undef LANGSTANDARD
diff -rduBE llvm_rel35/tools/clang/lib/CodeGen/CodeGenModule.cpp llvm/tools/clang/lib/CodeGen/CodeGenModule.cpp
--- llvm_rel35/tools/clang/lib/CodeGen/CodeGenModule.cpp
+++ llvm/tools/clang/lib/CodeGen/CodeGenModule.cpp
@@ -1219,21 +1219,17 @@
     return EmitAliasDefinition(GD);
 
   // If this is CUDA, be selective about which declarations we emit.
-  if (LangOpts.CUDA) {
-    if (CodeGenOpts.CUDAIsDevice) {
-      if (!Global->hasAttr<CUDADeviceAttr>() &&
-          !Global->hasAttr<CUDAGlobalAttr>() &&
-          !Global->hasAttr<CUDAConstantAttr>() &&
-          !Global->hasAttr<CUDASharedAttr>())
-        return;
-    } else {
+  /*if (LangOpts.CUDA) {
+    if (!CodeGenOpts.CUDAIsDevice) {
       if (!Global->hasAttr<CUDAHostAttr>() && (
             Global->hasAttr<CUDADeviceAttr>() ||
             Global->hasAttr<CUDAConstantAttr>() ||
-            Global->hasAttr<CUDASharedAttr>()))
+            Global->hasAttr<CUDASharedAttr>())) {
         return;
+	  }
     }
-  }
+	// else: CUDAIsDevice: always emit, even if __device__ is missing!
+  }*/
 
   // Ignore declarations, they will be emitted on their first use.
   if (const auto *FD = dyn_cast<FunctionDecl>(Global)) {
diff -rduBE llvm_rel35/tools/clang/lib/Frontend/CompilerInvocation.cpp llvm/tools/clang/lib/Frontend/CompilerInvocation.cpp
--- llvm_rel35/tools/clang/lib/Frontend/CompilerInvocation.cpp
+++ llvm/tools/clang/lib/Frontend/CompilerInvocation.cpp
@@ -1276,7 +1276,7 @@
             << A->getAsString(Args) << "C++/ObjC++";
         break;
       case IK_OpenCL:
-        if (!Std.isC99())
+        if (!Std.isC99() && !Std.isCPlusPlus())
           Diags.Report(diag::err_drv_argument_not_allowed_with)
             << A->getAsString(Args) << "OpenCL";
         break;
diff -rduBE llvm_rel35/tools/clang/lib/Lex/PPDirectives.cpp llvm/tools/clang/lib/Lex/PPDirectives.cpp
--- llvm_rel35/tools/clang/lib/Lex/PPDirectives.cpp
+++ llvm/tools/clang/lib/Lex/PPDirectives.cpp
@@ -1807,7 +1807,7 @@
              diag::ext_variadic_macro);
 
       // OpenCL v1.2 s6.9.e: variadic macros are not supported.
-      if (LangOpts.OpenCL) {
+      if (LangOpts.OpenCL && !LangOpts.CPlusPlus) {
         Diag(Tok, diag::err_pp_opencl_variadic_macros);
         return true;
       }
diff -rduBE llvm_rel35/tools/clang/lib/Sema/SemaDeclCXX.cpp llvm/tools/clang/lib/Sema/SemaDeclCXX.cpp
--- llvm_rel35/tools/clang/lib/Sema/SemaDeclCXX.cpp
+++ llvm/tools/clang/lib/Sema/SemaDeclCXX.cpp
@@ -13026,21 +13026,13 @@
 
 /// IdentifyCUDATarget - Determine the CUDA compilation target for this function
 Sema::CUDAFunctionTarget Sema::IdentifyCUDATarget(const FunctionDecl *D) {
-  // Implicitly declared functions (e.g. copy constructors) are
-  // __host__ __device__
-  if (D->isImplicit())
-    return CFT_HostDevice;
-
   if (D->hasAttr<CUDAGlobalAttr>())
     return CFT_Global;
 
-  if (D->hasAttr<CUDADeviceAttr>()) {
-    if (D->hasAttr<CUDAHostAttr>())
-      return CFT_HostDevice;
-    return CFT_Device;
-  }
-
-  return CFT_Host;
+  // if not a kernel, always default to device
+  // this is IMO a much saner approach and doesn't require to add the __device__
+  // attribute to _all_ functions
+  return CFT_Device;
 }
 
 bool Sema::CheckCUDATarget(CUDAFunctionTarget CallerTarget,
diff -rduBE llvm_rel35/tools/clang/lib/Sema/SemaExpr.cpp llvm/tools/clang/lib/Sema/SemaExpr.cpp
--- llvm_rel35/tools/clang/lib/Sema/SemaExpr.cpp
+++ llvm/tools/clang/lib/Sema/SemaExpr.cpp
@@ -444,7 +444,7 @@
   if (Ty->isFunctionType()) {
     // If we are here, we are not calling a function but taking
     // its address (which is not allowed in OpenCL v1.0 s6.8.a.3).
-    if (getLangOpts().OpenCL) {
+    if (getLangOpts().OpenCL && !LangOpts.CPlusPlus) {
       Diag(E->getExprLoc(), diag::err_opencl_taking_function_address);
       return ExprError();
     }
@@ -8953,7 +8953,7 @@
   Expr *op = OrigOp.get()->IgnoreParens();
 
   // OpenCL v1.0 s6.8.a.3: Pointers to functions are not allowed.
-  if (LangOpts.OpenCL && op->getType()->isFunctionType()) {
+  if (LangOpts.OpenCL && !LangOpts.CPlusPlus && op->getType()->isFunctionType()) {
     Diag(op->getExprLoc(), diag::err_opencl_taking_function_address);
     return QualType();
   }
