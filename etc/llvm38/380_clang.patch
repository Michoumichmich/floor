diff --git a/.gitignore b/.gitignore
index 3d07e81..e75acd3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -18,6 +18,7 @@
 # vim swap files
 .*.sw?
 .sw?
+.DS_Store
 
 #==============================================================================#
 # Explicit files to ignore (only matches one).
diff --git a/include/clang-c/Index.h b/include/clang-c/Index.h
index 09e2160..8318ccd 100644
--- a/include/clang-c/Index.h
+++ b/include/clang-c/Index.h
@@ -2305,7 +2305,7 @@ enum CXCursorKind {
   CXCursor_NoDuplicateAttr               = 411,
   CXCursor_CUDAConstantAttr              = 412,
   CXCursor_CUDADeviceAttr                = 413,
-  CXCursor_CUDAGlobalAttr                = 414,
+  CXCursor_ComputeKernelAttr             = 414,
   CXCursor_CUDAHostAttr                  = 415,
   CXCursor_CUDASharedAttr                = 416,
   CXCursor_VisibilityAttr                = 417,
@@ -2938,6 +2938,8 @@ enum CXCallingConv {
   CXCallingConv_X86_64Win64 = 10,
   CXCallingConv_X86_64SysV = 11,
   CXCallingConv_X86VectorCall = 12,
+  CXCallingConv_SpirFunction = 13,
+  CXCallingConv_SpirKernel = 14,
 
   CXCallingConv_Invalid = 100,
   CXCallingConv_Unexposed = 200
diff --git a/include/clang/AST/ASTContext.h b/include/clang/AST/ASTContext.h
index abf9294..7b9191a 100644
--- a/include/clang/AST/ASTContext.h
+++ b/include/clang/AST/ASTContext.h
@@ -414,6 +414,8 @@ private:
   ///  this ASTContext object.
   LangOptions &LangOpts;
 
+  bool disabledFPContract;
+
   /// \brief Blacklist object that is used by sanitizers to decide which
   /// entities should not be instrumented.
   std::unique_ptr<SanitizerBlacklist> SanitizerBL;
@@ -455,6 +457,8 @@ public:
   IntrusiveRefCntPtr<ExternalASTSource> ExternalSource;
   ASTMutationListener *Listener;
 
+  OpenCLOptions OpenCLFeatures;
+
   /// \brief Contains parents of a node.
   typedef llvm::SmallVector<ast_type_traits::DynTypedNode, 2> ParentVector;
 
@@ -599,6 +603,10 @@ public:
     return *SanitizerBL;
   }
 
+  void disableFPContract() { disabledFPContract = true; }
+
+  bool isFPContractDisabled() const { return disabledFPContract; }
+
   DiagnosticsEngine &getDiagnostics() const;
 
   FullSourceLoc getFullLoc(SourceLocation Loc) const {
@@ -898,11 +906,9 @@ public:
   CanQualType PseudoObjectTy, ARCUnbridgedCastTy;
   CanQualType ObjCBuiltinIdTy, ObjCBuiltinClassTy, ObjCBuiltinSelTy;
   CanQualType ObjCBuiltinBoolTy;
-  CanQualType OCLImage1dTy, OCLImage1dArrayTy, OCLImage1dBufferTy;
-  CanQualType OCLImage2dTy, OCLImage2dArrayTy, OCLImage2dDepthTy;
-  CanQualType OCLImage2dArrayDepthTy, OCLImage2dMSAATy, OCLImage2dArrayMSAATy;
-  CanQualType OCLImage2dMSAADepthTy, OCLImage2dArrayMSAADepthTy;
-  CanQualType OCLImage3dTy;
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  CanQualType SingletonId;
+#include "clang/Basic/OpenCLImageTypes.def"
   CanQualType OCLSamplerTy, OCLEventTy, OCLClkEventTy;
   CanQualType OCLQueueTy, OCLNDRangeTy, OCLReserveIDTy;
   CanQualType OMPArraySectionTy;
diff --git a/include/clang/AST/BuiltinTypes.def b/include/clang/AST/BuiltinTypes.def
index a08a683..dcca44d 100644
--- a/include/clang/AST/BuiltinTypes.def
+++ b/include/clang/AST/BuiltinTypes.def
@@ -154,20 +154,6 @@ BUILTIN_TYPE(ObjCClass, ObjCBuiltinClassTy)
 // type is a typedef of a PointerType to this.
 BUILTIN_TYPE(ObjCSel, ObjCBuiltinSelTy)
 
-// OpenCL image types.
-BUILTIN_TYPE(OCLImage1d, OCLImage1dTy)
-BUILTIN_TYPE(OCLImage1dArray, OCLImage1dArrayTy)
-BUILTIN_TYPE(OCLImage1dBuffer, OCLImage1dBufferTy)
-BUILTIN_TYPE(OCLImage2d, OCLImage2dTy)
-BUILTIN_TYPE(OCLImage2dArray, OCLImage2dArrayTy)
-BUILTIN_TYPE(OCLImage2dDepth, OCLImage2dDepthTy)
-BUILTIN_TYPE(OCLImage2dArrayDepth, OCLImage2dArrayDepthTy)
-BUILTIN_TYPE(OCLImage2dMSAA, OCLImage2dMSAATy)
-BUILTIN_TYPE(OCLImage2dArrayMSAA, OCLImage2dArrayMSAATy)
-BUILTIN_TYPE(OCLImage2dMSAADepth, OCLImage2dMSAADepthTy)
-BUILTIN_TYPE(OCLImage2dArrayMSAADepth, OCLImage2dArrayMSAADepthTy)
-BUILTIN_TYPE(OCLImage3d, OCLImage3dTy)
-
 // OpenCL sampler_t.
 BUILTIN_TYPE(OCLSampler, OCLSamplerTy)
 
diff --git a/include/clang/AST/Decl.h b/include/clang/AST/Decl.h
index 029c118..8fd8797 100644
--- a/include/clang/AST/Decl.h
+++ b/include/clang/AST/Decl.h
@@ -737,7 +737,7 @@ private:
     friend class VarDecl;
     friend class ASTDeclReader;
 
-    unsigned SClass : 3;
+    unsigned SClass : 4;
     unsigned TSCSpec : 2;
     unsigned InitStyle : 2;
   };
@@ -916,6 +916,7 @@ public:
   /// storage.
   bool hasExternalStorage() const {
     return getStorageClass() == SC_Extern ||
+           getStorageClass() == SC_OpenCLConstantExtern ||
            getStorageClass() == SC_PrivateExtern;
   }
 
diff --git a/include/clang/AST/Mangle.h b/include/clang/AST/Mangle.h
index 4872738..483b0f7 100644
--- a/include/clang/AST/Mangle.h
+++ b/include/clang/AST/Mangle.h
@@ -144,6 +144,9 @@ public:
   /// across translation units so it can be used with LTO.
   virtual void mangleTypeName(QualType T, raw_ostream &) = 0;
 
+  virtual void mangleMetalFieldName(const FieldDecl *D, const CXXRecordDecl* RD, raw_ostream &) {}
+  virtual void mangleMetalGeneric(const std::string& name, QualType Ty, const CXXRecordDecl* RD, raw_ostream &) {}
+
   /// @}
 };
 
diff --git a/include/clang/AST/OperationKinds.h b/include/clang/AST/OperationKinds.h
index 102bbc2..952b1a5 100644
--- a/include/clang/AST/OperationKinds.h
+++ b/include/clang/AST/OperationKinds.h
@@ -301,6 +301,12 @@ enum CastKind {
   // Convert a zero value for OpenCL event_t initialization.
   CK_ZeroToOCLEvent,
 
+  // Convert a zero value for OpenCL queue_t initialization.
+  CK_ZeroToOCLQueue,
+
+  // Convert an integer initializer to an OpenCL sampler
+  CK_IntToOCLSampler,
+
   // Convert a pointer to a different address space.
   CK_AddressSpaceConversion
 };
diff --git a/include/clang/AST/Type.h b/include/clang/AST/Type.h
index d63b2c4..3cd2336 100644
--- a/include/clang/AST/Type.h
+++ b/include/clang/AST/Type.h
@@ -411,10 +411,10 @@ public:
   ///   every address space is a superset of itself.
   /// CL2.0 adds:
   ///   __generic is a superset of any address space except for __constant.
-  bool isAddressSpaceSupersetOf(Qualifiers other) const {
+  bool isAddressSpaceSupersetOf(Qualifiers other, bool check_as = true) const {
     return
         // Address spaces must match exactly.
-        getAddressSpace() == other.getAddressSpace() ||
+		((check_as && getAddressSpace() == other.getAddressSpace()) || !check_as) ||
         // Otherwise in OpenCLC v2.0 s6.5.5: every address space except
         // for __constant can be used as __generic.
         (getAddressSpace() == LangAS::opencl_generic &&
@@ -424,8 +424,8 @@ public:
   /// Determines if these qualifiers compatibly include another set.
   /// Generally this answers the question of whether an object with the other
   /// qualifiers can be safely used as an object with these qualifiers.
-  bool compatiblyIncludes(Qualifiers other) const {
-    return isAddressSpaceSupersetOf(other) &&
+  bool compatiblyIncludes(Qualifiers other, bool check_as = true) const {
+    return isAddressSpaceSupersetOf(other, check_as) &&
            // ObjC GC qualifiers can match, be added, or be removed, but can't
            // be changed.
            (getObjCGCAttr() == other.getObjCGCAttr() || !hasObjCGCAttr() ||
@@ -1614,6 +1614,7 @@ public:
   bool isComplexType() const;      // C99 6.2.5p11 (complex)
   bool isAnyComplexType() const;   // C99 6.2.5p11 (complex) + Complex Int.
   bool isFloatingType() const;     // C99 6.2.5p11 (real floating + complex)
+  bool isDoubleType() const;       // (double + long double)
   bool isHalfType() const;         // OpenCL 6.1.1.1, NEON (IEEE 754-2008 half)
   bool isRealType() const;         // C99 6.2.5p17 (real floating + integer)
   bool isArithmeticType() const;   // C99 6.2.5p18 (integer + floating)
@@ -1623,6 +1624,12 @@ public:
   bool isFundamentalType() const;
   bool isCompoundType() const;
 
+  // Vector categories
+  bool isFloatingVecType() const;
+  bool isDoubleVecType() const;
+  bool isIntegerVecType() const;
+  bool isRealVecType() const;
+
   // Type Predicates: Check to see if this type is structurally the specified
   // type, ignoring typedefs and qualifiers.
   bool isFunctionType() const;
@@ -1699,27 +1706,21 @@ public:
   bool isNullPtrType() const;                   // C++0x nullptr_t
   bool isAtomicType() const;                    // C11 _Atomic()
 
-  bool isImage1dT() const;               // OpenCL image1d_t
-  bool isImage1dArrayT() const;          // OpenCL image1d_array_t
-  bool isImage1dBufferT() const;         // OpenCL image1d_buffer_t
-  bool isImage2dT() const;               // OpenCL image2d_t
-  bool isImage2dArrayT() const;          // OpenCL image2d_array_t
-  bool isImage2dDepthT() const;          // OpenCL image_2d_depth_t
-  bool isImage2dArrayDepthT() const;     // OpenCL image_2d_array_depth_t
-  bool isImage2dMSAAT() const;           // OpenCL image_2d_msaa_t
-  bool isImage2dArrayMSAAT() const;      // OpenCL image_2d_array_msaa_t
-  bool isImage2dMSAATDepth() const;      // OpenCL image_2d_msaa_depth_t
-  bool isImage2dArrayMSAATDepth() const; // OpenCL image_2d_array_msaa_depth_t
-  bool isImage3dT() const;               // OpenCL image3d_t
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  bool is##Id##Type() const;
+#include "clang/Basic/OpenCLImageTypes.def"
 
   bool isImageType() const;                     // Any OpenCL image type
 
+  bool isAggregateImageType() const;            // struct/class containing only image*_t members
+
   bool isSamplerT() const;                      // OpenCL sampler_t
   bool isEventT() const;                        // OpenCL event_t
   bool isClkEventT() const;                     // OpenCL clk_event_t
   bool isQueueT() const;                        // OpenCL queue_t
   bool isNDRangeT() const;                      // OpenCL ndrange_t
   bool isReserveIDT() const;                    // OpenCL reserve_id_t
+  bool isExecType() const;                      // OpenCL 2.0 execution model types
 
   bool isPipeType() const;                      // OpenCL pipe type
   bool isOpenCLSpecificType() const;            // Any OpenCL specific type
@@ -2011,6 +2012,10 @@ template <> inline const Class##Type *Type::castAs() const { \
 class BuiltinType : public Type {
 public:
   enum Kind {
+// OpenCL image types
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) Id,
+#include "clang/Basic/OpenCLImageTypes.def"
+// All other builtin types
 #define BUILTIN_TYPE(Id, SingletonId) Id,
 #define LAST_BUILTIN_TYPE(Id) LastKind = Id
 #include "clang/AST/BuiltinTypes.def"
@@ -5232,7 +5237,7 @@ inline FunctionType::ExtInfo getFunctionExtInfo(QualType t) {
 inline bool QualType::isMoreQualifiedThan(QualType other) const {
   Qualifiers myQuals = getQualifiers();
   Qualifiers otherQuals = other.getQualifiers();
-  return (myQuals != otherQuals && myQuals.compatiblyIncludes(otherQuals));
+  return (myQuals != otherQuals && myQuals.compatiblyIncludes(otherQuals, false));
 }
 
 /// Determine whether this type is at last
@@ -5240,7 +5245,7 @@ inline bool QualType::isMoreQualifiedThan(QualType other) const {
 /// int" is at least as qualified as "const int", "volatile int",
 /// "int", and "const volatile int".
 inline bool QualType::isAtLeastAsQualifiedAs(QualType other) const {
-  return getQualifiers().compatiblyIncludes(other.getQualifiers());
+  return getQualifiers().compatiblyIncludes(other.getQualifiers(), false);
 }
 
 /// If Type is a reference type (e.g., const
@@ -5417,53 +5422,11 @@ inline bool Type::isObjCBuiltinType() const {
   return isObjCIdType() || isObjCClassType() || isObjCSelType();
 }
 
-inline bool Type::isImage1dT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage1d);
-}
-
-inline bool Type::isImage1dArrayT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage1dArray);
-}
-
-inline bool Type::isImage1dBufferT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage1dBuffer);
-}
-
-inline bool Type::isImage2dT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage2d);
-}
-
-inline bool Type::isImage2dArrayT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage2dArray);
-}
-
-inline bool Type::isImage2dDepthT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage2dDepth);
-}
-
-inline bool Type::isImage2dArrayDepthT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayDepth);
-}
-
-inline bool Type::isImage2dMSAAT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage2dMSAA);
-}
-
-inline bool Type::isImage2dArrayMSAAT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayMSAA);
-}
-
-inline bool Type::isImage2dMSAATDepth() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage2dMSAADepth);
-}
-
-inline bool Type::isImage2dArrayMSAATDepth() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage2dArrayMSAADepth);
-}
-
-inline bool Type::isImage3dT() const {
-  return isSpecificBuiltinType(BuiltinType::OCLImage3d);
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+inline bool Type::is##Id##Type() const { \
+  return isSpecificBuiltinType(BuiltinType::Id); \
 }
+#include "clang/Basic/OpenCLImageTypes.def"
 
 inline bool Type::isSamplerT() const {
   return isSpecificBuiltinType(BuiltinType::OCLSampler);
@@ -5489,12 +5452,16 @@ inline bool Type::isReserveIDT() const {
   return isSpecificBuiltinType(BuiltinType::OCLReserveID);
 }
 
+inline bool Type::isExecType() const {
+ return isSpecificBuiltinType(BuiltinType::OCLQueue) ||
+        isSpecificBuiltinType(BuiltinType::OCLClkEvent);
+}
+
 inline bool Type::isImageType() const {
-  return isImage3dT() || isImage2dT() || isImage2dArrayT() ||
-         isImage2dDepthT() || isImage2dArrayDepthT() || isImage2dMSAAT() ||
-         isImage2dArrayMSAAT() || isImage2dMSAATDepth() ||
-         isImage2dArrayMSAATDepth() || isImage1dT() || isImage1dArrayT() ||
-         isImage1dBufferT();
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) is##Id##Type() ||
+  return
+#include "clang/Basic/OpenCLImageTypes.def"
+      0; // end boolean or operation
 }
 
 inline bool Type::isPipeType() const {
@@ -5503,7 +5470,8 @@ inline bool Type::isPipeType() const {
 
 inline bool Type::isOpenCLSpecificType() const {
   return isSamplerT() || isEventT() || isImageType() || isClkEventT() ||
-         isQueueT() || isNDRangeT() || isReserveIDT() || isPipeType();
+         isQueueT() || isNDRangeT() || isReserveIDT() || isPipeType() ||
+         isAggregateImageType();
 }
 
 inline bool Type::isTemplateTypeParmType() const {
diff --git a/include/clang/Basic/Attr.td b/include/clang/Basic/Attr.td
index d5ba722..ee653b1 100644
--- a/include/clang/Basic/Attr.td
+++ b/include/clang/Basic/Attr.td
@@ -116,7 +116,7 @@ def FunctionLike : SubsetSubject<DeclBase,
                                   [{S->getFunctionType(false) != nullptr}]>;
 
 def OpenCLKernelFunction : SubsetSubject<Function, [{
-  S->hasAttr<OpenCLKernelAttr>()
+  S->hasAttr<ComputeKernelAttr>()
 }]>;
 
 // HasFunctionProto is a more strict version of FunctionLike, so it should
@@ -561,13 +561,6 @@ def Constructor : InheritableAttr {
   let Documentation = [Undocumented];
 }
 
-def CUDAConstant : InheritableAttr {
-  let Spellings = [GNU<"constant">];
-  let Subjects = SubjectList<[Var]>;
-  let LangOpts = [CUDA];
-  let Documentation = [Undocumented];
-}
-
 def CUDACudartBuiltin : IgnoredAttr {
   let Spellings = [GNU<"cudart_builtin">];
   let LangOpts = [CUDA];
@@ -595,13 +588,6 @@ def CUDADeviceBuiltinTextureType : IgnoredAttr {
   let LangOpts = [CUDA];
 }
 
-def CUDAGlobal : InheritableAttr {
-  let Spellings = [GNU<"global">];
-  let Subjects = SubjectList<[Function]>;
-  let LangOpts = [CUDA];
-  let Documentation = [Undocumented];
-}
-
 def CUDAHost : InheritableAttr {
   let Spellings = [GNU<"host">];
   let Subjects = SubjectList<[Function]>;
@@ -628,13 +614,6 @@ def CUDALaunchBounds : InheritableAttr {
   let Documentation = [Undocumented];
 }
 
-def CUDAShared : InheritableAttr {
-  let Spellings = [GNU<"shared">];
-  let Subjects = SubjectList<[Var]>;
-  let LangOpts = [CUDA];
-  let Documentation = [Undocumented];
-}
-
 def C11NoReturn : InheritableAttr {
   let Spellings = [Keyword<"_Noreturn">];
   let Subjects = SubjectList<[Function], ErrorDiag>;
@@ -648,53 +627,142 @@ def CXX11NoReturn : InheritableAttr {
   let Documentation = [CXX11NoReturnDocs];
 }
 
-def OpenCLKernel : InheritableAttr {
-  let Spellings = [Keyword<"__kernel">, Keyword<"kernel">];
+def ComputeKernel : InheritableAttr {
+  let Spellings = [GNU<"compute_kernel">, CXX11<"","compute_kernel", 200809>];
+  let Subjects = SubjectList<[Function], ErrorDiag>;
+  let Documentation = [Undocumented];
+}
+
+def GraphicsVertexShader : InheritableAttr {
+  let Spellings = [GNU<"vertex_shader">, CXX11<"","vertex_shader", 200809>];
+  let Subjects = SubjectList<[Function], ErrorDiag>;
+  let Documentation = [Undocumented];
+}
+
+def GraphicsFragmentShader : InheritableAttr {
+  let Spellings = [GNU<"fragment_shader">, CXX11<"","fragment_shader", 200809>];
   let Subjects = SubjectList<[Function], ErrorDiag>;
   let Documentation = [Undocumented];
 }
 
 // This attribute is both a type attribute, and a declaration attribute (for
 // parameter variables).
-def OpenCLImageAccess : Attr {
-  let Spellings = [Keyword<"__read_only">, Keyword<"read_only">,
-                   Keyword<"__write_only">, Keyword<"write_only">,
-                   Keyword<"__read_write">, Keyword<"read_write">];
-  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
-  let Accessors = [Accessor<"isReadOnly", [Keyword<"__read_only">,
-                                           Keyword<"read_only">]>,
-                   Accessor<"isReadWrite", [Keyword<"__read_write">,
-                                            Keyword<"read_write">]>,
-                   Accessor<"isWriteOnly", [Keyword<"__write_only">,
-                                            Keyword<"write_only">]>];
+def ImageAccess : Attr {
+  let Spellings = [GNU<"image_read_only">, CXX11<"","image_read_only", 200809>,
+                   GNU<"image_write_only">, CXX11<"","image_write_only", 200809>,
+                   GNU<"image_read_write">, CXX11<"","image_read_write", 200809>];
+  let Accessors = [Accessor<"isReadOnly", [GNU<"image_read_only">,
+										   CXX11<"","image_read_only", 200809>]>,
+                   Accessor<"isReadWrite", [GNU<"image_read_write">,
+											CXX11<"","image_read_write", 200809>]>,
+                   Accessor<"isWriteOnly", [GNU<"image_write_only">,
+											CXX11<"","image_write_only", 200809>]>];
   let Documentation = [Undocumented];
 }
 
-def OpenCLPrivateAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__private">, Keyword<"private">];
+def PrivateAddressSpace : TypeAttr {
+  let Spellings = [GNU<"private_as">, CXX11<"","private_as", 200809>];
   let Documentation = [OpenCLAddressSpacePrivateDocs];
 }
 
-def OpenCLGlobalAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__global">, Keyword<"global">];
+def GlobalAddressSpace : TypeAttr {
+  let Spellings = [GNU<"global_as">, CXX11<"","global_as", 200809>];
   let Documentation = [OpenCLAddressSpaceGlobalDocs];
 }
 
-def OpenCLLocalAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__local">, Keyword<"local">];
+def LocalAddressSpace : TypeAttr {
+  let Spellings = [GNU<"local_as">, CXX11<"","local_as", 200809>];
   let Documentation = [OpenCLAddressSpaceLocalDocs];
 }
 
-def OpenCLConstantAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__constant">, Keyword<"constant">];
+def ConstantAddressSpace : TypeAttr {
+  let Spellings = [GNU<"constant_as">, CXX11<"","constant_as", 200809>];
   let Documentation = [OpenCLAddressSpaceConstantDocs];
 }
 
-def OpenCLGenericAddressSpace : TypeAttr {
-  let Spellings = [Keyword<"__generic">, Keyword<"generic">];
+def GenericAddressSpace : TypeAttr {
+  let Spellings = [GNU<"generic_as">, CXX11<"","generic_as", 200809>];
   let Documentation = [OpenCLAddressSpaceGenericDocs];
 }
 
+// CUDA address space attrs are not type attrs, so they need to be handled specially
+def CUDAShared : InheritableAttr {
+  let Spellings = [GNU<"local_cuda">, CXX11<"","local_cuda", 200809>];
+  let Subjects = SubjectList<[Var]>;
+  let LangOpts = [CUDA];
+  let Documentation = [Undocumented];
+}
+
+def CUDAConstant : InheritableAttr {
+  let Spellings = [GNU<"constant_cuda">, CXX11<"","constant_cuda", 200809>];
+  let Subjects = SubjectList<[Var]>;
+  let LangOpts = [CUDA];
+  let Documentation = [Undocumented];
+}
+
+def FloorImageDataType : InheritableAttr {
+  let Spellings = [GNU<"floor_image">, CXX11<"","floor_image", 200809>];
+  let Args = [TypeArgument<"ImageDataType">];
+  let TemplateDependent = 1;
+  let Documentation = [Undocumented];
+}
+
+// on aggregate types this signals that they can be converted/coerced to the corresponding clang/llvm vector type
+def VectorCompat : InheritableAttr {
+  let Spellings = [GNU<"vector_compat">, CXX11<"","vector_compat", 200809>];
+  let Documentation = [Undocumented];
+}
+
+// fbo color output location
+def GraphicsFBOColorLocation : InheritableAttr {
+  let Spellings = [GNU<"color">, CXX11<"","color", 200809>];
+  let Args = [ExprArgument<"ColorLocation">];
+  let TemplateDependent = 1;
+  let AdditionalMembers = [{
+  unsigned int eval_location = 0;
+  unsigned int getEvalLocation() const {
+    return eval_location;
+  }
+  void setEvalLocation(unsigned int loc) {
+    eval_location = loc;
+  }
+  }];
+  let Documentation = [Undocumented];
+}
+
+// fbo explicit writable depth with depth type
+def GraphicsFBODepthType : InheritableAttr {
+  let Spellings = [GNU<"depth">, CXX11<"","depth", 200809>];
+  let Args = [EnumArgument<"DepthQualifier", "DepthQualifierType",
+                           ["any", "greater", "less"],
+                           ["FBODepthTypeAny", "FBODepthTypeGreater", "FBODepthTypeLess"]>];
+  let Documentation = [Undocumented];
+}
+
+// vertex output position (used in vertex output structs)
+def GraphicsVertexPosition : InheritableAttr {
+  let Spellings = [GNU<"position">, CXX11<"","position", 200809>];
+  let Documentation = [Undocumented];
+}
+
+// vertex/point output size (used in vertex output structs)
+def GraphicsPointSize : InheritableAttr {
+  let Spellings = [GNU<"point_size">, CXX11<"","point_size", 200809>];
+  let Documentation = [Undocumented];
+}
+
+// stage input (just fragment shader input right now)
+def GraphicsStageInput : Attr {
+  let Spellings = [GNU<"stage_input">, CXX11<"","stage_input", 200809>];
+  let Subjects = SubjectList<[ParmVar], ErrorDiag>;
+  let Documentation = [Undocumented];
+}
+
+def OpenCLNoSVM : Attr {
+  let Spellings = [GNU<"nosvm">];
+  let Documentation = [Undocumented];
+}
+
 def Deprecated : InheritableAttr {
   let Spellings = [GCC<"deprecated">, Declspec<"deprecated">,
                    CXX11<"","deprecated", 201309>];
diff --git a/include/clang/Basic/Builtins.def b/include/clang/Basic/Builtins.def
index 4f474eb..020434b 100644
--- a/include/clang/Basic/Builtins.def
+++ b/include/clang/Basic/Builtins.def
@@ -118,9 +118,11 @@ BUILTIN(__builtin_frexpl, "LdLdi*", "Fn")
 BUILTIN(__builtin_huge_val, "d", "nc")
 BUILTIN(__builtin_huge_valf, "f", "nc")
 BUILTIN(__builtin_huge_vall, "Ld", "nc")
+BUILTIN(__builtin_huge_valh, "h", "nc")
 BUILTIN(__builtin_inf  , "d"   , "nc")
 BUILTIN(__builtin_inff , "f"   , "nc")
 BUILTIN(__builtin_infl , "Ld"  , "nc")
+BUILTIN(__builtin_infh , "h"   , "nc")
 BUILTIN(__builtin_labs , "LiLi"  , "Fnc")
 BUILTIN(__builtin_llabs, "LLiLLi", "Fnc")
 BUILTIN(__builtin_ldexp , "ddi"  , "Fnc")
@@ -132,9 +134,11 @@ BUILTIN(__builtin_modfl, "LdLdLd*", "Fn")
 BUILTIN(__builtin_nan,  "dcC*" , "ncF")
 BUILTIN(__builtin_nanf, "fcC*" , "ncF")
 BUILTIN(__builtin_nanl, "LdcC*", "ncF")
+BUILTIN(__builtin_nanh, "hcC*" , "ncF")
 BUILTIN(__builtin_nans,  "dcC*" , "ncF")
 BUILTIN(__builtin_nansf, "fcC*" , "ncF")
 BUILTIN(__builtin_nansl, "LdcC*", "ncF")
+BUILTIN(__builtin_nansh, "hcC*" , "ncF")
 BUILTIN(__builtin_powi , "ddi"  , "Fnc")
 BUILTIN(__builtin_powif, "ffi"  , "Fnc")
 BUILTIN(__builtin_powil, "LdLdi", "Fnc")
@@ -1252,6 +1256,33 @@ BUILTIN(__builtin___get_unsafe_stack_ptr, "v*", "Fn")
 BUILTIN(__builtin_nontemporal_store, "v.", "t")
 BUILTIN(__builtin_nontemporal_load, "v.", "t")
 
+// OpenCL 2.0 Pipe functions.
+//
+// We need the variadic prototype, since the packet type could be anything.
+BUILTIN(read_pipe, "i.", "tn")
+BUILTIN(write_pipe, "i.", "tn")
+
+BUILTIN(reserve_read_pipe, "i.", "tn")
+BUILTIN(reserve_write_pipe, "i.", "tn")
+
+BUILTIN(commit_write_pipe, "v.", "tn")
+BUILTIN(commit_read_pipe, "v.", "tn")
+
+BUILTIN(sub_group_reserve_read_pipe, "i.", "tn")
+BUILTIN(sub_group_reserve_write_pipe, "i.", "tn")
+
+BUILTIN(sub_group_commit_read_pipe, "v.", "tn")
+BUILTIN(sub_group_commit_write_pipe, "v.", "tn")
+
+BUILTIN(work_group_reserve_read_pipe, "i.", "tn")
+BUILTIN(work_group_reserve_write_pipe, "i.", "tn")
+
+BUILTIN(work_group_commit_read_pipe, "v.", "tn")
+BUILTIN(work_group_commit_write_pipe, "v.", "tn")
+
+BUILTIN(get_pipe_num_packets, "Ui.", "tn")
+BUILTIN(get_pipe_max_packets, "Ui.", "tn")
+
 #undef BUILTIN
 #undef LIBBUILTIN
 #undef LANGBUILTIN
diff --git a/include/clang/Basic/DiagnosticDriverKinds.td b/include/clang/Basic/DiagnosticDriverKinds.td
index b04498f..6f60318 100644
--- a/include/clang/Basic/DiagnosticDriverKinds.td
+++ b/include/clang/Basic/DiagnosticDriverKinds.td
@@ -86,6 +86,8 @@ def err_drv_invalid_argument_to_fdebug_prefix_map : Error<
   "invalid argument '%0' to -fdebug-prefix-map">;
 def err_drv_malformed_sanitizer_blacklist : Error<
   "malformed sanitizer blacklist: '%0'">;
+def err_drv_floor_function_info : Error<
+  "unable to open floor function info file">, DefaultFatal;
 
 def err_target_unsupported_arch
   : Error<"the target architecture '%0' is not supported by the target '%1'">;
diff --git a/include/clang/Basic/DiagnosticGroups.td b/include/clang/Basic/DiagnosticGroups.td
index 2e4e57b..20a952c 100644
--- a/include/clang/Basic/DiagnosticGroups.td
+++ b/include/clang/Basic/DiagnosticGroups.td
@@ -844,6 +844,10 @@ def CudaCompat : DiagGroup<"cuda-compat">;
 // A warning group for things that will change semantics in the future.
 def FutureCompat : DiagGroup<"future-compat">;
 
+// A warning group for warnings about code that clang accepts when
+// compiling OpenCL C/C++ but which is not compatible with the SPIR spec.
+def SpirCompat : DiagGroup<"spir-compat">;
+
 def InvalidOrNonExistentDirectory : DiagGroup<"invalid-or-nonexistent-directory">;
 
 def OptionIgnored : DiagGroup<"option-ignored">;
diff --git a/include/clang/Basic/DiagnosticIDs.h b/include/clang/Basic/DiagnosticIDs.h
index 312b71f..d13ae4c 100644
--- a/include/clang/Basic/DiagnosticIDs.h
+++ b/include/clang/Basic/DiagnosticIDs.h
@@ -36,7 +36,7 @@ namespace clang {
       DIAG_START_AST           = DIAG_START_PARSE           +  500,
       DIAG_START_COMMENT       = DIAG_START_AST             +  110,
       DIAG_START_SEMA          = DIAG_START_COMMENT         +  100,
-      DIAG_START_ANALYSIS      = DIAG_START_SEMA            + 3000,
+      DIAG_START_ANALYSIS      = DIAG_START_SEMA            + 4000,
       DIAG_UPPER_LIMIT         = DIAG_START_ANALYSIS        +  100
     };
 
diff --git a/include/clang/Basic/DiagnosticParseKinds.td b/include/clang/Basic/DiagnosticParseKinds.td
index f8dee2f..e0d4bb0 100644
--- a/include/clang/Basic/DiagnosticParseKinds.td
+++ b/include/clang/Basic/DiagnosticParseKinds.td
@@ -909,6 +909,12 @@ def warn_pragma_expected_enable_disable : Warning<
   "expected 'enable' or 'disable' - ignoring">, InGroup<IgnoredPragmas>;
 def warn_pragma_unknown_extension : Warning<
   "unknown OpenCL extension %0 - ignoring">, InGroup<IgnoredPragmas>;
+def err_pragma_enabled_unsupported : Error<
+  "OpenCL extension %0 is unsupported">;
+
+def err_opencl_address_of_label : Error<
+  "OpenCL does not support address of label ('&&') GNU extension">;
+
 
 // OpenCL error
 def err_opencl_taking_function_address_parser : Error<
diff --git a/include/clang/Basic/DiagnosticSemaKinds.td b/include/clang/Basic/DiagnosticSemaKinds.td
index 6ba482c..9129299 100644
--- a/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/include/clang/Basic/DiagnosticSemaKinds.td
@@ -330,6 +330,8 @@ def warn_implicit_function_decl : Warning<
 def ext_implicit_function_decl : ExtWarn<
   "implicit declaration of function %0 is invalid in C99">,
   InGroup<ImplicitFunctionDeclare>;
+def err_opencl_implicit_function_decl : Error<
+  "implicit declaration of function %0 is invalid in OpenCL">;
 def note_function_suggestion : Note<"did you mean %0?">;
 
 def err_ellipsis_first_param : Error<
@@ -589,6 +591,7 @@ def ext_main_used : Extension<
 /// parser diagnostics
 def ext_no_declarators : ExtWarn<"declaration does not declare anything">,
   InGroup<MissingDeclarations>;
+def err_no_declarators : Error<"declaration does not declare anything">;
 def ext_typedef_without_a_name : ExtWarn<"typedef requires a name">,
   InGroup<MissingDeclarations>;
 def err_typedef_not_identifier : Error<"typedef name must be an identifier">;
@@ -603,9 +606,14 @@ def err_object_cannot_be_passed_returned_by_value : Error<
   "; did you forget * in %1?">;
 def err_parameters_retval_cannot_have_fp16_type : Error<
   "%select{parameters|function return value}0 cannot have __fp16 type; did you forget * ?">;
+def err_opencl_dereferencing : Error<
+  "dereferencing pointer of type %0 is not allowed">;
 def err_opencl_half_load_store : Error<
   "%select{loading directly from|assigning directly to}0 pointer to type %1 is not allowed">;
+def err_opencl_subscript : Error<
+  "subscript to array of type %0 is not allowed">;
 def err_opencl_cast_to_half : Error<"casting to type %0 is not allowed">;
+def err_opencl_cast_from_half : Error<"casting from type %0 is not allowed">;
 def err_opencl_half_declaration : Error<
   "declaring variable of type %0 is not allowed">;
 def err_opencl_half_param : Error<
@@ -7169,6 +7177,18 @@ def err_builtin_annotation_first_arg : Error<
 def err_builtin_annotation_second_arg : Error<
   "second argument to __builtin_annotation must be a non-wide string constant">;
 
+// Builtin pipe
+def err_builtin_pipe_first_arg : Error<
+  "first argument to %0 must be a pipe type">;
+def err_builtin_pipe_argument_type_mismatch : Error<
+  "argument type doesn't match pipe type">;
+def err_builtin_pipe_args_num_mismatch : Error<
+  "invalid number of arguments to function: %0">;
+def err_builtin_pipe_invalid_arg : Error<
+  "invalid argument type to function %0 (expecting: %1)">;
+def err_builtin_pipe_invalid_access_modifier : Error<"invalid pipe access modifier (expecting %0)">;
+
+
 // CFString checking
 def err_cfstring_literal_not_string_constant : Error<
   "CFString literal is not a string constant">;
@@ -7636,16 +7656,99 @@ def err_event_t_addr_space_qual : Error<
   "the event_t type can only be used with __private address space qualifier">;
 def err_expected_kernel_void_return_type : Error<
   "kernel must have void return type">;
+def err_opencl20_global_invalid_addr_space : Error<
+  "program scope variables must reside global or constant address space">;
+def err_sampler_initializer_not_integer : Error<
+  "sampler_t initialization requires 32-bit integer, not %0">;
+def warn_sampler_initializer_invalid_bits : Warning<
+  "Sampler initializer has invalid %0 bits">, InGroup<SpirCompat>;
+def err_event_initialization : Error<
+  "cannot initialize event_t">;
+def err_event_argument_not_null : Error<
+  "event_t variable or NULL required - got %0">;
+def err_opencl_missing_type_specifier : Error<
+  "type specifier missing">;
+def err_program_scope_variable_non_constant : Error<
+  "program scope variables are required to be declared in constant address space">;
+def err_program_scope_variable_non_constant_or_global : Error<
+  "program scope variables are required to be declared either in constant or global address space">;
+def err_half_variables : Error<
+  "half type variables are not allowed in OpenCL">;
+def err_invalid_vector_promotion : Error<
+  "cannot apply default argument promotion on a vector">;
+def err_implicit_pointer_address_space_cast : Error<
+  "illegal implicit conversion between two pointers with different address "
+  "spaces">;
+def err_static_variables : Error<
+  "static storage class can be specified only for global and constant variables">;
+def err_enqueue_kernel_num_args_mismatch : Error<
+  "number of local_size argument doesn't match the block's prototype">;
+def err_variadic_enqueue_kernel : Error<
+  "variadic arguments passed to 'enqueue_kernel' has to be of type 'unsigned int'">;
+def err_kernel_arg_address_space : Error<
+  "pointer arguments to kernel functions must reside in '__global', '__constant' or '__local' address space">;
+def err_opencl_pointer_to_image : Error<
+  "pointer to image is invalid in OpenCL">;
+def err_scalar_type_rank_greater_than_vector_type : Error<
+  "scalar operand type has greater rank than the type of the vector element. (%0 and %1)">;
+// Images.
+def err_sampler_initializer_not_constant : Error<
+  "sampler_t initialization requires compile time constant">;
+def err_opencl_image3d_writes : Error<
+  "image3d_t access qualifier write_only requires"
+  " cl_khr_3d_image_writes extension to be enabled">;
+def warn_opencl_image_access_non_image : Warning<
+  "using image access qualifier with non-image type">;
+def err_opencl_image_access_read_write : Error<
+  "image access qualifier read_write is reserved for future use">;
+def err_depth_image_requires_ext : Error<
+  "use of depth image type requires extension cl_khr_depth_images">;
+def err_msaa_image_requires_ext : Error<
+  "use of multi-sample image type requires extension cl_khr_gl_msaa_sharing">;
 def err_sampler_argument_required : Error<
   "sampler_t variable required - got %0">;
 def err_wrong_sampler_addressspace: Error<
   "sampler type cannot be used with the __local and __global address space qualifiers">;
 def err_opencl_global_invalid_addr_space : Error<
   "program scope variable must reside in %0 address space">;
+def err_read_write_with_samplers : Error <
+  "reading from an image declared with 'read_write' qualifier using a sampler is prohibited">;
+def err_image_type_can_be_used_only_as_parameter : Error <
+  "An image type can only be used as a type of a function parameter">;
+// Atomics.
+def err_atomic_init_addressspace : Error<
+  "initialization of atomic variables is restricted to variables in global address space">;
+def err_atomic_init_constant : Error<
+  "atomic variable can only be assigned to a compile time constant"
+  " in the declaration statement in the program scope">;
+// Blocks.
+def err_invalid_block_as_parameter : Error<
+  "block parameter given must take pointers to local memory as parameters (prototype is %0)">;
+def err_block_proto_variadic : Error<
+  "Invalid block prototype, variadic arguments are not allowed">;
+def err_invalid_block_array : Error<
+  "Array of block is invalid in OpenCL">;
+def err_ternary_with_block : Error<
+  "blocks cannot be used as expressions in ternary expressions">;
+// Pipes.
+def err_pipe_can_be_used_only_as_parameter : Error<
+  "pipes can be used only as function parameters">;
+def err_read_write_not_allowed_for_pipes : Error<
+  "read_write access qualifier can't be specified for pipes">;
+def err_mismatch_access_qualifiers : Error<
+  "passing '%0' to '%1' mismatch access qualifiers">;
 def err_missing_actual_pipe_type : Error<
   "missing actual type specifier for pipe">;
+def err_multiple_access_qualifiers : Error<
+  "multiple access qualifiers">;
 def err_reference_pipe_type : Error <
   "pipes packet types cannot be of reference type">;
+def err_nosvm_attr_not_pointer : Error<
+  "nosvm attribute should be used with pointer variables only">;
+def err_nosvm_opencl_version : Error<
+  "nosvm attribute supported in OpenCL 2.0 and above">;
+def warn_ocl_bultin_potential_ambiguity : Warning<
+  "implicit conversion from integral type to floating point type for overloadable function might lead to ambiguity">;
 def err_opencl_no_main : Error<"%select{function|kernel}0 cannot be called 'main'">;
 def err_opencl_kernel_attr :
   Error<"attribute %0 can only be applied to a kernel function">;
@@ -7653,9 +7756,6 @@ def err_opencl_return_value_with_address_space : Error<
   "return value cannot be qualified with address space">;
 def err_opencl_constant_no_init : Error<
   "variable in constant address space must be initialized">;
-def err_atomic_init_constant : Error<
-  "atomic variable can only be assigned to a compile time constant"
-  " in the declaration statement in the program scope">;
 def err_opencl_implicit_vector_conversion : Error<
   "implicit conversions between vector types (%0 and %1) are not permitted">;
 
@@ -8004,6 +8104,8 @@ def note_related_result_type_inferred : Note<
 def note_related_result_type_explicit : Note<
   "%select{overridden|current}0 method is explicitly declared 'instancetype'"
   "%select{| and is expected to return an instance of its class type}0">;
+def err_invalid_type_for_program_scope_var : Error<
+  "the %0 type cannot be used to declare a program scope variable">;
 
 }
 
diff --git a/include/clang/Basic/LangOptions.def b/include/clang/Basic/LangOptions.def
index cc70d62..24b1d64 100644
--- a/include/clang/Basic/LangOptions.def
+++ b/include/clang/Basic/LangOptions.def
@@ -159,6 +159,7 @@ ENUM_LANGOPT(MSPointerToMemberRepresentationMethod, PragmaMSPointersToMembersKin
 LANGOPT(ShortEnums        , 1, 0, "short enum types")
 
 LANGOPT(OpenCL            , 1, 0, "OpenCL")
+LANGOPT(Metal             , 1, 0, "Metal")
 LANGOPT(OpenCLVersion     , 32, 0, "OpenCL version")
 LANGOPT(NativeHalfType    , 1, 0, "Native half type support")
 LANGOPT(HalfArgsAndReturns, 1, 0, "half args and returns")
@@ -236,6 +237,10 @@ LANGOPT(SanitizeAddressFieldPadding, 2, 0, "controls how aggressive is ASan "
                                            "field padding (0: none, 1:least "
                                            "aggressive, 2: more aggressive)")
 
+LANGOPT(CLEnableHalf            , 1, 0, "cl-enable-half flag used")
+LANGOPT(CLSamplerOpaque, 1, 0, "Emit sampler as a pointer to opaque structure")
+LANGOPT(CLVerifySPIR            , 1, 0, "cl-verify-spir flag used")
+
 #undef LANGOPT
 #undef COMPATIBLE_LANGOPT
 #undef BENIGN_LANGOPT
diff --git a/include/clang/Basic/LangOptions.h b/include/clang/Basic/LangOptions.h
index 736d4e0..5e9dcf8 100644
--- a/include/clang/Basic/LangOptions.h
+++ b/include/clang/Basic/LangOptions.h
@@ -74,6 +74,9 @@ public:
     MSVC2015 = 19
   };
 
+  std::fstream* floor_function_info { nullptr };
+  unsigned int floor_image_capabilities { 0 };
+
 public:
   /// \brief Set of enabled sanitizers.
   SanitizerSet Sanitize;
@@ -168,8 +171,36 @@ public:
 #define OPENCLEXT(nm)  unsigned nm : 1;
 #include "clang/Basic/OpenCLExtensions.def"
 
+  OpenCLOptions(LangOptions LangOpts, const OpenCLOptions& SupportedPragmas) {
+#define OPENCLEXT(nm)     nm = 0;
+#define OPENCLEXT_1_2(nm) \
+    if (LangOpts.OpenCL) { \
+      if(LangOpts.OpenCLVersion >= 120 && SupportedPragmas.nm == 1) { \
+        nm = 1; \
+      } else { \
+        nm = 0; \
+      } \
+    }
+
+    #include "clang/Basic/OpenCLExtensions.def"
+  }
+
+  OpenCLOptions(LangOptions LangOpts) {
+#define OPENCLEXT(nm)   nm = 0;
+#define OPENCLEXT_1_2(nm) \
+    if (LangOpts.OpenCL) { \
+      if(LangOpts.OpenCLVersion >= 120) { \
+        nm = 1; \
+      } else { \
+        nm = 0; \
+      } \
+    }
+#include "clang/Basic/OpenCLExtensions.def"
+  }
+
   OpenCLOptions() {
 #define OPENCLEXT(nm)   nm = 0;
+#define OPENCLEXT_1_2(nm) nm = 0;
 #include "clang/Basic/OpenCLExtensions.def"
   }
 };
diff --git a/include/clang/Basic/OpenCLExtensions.def b/include/clang/Basic/OpenCLExtensions.def
index 91fd919..8c60ee6 100644
--- a/include/clang/Basic/OpenCLExtensions.def
+++ b/include/clang/Basic/OpenCLExtensions.def
@@ -11,11 +11,15 @@
 //
 //===----------------------------------------------------------------------===//
 
+#if defined(OPENCLEXT) && !defined(OPENCLEXT_1_2)
+#  define OPENCLEXT_1_2(ID) OPENCLEXT(ID)
+#endif
+
 // OpenCL 1.1.
-OPENCLEXT(cl_khr_fp64)
+OPENCLEXT_1_2(cl_khr_fp64)
 OPENCLEXT(cl_khr_int64_base_atomics)
 OPENCLEXT(cl_khr_int64_extended_atomics)
-OPENCLEXT(cl_khr_fp16)
+OPENCLEXT_1_2(cl_khr_fp16)
 OPENCLEXT(cl_khr_gl_sharing)
 OPENCLEXT(cl_khr_gl_event)
 OPENCLEXT(cl_khr_d3d10_sharing)
@@ -24,12 +28,20 @@ OPENCLEXT(cl_khr_global_int32_extended_atomics)
 OPENCLEXT(cl_khr_local_int32_base_atomics)
 OPENCLEXT(cl_khr_local_int32_extended_atomics)
 OPENCLEXT(cl_khr_byte_addressable_store)
-OPENCLEXT(cl_khr_3d_image_writes)
+OPENCLEXT_1_2(cl_khr_3d_image_writes)
 
 // OpenCL 2.0
 OPENCLEXT(cl_khr_gl_msaa_sharing)
+OPENCLEXT(cl_khr_depth_images)
+OPENCLEXT(cl_khr_subgroups)
+OPENCLEXT(cl_khr_mipmap_image)
+OPENCLEXT(cl_khr_mipmap_image_writes)
 
 // Clang Extensions.
 OPENCLEXT(cl_clang_storage_class_specifiers)
 
+// Intel Vendor Extensions
+OPENCLEXT(cl_intel_subgroups)
+
 #undef OPENCLEXT
+#undef OPENCLEXT_1_2
diff --git a/include/clang/Basic/OpenCLImageTypes.def b/include/clang/Basic/OpenCLImageTypes.def
new file mode 100644
index 0000000..d5e5c91
--- /dev/null
+++ b/include/clang/Basic/OpenCLImageTypes.def
@@ -0,0 +1,109 @@
+//===-- OpenCLImageTypes.def - Metadata about BuiltinTypes ------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//  This file extends builtin types database with OpenCL image singleton types.
+//  Custom code should define one of those two macros:
+//    GENERIC_IMAGE_TYPE(Type, Id) - a generic image with its Id without an
+//      access type
+//    IMAGE_TYPE(Type, Id, SingletonId, AccessType, CGSuffix) - an image type
+//      with given ID, singleton ID access type and a codegen suffix
+
+#ifdef GENERIC_IMAGE_TYPE
+
+#define IMAGE_READ_TYPE(Type, Id) GENERIC_IMAGE_TYPE(Type, Id)
+#define IMAGE_WRITE_TYPE(Type, Id)
+#define IMAGE_READ_WRITE_TYPE(Type, Id)
+
+#else
+
+// NOTE/TODO:
+// this new method of using ro/wo/rw specific image types does not yet
+// work everywhere, is generally incompatible to SPIR 1.2 itself, and I'll
+// not backport this for clang/llvm 3.5
+// -> use the new facilities, but keep using the old/standard type names
+#if 1
+
+#define IMAGE_READ_TYPE(Type, Id) IMAGE_TYPE(Type, Id, Id##Ty, , )
+#define IMAGE_WRITE_TYPE(Type, Id)
+#define IMAGE_READ_WRITE_TYPE(Type, Id)
+
+#else
+
+#ifndef IMAGE_READ_TYPE
+#define IMAGE_READ_TYPE(Type, Id) \
+          IMAGE_TYPE(Type, Id##RO, Id##ROTy,  read_only, _ro)
+#endif
+#ifndef IMAGE_WRITE_TYPE
+#define IMAGE_WRITE_TYPE(Type, Id) \
+          IMAGE_TYPE(Type, Id##WO, Id##WOTy, write_only, _wo)
+#endif
+#ifndef IMAGE_READ_WRITE_TYPE
+#define IMAGE_READ_WRITE_TYPE(Type, Id) \
+          IMAGE_TYPE(Type, Id##RW, Id##RWTy, read_write, _rw)
+#endif
+
+#endif
+
+#endif
+
+IMAGE_READ_TYPE(image1d, OCLImage1d)
+IMAGE_READ_TYPE(image1d_array, OCLImage1dArray)
+IMAGE_READ_TYPE(image1d_buffer, OCLImage1dBuffer)
+IMAGE_READ_TYPE(image2d, OCLImage2d)
+IMAGE_READ_TYPE(image2d_array, OCLImage2dArray)
+IMAGE_READ_TYPE(image2d_depth, OCLImage2dDepth)
+IMAGE_READ_TYPE(image2d_array_depth, OCLImage2dArrayDepth)
+IMAGE_READ_TYPE(image2d_msaa, OCLImage2dMSAA)
+IMAGE_READ_TYPE(image2d_array_msaa, OCLImage2dArrayMSAA)
+IMAGE_READ_TYPE(image2d_msaa_depth, OCLImage2dMSAADepth)
+IMAGE_READ_TYPE(image2d_array_msaa_depth, OCLImage2dArrayMSAADepth)
+IMAGE_READ_TYPE(image3d, OCLImage3d)
+IMAGE_READ_TYPE(imagecube, OCLImageCube)
+IMAGE_READ_TYPE(imagecube_array, OCLImageCubeArray)
+IMAGE_READ_TYPE(imagecube_depth, OCLImageCubeDepth)
+IMAGE_READ_TYPE(imagecube_array_depth, OCLImageCubeArrayDepth)
+
+IMAGE_WRITE_TYPE(image1d, OCLImage1d)
+IMAGE_WRITE_TYPE(image1d_array, OCLImage1dArray)
+IMAGE_WRITE_TYPE(image1d_buffer, OCLImage1dBuffer)
+IMAGE_WRITE_TYPE(image2d, OCLImage2d)
+IMAGE_WRITE_TYPE(image2d_array, OCLImage2dArray)
+IMAGE_WRITE_TYPE(image2d_depth, OCLImage2dDepth)
+IMAGE_WRITE_TYPE(image2d_array_depth, OCLImage2dArrayDepth)
+IMAGE_WRITE_TYPE(image2d_msaa, OCLImage2dMSAA)
+IMAGE_WRITE_TYPE(image2d_array_msaa, OCLImage2dArrayMSAA)
+IMAGE_WRITE_TYPE(image2d_msaa_depth, OCLImage2dMSAADepth)
+IMAGE_WRITE_TYPE(image2d_array_msaa_depth, OCLImage2dArrayMSAADepth)
+IMAGE_WRITE_TYPE(image3d, OCLImage3d)
+IMAGE_WRITE_TYPE(imagecube, OCLImageCube)
+IMAGE_WRITE_TYPE(imagecube_array, OCLImageCubeArray)
+IMAGE_WRITE_TYPE(imagecube_depth, OCLImageCubeDepth)
+IMAGE_WRITE_TYPE(imagecube_array_depth, OCLImageCubeArrayDepth)
+
+IMAGE_READ_WRITE_TYPE(image1d, OCLImage1d)
+IMAGE_READ_WRITE_TYPE(image1d_array, OCLImage1dArray)
+IMAGE_READ_WRITE_TYPE(image1d_buffer, OCLImage1dBuffer)
+IMAGE_READ_WRITE_TYPE(image2d, OCLImage2d)
+IMAGE_READ_WRITE_TYPE(image2d_array, OCLImage2dArray)
+IMAGE_READ_WRITE_TYPE(image2d_depth, OCLImage2dDepth)
+IMAGE_READ_WRITE_TYPE(image2d_array_depth, OCLImage2dArrayDepth)
+IMAGE_READ_WRITE_TYPE(image2d_msaa, OCLImage2dMSAA)
+IMAGE_READ_WRITE_TYPE(image2d_array_msaa, OCLImage2dArrayMSAA)
+IMAGE_READ_WRITE_TYPE(image2d_msaa_depth, OCLImage2dMSAADepth)
+IMAGE_READ_WRITE_TYPE(image2d_array_msaa_depth, OCLImage2dArrayMSAADepth)
+IMAGE_READ_WRITE_TYPE(image3d, OCLImage3d)
+IMAGE_READ_WRITE_TYPE(imagecube, OCLImageCube)
+IMAGE_READ_WRITE_TYPE(imagecube_array, OCLImageCubeArray)
+IMAGE_READ_WRITE_TYPE(imagecube_depth, OCLImageCubeDepth)
+IMAGE_READ_WRITE_TYPE(imagecube_array_depth, OCLImageCubeArrayDepth)
+
+#undef IMAGE_TYPE
+#undef GENERIC_IMAGE_TYPE
+#undef IMAGE_READ_TYPE
+#undef IMAGE_WRITE_TYPE
+#undef IMAGE_READ_WRITE_TYPE
\ No newline at end of file
diff --git a/include/clang/Basic/Specifiers.h b/include/clang/Basic/Specifiers.h
index e284171..1ea9d84 100644
--- a/include/clang/Basic/Specifiers.h
+++ b/include/clang/Basic/Specifiers.h
@@ -73,6 +73,13 @@ namespace clang {
     TST_auto_type,        // __auto_type extension
     TST_unknown_anytype,  // __unknown_anytype extension
     TST_atomic,           // C11 _Atomic
+#define GENERIC_IMAGE_TYPE(ImgType, Id) TST_##ImgType##_t, // OpenCL image types
+#include "clang/Basic/OpenCLImageTypes.def"
+    TST_sampler_t,        // OpenCL sampler_t
+    TST_event_t,          // OpenCL event_t
+    TST_queue_t,          // OpenCL queue_t
+    TST_clk_event_t,      // OpenCL clk_event_t
+    TST_reserve_id_t,     // OpenCL reserve_id_t
     TST_error         // erroneous type
   };
   
@@ -203,6 +210,9 @@ namespace clang {
     SC_PrivateExtern,
 
     // These are only legal on variables.
+    // TODO: are these wanted/unproblematic? (SC_OpenCLWorkGroupLocal was removed due to issues)
+    SC_OpenCLConstant,
+    SC_OpenCLConstantExtern,
     SC_Auto,
     SC_Register
   };
diff --git a/include/clang/Basic/TokenKinds.def b/include/clang/Basic/TokenKinds.def
index 0269451..89730a0 100644
--- a/include/clang/Basic/TokenKinds.def
+++ b/include/clang/Basic/TokenKinds.def
@@ -491,36 +491,21 @@ KEYWORD(__forceinline               , KEYMS)
 KEYWORD(__unaligned                 , KEYMS)
 KEYWORD(__super                     , KEYMS)
 
-// OpenCL address space qualifiers
-KEYWORD(__global                    , KEYOPENCL)
-KEYWORD(__local                     , KEYOPENCL)
-KEYWORD(__constant                  , KEYOPENCL)
-KEYWORD(__private                   , KEYOPENCL)
-KEYWORD(__generic                   , KEYOPENCL)
-ALIAS("global", __global            , KEYOPENCL)
-ALIAS("local", __local              , KEYOPENCL)
-ALIAS("constant", __constant        , KEYOPENCL)
-ALIAS("private", __private          , KEYOPENCL)
-ALIAS("generic", __generic          , KEYOPENCL)
-// OpenCL function qualifiers
-KEYWORD(__kernel                    , KEYOPENCL)
-ALIAS("kernel", __kernel            , KEYOPENCL)
-// OpenCL access qualifiers
-KEYWORD(__read_only                 , KEYOPENCL)
-KEYWORD(__write_only                , KEYOPENCL)
-KEYWORD(__read_write                , KEYOPENCL)
-ALIAS("read_only", __read_only      , KEYOPENCL)
-ALIAS("write_only", __write_only    , KEYOPENCL)
-ALIAS("read_write", __read_write    , KEYOPENCL)
 // OpenCL builtins
-KEYWORD(__builtin_astype            , KEYOPENCL)
-KEYWORD(vec_step                    , KEYOPENCL|KEYALTIVEC|KEYZVECTOR)
+KEYWORD(__builtin_astype            , KEYCXX|KEYOPENCL)
+KEYWORD(sampler_t                   , KEYCXX|KEYOPENCL)
+KEYWORD(event_t                     , KEYCXX|KEYOPENCL)
+KEYWORD(vec_step                    , KEYCXX|KEYOPENCL|KEYALTIVEC|KEYZVECTOR)
+
+// OpenCL 2.0
+KEYWORD(queue_t                     , KEYCXX|KEYOPENCL)
+KEYWORD(clk_event_t                 , KEYCXX|KEYOPENCL)
+KEYWORD(reserve_id_t                , KEYCXX|KEYOPENCL)
+KEYWORD(pipe                        , KEYCXX|KEYOPENCL)
 
 // OpenMP Type Traits
 KEYWORD(__builtin_omp_required_simd_align, KEYALL)
 
-KEYWORD(pipe                        , KEYOPENCL)
-
 // Borland Extensions.
 KEYWORD(__pascal                    , KEYALL)
 
diff --git a/include/clang/CodeGen/BackendUtil.h b/include/clang/CodeGen/BackendUtil.h
index d375a78..423a296 100644
--- a/include/clang/CodeGen/BackendUtil.h
+++ b/include/clang/CodeGen/BackendUtil.h
@@ -27,6 +27,9 @@ namespace clang {
   enum BackendAction {
     Backend_EmitAssembly,  ///< Emit native assembly files
     Backend_EmitBC,        ///< Emit LLVM bitcode files
+    Backend_EmitBC32,      ///< Emit LLVM 3.2 bitcode files
+    Backend_EmitBC35,      ///< Emit LLVM 3.5 bitcode files
+    Backend_EmitSPIRV,     ///< Emit SPIR-V bitcode files
     Backend_EmitLL,        ///< Emit human-readable LLVM assembly
     Backend_EmitNothing,   ///< Don't emit anything (benchmarking mode)
     Backend_EmitMCNull,    ///< Run CodeGen, but don't emit anything
diff --git a/include/clang/CodeGen/CodeGenAction.h b/include/clang/CodeGen/CodeGenAction.h
index cc38e24..9efc991 100644
--- a/include/clang/CodeGen/CodeGenAction.h
+++ b/include/clang/CodeGen/CodeGenAction.h
@@ -78,6 +78,24 @@ public:
   EmitBCAction(llvm::LLVMContext *_VMContext = nullptr);
 };
 
+class EmitBC32Action : public CodeGenAction {
+  virtual void anchor();
+public:
+  EmitBC32Action(llvm::LLVMContext *_VMContext = nullptr);
+};
+
+class EmitBC35Action : public CodeGenAction {
+  virtual void anchor();
+public:
+  EmitBC35Action(llvm::LLVMContext *_VMContext = nullptr);
+};
+
+class EmitSPIRVAction : public CodeGenAction {
+  virtual void anchor();
+public:
+  EmitSPIRVAction(llvm::LLVMContext *_VMContext = nullptr);
+};
+
 class EmitLLVMAction : public CodeGenAction {
   virtual void anchor();
 public:
diff --git a/include/clang/Driver/CC1Options.td b/include/clang/Driver/CC1Options.td
index 051f903..b9e39cb 100644
--- a/include/clang/Driver/CC1Options.td
+++ b/include/clang/Driver/CC1Options.td
@@ -440,6 +440,8 @@ def emit_pch : Flag<["-"], "emit-pch">,
   HelpText<"Generate pre-compiled header file">;
 def emit_llvm_bc : Flag<["-"], "emit-llvm-bc">,
   HelpText<"Build ASTs then convert to LLVM, emit .bc file">;
+def emit_spirv : Flag<["-"], "emit-spirv">,
+  HelpText<"Build ASTs then convert to LLVM then convert to SPIR-V, emit .spv file">;
 def emit_llvm_only : Flag<["-"], "emit-llvm-only">,
   HelpText<"Build ASTs and convert to LLVM, discarding output">;
 def emit_codegen_only : Flag<["-"], "emit-codegen-only">,
@@ -636,6 +638,15 @@ def detailed_preprocessing_record : Flag<["-"], "detailed-preprocessing-record">
   HelpText<"include a detailed record of preprocessing actions">;
 
 //===----------------------------------------------------------------------===//
+// libfloor Options (applying to OpenCL, CUDA and Metal)
+//===----------------------------------------------------------------------===//
+
+def floor_function_info : Joined<["-"], "floor-function-info=">,
+  HelpText<"floor function info output file">;
+def floor_image_capabilities : Joined<["-"], "floor-image-capabilities=">,
+  HelpText<"image read and write capabilities">;
+
+//===----------------------------------------------------------------------===//
 // OpenCL Options
 //===----------------------------------------------------------------------===//
 
@@ -660,6 +671,20 @@ def cl_std_EQ : Joined<["-"], "cl-std=">,
 def cl_denorms_are_zero : Flag<["-"], "cl-denorms-are-zero">,
   HelpText<"OpenCL only. Allow denormals to be flushed to zero">;
 
+def cl_fp32_correctly_rounded_divide_sqrt : Flag<["-"], "cl-fp32-correctly-rounded-divide-sqrt">,
+  HelpText<"OpenCL only. This option causes single precision floating-point divide and sqrt to be correctly rounded.">;
+def cl_enable_half : Flag<["-"], "cl-enable-half">,
+  HelpText<"OpenCL only. This option enables the dereferencing of half pointers">;
+
+// SPIR generator options
+def cl_spir_compile_options : Separate<["-"], "cl-spir-compile-options">,
+  HelpText<"SPIR compilation options to record in metadata">;
+def cl_sampler_type : Separate<["-"], "cl-sampler-type">,
+  HelpText<"OpenCL only. Specify type of sampler to emit. Valid values: \"opaque\"(default), \"i32\"">;
+
+def cl_verify_spir : Flag<["-"], "cl-verify-spir">,
+  HelpText<"OpenCL/SPIR only. Runs the Khronos SPIR verifier on the final LLVM IR.">;
+
 //===----------------------------------------------------------------------===//
 // CUDA Options
 //===----------------------------------------------------------------------===//
@@ -678,6 +703,19 @@ def fcuda_target_overloads : Flag<["-"], "fcuda-target-overloads">,
   HelpText<"Enable function overloads based on CUDA target attributes.">;
 
 //===----------------------------------------------------------------------===//
+// AIR/Metal Options
+//===----------------------------------------------------------------------===//
+
+def metal_intel_workarounds : Flag<["-"], "metal-intel-workarounds">,
+  HelpText<"Enable Intel GPU specific fixes and workarounds">;
+
+//===----------------------------------------------------------------------===//
+// AppleCL/OpenCL Options
+//===----------------------------------------------------------------------===//
+def applecl_kernel_info : Flag<["-"], "applecl-kernel-info">,
+  HelpText<"AppleCL/OpenCL only. Generate general AppleCL and kernel argument metadata.">;
+
+//===----------------------------------------------------------------------===//
 // OpenMP Options
 //===----------------------------------------------------------------------===//
 
diff --git a/include/clang/Driver/Options.td b/include/clang/Driver/Options.td
index e4279e8..2627408 100644
--- a/include/clang/Driver/Options.td
+++ b/include/clang/Driver/Options.td
@@ -402,6 +402,10 @@ def emit_ast : Flag<["-"], "emit-ast">,
   HelpText<"Emit Clang AST files for source inputs">;
 def emit_llvm : Flag<["-"], "emit-llvm">, Flags<[CC1Option]>, Group<Action_Group>,
   HelpText<"Use the LLVM representation for assembler and object files">;
+def llvm_bc_32 : Flag<["-"], "llvm-bc-32">, Flags<[CC1Option]>, Group<Action_Group>,
+  HelpText<"Output LLVM 3.2 compatible bitcode">;
+def llvm_bc_35 : Flag<["-"], "llvm-bc-35">, Flags<[CC1Option]>, Group<Action_Group>,
+  HelpText<"Output LLVM 3.5 compatible bitcode">;
 def exported__symbols__list : Separate<["-"], "exported_symbols_list">;
 def e : JoinedOrSeparate<["-"], "e">;
 def fPIC : Flag<["-"], "fPIC">, Group<f_Group>;
diff --git a/include/clang/Driver/Types.def b/include/clang/Driver/Types.def
index d1b6915..08ae248 100644
--- a/include/clang/Driver/Types.def
+++ b/include/clang/Driver/Types.def
@@ -42,6 +42,7 @@
 TYPE("cpp-output",               PP_C,         INVALID,         "i",     "u")
 TYPE("c",                        C,            PP_C,            "c",     "u")
 TYPE("cl",                       CL,           PP_C,            "cl",    "u")
+TYPE("metal",                    METAL,        PP_CXX,          "cpp",   "u")
 TYPE("cuda-cpp-output",          PP_CUDA,      INVALID,         "cui",   "u")
 TYPE("cuda",                     CUDA,         PP_CUDA,         "cu",    "u")
 TYPE("cuda",                     CUDA_DEVICE,  PP_CUDA,         "cu",    "")
@@ -58,6 +59,7 @@ TYPE("objective-c++",            ObjCXX,       PP_ObjCXX,       "mm",    "u")
 TYPE("c-header-cpp-output",      PP_CHeader,   INVALID,         "i",     "p")
 TYPE("c-header",                 CHeader,      PP_CHeader,      "h",     "pu")
 TYPE("cl-header",                CLHeader,     PP_CHeader,      "h",     "pu")
+TYPE("metal-header",             MetalHeader,  PP_CXXHeader,    "h",     "pu")
 TYPE("objective-c-header-cpp-output", PP_ObjCHeader, INVALID,   "mi",    "p")
 TYPE("objective-c-header",       ObjCHeader,   PP_ObjCHeader,   "h",     "pu")
 TYPE("c++-header-cpp-output",    PP_CXXHeader, INVALID,         "ii",    "p")
@@ -77,6 +79,8 @@ TYPE("java",                     Java,         INVALID,         nullptr, "u")
 // outputs should use the standard suffixes.
 TYPE("ir",                       LLVM_IR,      INVALID,         "ll",    "u")
 TYPE("ir",                       LLVM_BC,      INVALID,         "bc",    "u")
+TYPE("ir",                       LLVM_BC_32,   INVALID,         "bc",    "u")
+TYPE("ir",                       LLVM_BC_35,   INVALID,         "bc",    "u")
 TYPE("lto-ir",                   LTO_IR,       INVALID,         "s",     "")
 TYPE("lto-bc",                   LTO_BC,       INVALID,         "o",     "")
 
diff --git a/include/clang/Frontend/CodeGenOptions.def b/include/clang/Frontend/CodeGenOptions.def
index d9f6ab7..0e11206 100644
--- a/include/clang/Frontend/CodeGenOptions.def
+++ b/include/clang/Frontend/CodeGenOptions.def
@@ -60,6 +60,8 @@ CODEGENOPT(EmitDeclMetadata  , 1, 0) ///< Emit special metadata indicating what
 CODEGENOPT(EmitGcovArcs      , 1, 0) ///< Emit coverage data files, aka. GCDA.
 CODEGENOPT(EmitGcovNotes     , 1, 0) ///< Emit coverage "notes" files, aka GCNO.
 CODEGENOPT(EmitOpenCLArgMetadata , 1, 0) ///< Emit OpenCL kernel arg metadata.
+CODEGENOPT(EmitAppleCLMetadata , 1, 0) ///< Emit AppleCL kernel info and arg metadata.
+CODEGENOPT(MetalIntelWorkarounds , 1, 0) ///< Enable Intel GPU specific fixes and workarounds.
 CODEGENOPT(EmulatedTLS       , 1, 0) ///< Set when -femulated-tls is enabled.
 /// \brief FP_CONTRACT mode (on/off/fast).
 ENUM_CODEGENOPT(FPContractMode, FPContractModeKind, 2, FPC_On)
@@ -149,6 +151,11 @@ CODEGENOPT(VectorizeBB       , 1, 0) ///< Run basic block vectorizer.
 CODEGENOPT(VectorizeLoop     , 1, 0) ///< Run loop vectorizer.
 CODEGENOPT(VectorizeSLP      , 1, 0) ///< Run SLP vectorizer.
 
+CODEGENOPT(DenormsAreZero    , 1, 0) ///< Allow flushing of denorms to zero.
+CODEGENOPT(CorrectFPDivideSqrt , 1, 0) ///< Single precision divide and sqrt are
+                                       ///< correctly rounded.
+CODEGENOPT(OptDisable        , 1, 0) ///< Disables all optimizations.
+
   /// Attempt to use register sized accesses to bit-fields in structures, when
   /// possible.
 CODEGENOPT(UseRegisterSizedBitfieldAccess , 1, 0)
diff --git a/include/clang/Frontend/CodeGenOptions.h b/include/clang/Frontend/CodeGenOptions.h
index 7550e6f..f41e859 100644
--- a/include/clang/Frontend/CodeGenOptions.h
+++ b/include/clang/Frontend/CodeGenOptions.h
@@ -161,6 +161,9 @@ public:
   /// A list of command-line options to forward to the LLVM backend.
   std::vector<std::string> BackendOptions;
 
+  /// OpenCL compile options to embed in the SPIR metadata
+  std::string SPIRCompileOptions;
+
   /// A list of dependent libraries.
   std::vector<std::string> DependentLibraries;
 
diff --git a/include/clang/Frontend/FrontendOptions.h b/include/clang/Frontend/FrontendOptions.h
index c800a51..8e265ee 100644
--- a/include/clang/Frontend/FrontendOptions.h
+++ b/include/clang/Frontend/FrontendOptions.h
@@ -33,6 +33,9 @@ namespace frontend {
     DumpTokens,             ///< Dump out preprocessed tokens.
     EmitAssembly,           ///< Emit a .s file.
     EmitBC,                 ///< Emit a .bc file.
+    EmitBC32,               ///< Emit a LLVM 3.2 .bc file.
+    EmitBC35,               ///< Emit a LLVM 3.5 .bc file.
+    EmitSPIRV,              ///< Emit a .spv file.
     EmitHTML,               ///< Translate input source into HTML.
     EmitLLVM,               ///< Emit a .ll file.
     EmitLLVMOnly,           ///< Generate LLVM IR, but do not emit anything.
@@ -71,6 +74,7 @@ enum InputKind {
   IK_PreprocessedObjC,
   IK_PreprocessedObjCXX,
   IK_OpenCL,
+  IK_Metal,
   IK_CUDA,
   IK_PreprocessedCuda,
   IK_AST,
diff --git a/include/clang/Frontend/LangStandards.def b/include/clang/Frontend/LangStandards.def
index cac9c3c..67332da 100644
--- a/include/clang/Frontend/LangStandards.def
+++ b/include/clang/Frontend/LangStandards.def
@@ -134,20 +134,31 @@ LANGSTANDARD(gnucxx1z, "gnu++1z",
 // OpenCL
 LANGSTANDARD(opencl, "cl",
              "OpenCL 1.0",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | Digraphs | HexFloat | GNUMode)
 LANGSTANDARD(opencl11, "CL1.1",
              "OpenCL 1.1",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | Digraphs | HexFloat | GNUMode)
 LANGSTANDARD(opencl12, "CL1.2",
              "OpenCL 1.2",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | Digraphs | HexFloat | GNUMode)
 LANGSTANDARD(opencl20, "CL2.0",
              "OpenCL 2.0",
-             LineComment | C99 | Digraphs | HexFloat)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | Digraphs | HexFloat | GNUMode)
+LANGSTANDARD(opencl21, "CL2.1",
+             "OpenCL 2.1",
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | Digraphs | HexFloat | GNUMode)
+LANGSTANDARD(opencl22, "CL2.2",
+             "OpenCL 2.2",
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | Digraphs | HexFloat | GNUMode)
+
+// Metal
+LANGSTANDARD(metal11, "metal1.1",
+             "Metal 1.1",
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | Digraphs | HexFloat | GNUMode)
 
 // CUDA
 LANGSTANDARD(cuda, "cuda",
              "NVIDIA CUDA(tm)",
-             LineComment | CPlusPlus | Digraphs)
+             LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | Digraphs | HexFloat | GNUMode)
 
 #undef LANGSTANDARD
diff --git a/include/clang/Lex/LiteralSupport.h b/include/clang/Lex/LiteralSupport.h
index d568614..c1c5e00 100644
--- a/include/clang/Lex/LiteralSupport.h
+++ b/include/clang/Lex/LiteralSupport.h
@@ -61,6 +61,7 @@ public:
   bool isUnsigned : 1;
   bool isLong : 1;          // This is *not* set for long long.
   bool isLongLong : 1;
+  bool isHalf;              // 1.0h
   bool isFloat : 1;         // 1.0f
   bool isImaginary : 1;     // 1.0i
   uint8_t MicrosoftInteger; // Microsoft suffix extension i8, i16, i32, or i64.
diff --git a/include/clang/Lex/Preprocessor.h b/include/clang/Lex/Preprocessor.h
index f6154b6..7c406d6 100644
--- a/include/clang/Lex/Preprocessor.h
+++ b/include/clang/Lex/Preprocessor.h
@@ -104,6 +104,7 @@ class Preprocessor : public RefCountedBase<Preprocessor> {
   std::unique_ptr<ScratchBuffer> ScratchBuf;
   HeaderSearch      &HeaderInfo;
   ModuleLoader      &TheModuleLoader;
+  OpenCLOptions     SupportedPragmas;
 
   /// \brief External source of macros.
   ExternalPreprocessorSource *ExternalSource;
@@ -680,6 +681,12 @@ public:
   DiagnosticsEngine &getDiagnostics() const { return *Diags; }
   void setDiagnostics(DiagnosticsEngine &D) { Diags = &D; }
 
+  const OpenCLOptions &getSupportedPragmas() const { return SupportedPragmas; }
+  void setSupportedPragmas(const OpenCLOptions &opts)
+  {
+    SupportedPragmas = opts;
+  }
+
   const LangOptions &getLangOpts() const { return LangOpts; }
   const TargetInfo &getTargetInfo() const { return *Target; }
   const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }
diff --git a/include/clang/Lex/PreprocessorOptions.h b/include/clang/Lex/PreprocessorOptions.h
index 963d95d..2dd1099 100644
--- a/include/clang/Lex/PreprocessorOptions.h
+++ b/include/clang/Lex/PreprocessorOptions.h
@@ -20,6 +20,7 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include "clang/Basic/LangOptions.h"
 
 namespace llvm {
   class MemoryBuffer;
@@ -55,6 +56,9 @@ public:
   /// definitions and expansions.
   unsigned DetailedRecord : 1;
 
+  /// Initialize the preprocessor list of supported pragmas
+  OpenCLOptions SupportedPragmas;
+
   /// The implicit PCH included at the start of the translation unit, or empty.
   std::string ImplicitPCHInclude;
 
diff --git a/include/clang/Parse/Parser.h b/include/clang/Parse/Parser.h
index 00885a5..2be247c 100644
--- a/include/clang/Parse/Parser.h
+++ b/include/clang/Parse/Parser.h
@@ -1408,10 +1408,12 @@ private:
   ExprResult ParseCastExpression(bool isUnaryExpression,
                                  bool isAddressOfOperand,
                                  bool &NotCastExpr,
-                                 TypeCastState isTypeCast);
+                                 TypeCastState isTypeCast,
+                                 bool isVectorLiteral = false);
   ExprResult ParseCastExpression(bool isUnaryExpression,
                                  bool isAddressOfOperand = false,
-                                 TypeCastState isTypeCast = NotTypeCast);
+                                 TypeCastState isTypeCast = NotTypeCast,
+                                 bool isVectorLiteral = false);
 
   /// Returns true if the next token cannot start an expression.
   bool isNotExpressionStart();
diff --git a/include/clang/Sema/DeclSpec.h b/include/clang/Sema/DeclSpec.h
index 064d37b..2e7439d 100644
--- a/include/clang/Sema/DeclSpec.h
+++ b/include/clang/Sema/DeclSpec.h
@@ -299,6 +299,14 @@ public:
   static const TST TST_auto_type = clang::TST_auto_type;
   static const TST TST_unknown_anytype = clang::TST_unknown_anytype;
   static const TST TST_atomic = clang::TST_atomic;
+#define GENERIC_IMAGE_TYPE(ImgType, Id) \
+  static const TST TST_##ImgType##_t = clang::TST_##ImgType##_t;
+#include "clang/Basic/OpenCLImageTypes.def"
+  static const TST TST_sampler_t = clang::TST_sampler_t;
+  static const TST TST_event_t = clang::TST_event_t;
+  static const TST TST_queue_t = clang::TST_queue_t;
+  static const TST TST_clk_event_t = clang::TST_clk_event_t;
+  static const TST TST_reserve_id_t = clang::TST_reserve_id_t;
   static const TST TST_error = clang::TST_error;
 
   // type-qualifiers
diff --git a/include/clang/Sema/Initialization.h b/include/clang/Sema/Initialization.h
index d4f57b7..d2fc5f1 100644
--- a/include/clang/Sema/Initialization.h
+++ b/include/clang/Sema/Initialization.h
@@ -710,6 +710,8 @@ public:
     SK_StdInitializerListConstructorCall,
     /// \brief Initialize an OpenCL sampler from an integer.
     SK_OCLSamplerInit,
+    /// \brief Initialize queue_t from 0.
+    SK_OCLZeroQueue,
     /// \brief Passing zero to a function where OpenCL event_t is expected.
     SK_OCLZeroEvent
   };
@@ -1090,6 +1092,9 @@ public:
   /// constant.
   void AddOCLZeroEventStep(QualType T);
 
+  /// \brief Add a step to initialize an OpenCL queue_t from 0.
+  void AddOCLZeroQueueStep(QualType T);
+
   /// \brief Add steps to unwrap a initializer list for a reference around a
   /// single element and rewrap it at the end.
   void RewrapReferenceInitList(QualType T, InitListExpr *Syntactic);
diff --git a/include/clang/Sema/Overload.h b/include/clang/Sema/Overload.h
index 6243795..b79e028 100644
--- a/include/clang/Sema/Overload.h
+++ b/include/clang/Sema/Overload.h
@@ -83,6 +83,8 @@ namespace clang {
     ICK_TransparentUnionConversion, ///< Transparent Union Conversions
     ICK_Writeback_Conversion,  ///< Objective-C ARC writeback conversion
     ICK_Zero_Event_Conversion, ///< Zero constant to event (OpenCL1.2 6.12.10)
+    ICK_Zero_Queue_Conversion, ///< Zero constant to queue
+    ICK_Int_Sampler_Conversion, ///< Integer constant to OpenCL sampler
     ICK_C_Only_Conversion,     ///< Conversions allowed in C, but not C++
     ICK_Num_Conversion_Kinds,  ///< The number of conversion kinds
   };
@@ -95,6 +97,7 @@ namespace clang {
     ICR_Exact_Match = 0,         ///< Exact Match
     ICR_Promotion,               ///< Promotion
     ICR_Conversion,              ///< Conversion
+    ICR_OCL_Scalar_Widening,     ///< OpenCL Scalar Widening
     ICR_Complex_Real_Conversion, ///< Complex <-> Real conversion
     ICR_Writeback_Conversion,    ///< ObjC ARC writeback conversion
     ICR_C_Conversion             ///< Conversion only allowed in the C standard.
@@ -578,6 +581,8 @@ namespace clang {
     /// (CUDA) This candidate was not viable because the callee
     /// was not accessible from the caller's target (i.e. host->device,
     /// global->host, device->host).
+    /// (OpenCL) This candidate was not viable because the callee
+    /// uses extensions that are not enabled or supported.
     ovl_fail_bad_target,
 
     /// This candidate function was not viable because an enable_if
diff --git a/include/clang/Sema/Sema.h b/include/clang/Sema/Sema.h
index 29aa642..79402ee 100644
--- a/include/clang/Sema/Sema.h
+++ b/include/clang/Sema/Sema.h
@@ -7812,6 +7812,10 @@ public:
   /// \param Init First part of the for loop.
   void ActOnOpenMPLoopInitialization(SourceLocation ForLoc, Stmt *Init);
 
+  /// Adds a color(location) attribute to a particular declaration.
+  void AddGraphicsFBOColorLocationAttr(SourceRange AttrRange, Decl *D, Expr *E,
+                                       unsigned SpellingListIndex);
+
   // OpenMP directives and clauses.
   /// \brief Called on correct id-expression from the '#pragma omp
   /// threadprivate'.
diff --git a/include/clang/Sema/SemaInternal.h b/include/clang/Sema/SemaInternal.h
index 60c6598..bea86fa 100644
--- a/include/clang/Sema/SemaInternal.h
+++ b/include/clang/Sema/SemaInternal.h
@@ -56,7 +56,7 @@ inline bool DeclAttrsMatchCUDAMode(const LangOptions &LangOpts, Decl *D) {
     return true;
   bool isDeviceSideDecl = D->hasAttr<CUDADeviceAttr>() ||
                           D->hasAttr<CUDASharedAttr>() ||
-                          D->hasAttr<CUDAGlobalAttr>();
+                          D->hasAttr<ComputeKernelAttr>();
   return isDeviceSideDecl == LangOpts.CUDAIsDevice;
 }
 
diff --git a/include/clang/Serialization/ASTBitCodes.h b/include/clang/Serialization/ASTBitCodes.h
index 0dfb8cf..58719f6 100644
--- a/include/clang/Serialization/ASTBitCodes.h
+++ b/include/clang/Serialization/ASTBitCodes.h
@@ -772,44 +772,24 @@ namespace clang {
       PREDEF_TYPE_PSEUDO_OBJECT = 35,
       /// \brief The placeholder type for builtin functions.
       PREDEF_TYPE_BUILTIN_FN = 36,
-      /// \brief OpenCL 1d image type.
-      PREDEF_TYPE_IMAGE1D_ID    = 37,
-      /// \brief OpenCL 1d image array type.
-      PREDEF_TYPE_IMAGE1D_ARR_ID = 38,
-      /// \brief OpenCL 1d image buffer type.
-      PREDEF_TYPE_IMAGE1D_BUFF_ID = 39,
-      /// \brief OpenCL 2d image type.
-      PREDEF_TYPE_IMAGE2D_ID    = 40,
-      /// \brief OpenCL 2d image array type.
-      PREDEF_TYPE_IMAGE2D_ARR_ID = 41,
-      /// \brief OpenCL 2d image depth type.
-      PREDEF_TYPE_IMAGE2D_DEP_ID = 42,
-      /// \brief OpenCL 2d image array depth type.
-      PREDEF_TYPE_IMAGE2D_ARR_DEP_ID = 43,
-      /// \brief OpenCL 2d image MSAA type.
-      PREDEF_TYPE_IMAGE2D_MSAA_ID = 44,
-      /// \brief OpenCL 2d image array MSAA type.
-      PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID = 45,
-      /// \brief OpenCL 2d image MSAA depth type.
-      PREDEF_TYPE_IMAGE2D_MSAA_DEP_ID = 46,
-      /// \brief OpenCL 2d image array MSAA depth type.
-      PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID = 47,
-      /// \brief OpenCL 3d image type.
-      PREDEF_TYPE_IMAGE3D_ID    = 48,
       /// \brief OpenCL event type.
-      PREDEF_TYPE_EVENT_ID      = 49,
+      PREDEF_TYPE_EVENT_ID      = 37,
       /// \brief OpenCL clk event type.
-      PREDEF_TYPE_CLK_EVENT_ID  = 50,
+      PREDEF_TYPE_CLK_EVENT_ID  = 38,
       /// \brief OpenCL sampler type.
-      PREDEF_TYPE_SAMPLER_ID    = 51,
+      PREDEF_TYPE_SAMPLER_ID    = 39,
       /// \brief OpenCL queue type.
-      PREDEF_TYPE_QUEUE_ID      = 52,
+      PREDEF_TYPE_QUEUE_ID      = 40,
       /// \brief OpenCL ndrange type.
-      PREDEF_TYPE_NDRANGE_ID    = 53,
+      PREDEF_TYPE_NDRANGE_ID    = 41,
       /// \brief OpenCL reserve_id type.
-      PREDEF_TYPE_RESERVE_ID_ID = 54,
+      PREDEF_TYPE_RESERVE_ID_ID = 42,
       /// \brief The placeholder type for OpenMP array section.
-      PREDEF_TYPE_OMP_ARRAY_SECTION = 55
+      PREDEF_TYPE_OMP_ARRAY_SECTION = 43,
+      /// \brief OpenCL image types with auto numeration
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+      PREDEF_TYPE_##Id##_ID,
+#include "clang/Basic/OpenCLImageTypes.def"
     };
 
     /// \brief The number of predefined type IDs that are reserved for
diff --git a/include/clang/module.modulemap b/include/clang/module.modulemap
index 28b6d16..440e8f0 100644
--- a/include/clang/module.modulemap
+++ b/include/clang/module.modulemap
@@ -41,6 +41,7 @@ module Clang_Basic {
   textual header "Basic/DiagnosticOptions.def"
   textual header "Basic/LangOptions.def"
   textual header "Basic/OpenCLExtensions.def"
+  textual header "Basic/OpenCLImageTypes.def"
   textual header "Basic/OpenMPKinds.def"
   textual header "Basic/OperatorKinds.def"
   textual header "Basic/Sanitizers.def"
diff --git a/lib/AST/ASTContext.cpp b/lib/AST/ASTContext.cpp
index 6438696..a51d469 100644
--- a/lib/AST/ASTContext.cpp
+++ b/lib/AST/ASTContext.cpp
@@ -744,6 +744,7 @@ ASTContext::ASTContext(LangOptions &LOpts, SourceManager &SM,
       BlockDescriptorExtendedType(nullptr), cudaConfigureCallDecl(nullptr),
       FirstLocalImport(), LastLocalImport(), ExternCContext(nullptr),
       MakeIntegerSeqDecl(nullptr), SourceMgr(SM), LangOpts(LOpts),
+      disabledFPContract(false),
       SanitizerBL(new SanitizerBlacklist(LangOpts.SanitizerBlacklistFiles, SM)),
       AddrSpaceMap(nullptr), Target(nullptr), AuxTarget(nullptr),
       PrintingPolicy(LOpts), Idents(idents), Selectors(sels),
@@ -1089,20 +1090,10 @@ void ASTContext::InitBuiltinTypes(const TargetInfo &Target,
   InitBuiltinType(ObjCBuiltinClassTy, BuiltinType::ObjCClass);
   InitBuiltinType(ObjCBuiltinSelTy, BuiltinType::ObjCSel);
 
-  if (LangOpts.OpenCL) { 
-    InitBuiltinType(OCLImage1dTy, BuiltinType::OCLImage1d);
-    InitBuiltinType(OCLImage1dArrayTy, BuiltinType::OCLImage1dArray);
-    InitBuiltinType(OCLImage1dBufferTy, BuiltinType::OCLImage1dBuffer);
-    InitBuiltinType(OCLImage2dTy, BuiltinType::OCLImage2d);
-    InitBuiltinType(OCLImage2dArrayTy, BuiltinType::OCLImage2dArray);
-    InitBuiltinType(OCLImage2dDepthTy, BuiltinType::OCLImage2dDepth);
-    InitBuiltinType(OCLImage2dArrayDepthTy, BuiltinType::OCLImage2dArrayDepth);
-    InitBuiltinType(OCLImage2dMSAATy, BuiltinType::OCLImage2dMSAA);
-    InitBuiltinType(OCLImage2dArrayMSAATy, BuiltinType::OCLImage2dArrayMSAA);
-    InitBuiltinType(OCLImage2dMSAADepthTy, BuiltinType::OCLImage2dMSAADepth);
-    InitBuiltinType(OCLImage2dArrayMSAADepthTy,
-                    BuiltinType::OCLImage2dArrayMSAADepth);
-    InitBuiltinType(OCLImage3dTy, BuiltinType::OCLImage3d);
+  if (LangOpts.OpenCL) {
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    InitBuiltinType(SingletonId, BuiltinType::Id);
+#include "clang/Basic/OpenCLImageTypes.def"
 
     InitBuiltinType(OCLSamplerTy, BuiltinType::OCLSampler);
     InitBuiltinType(OCLEventTy, BuiltinType::OCLEvent);
@@ -1676,22 +1667,13 @@ TypeInfo ASTContext::getTypeInfoImpl(const Type *T) const {
       Align = Target->getIntAlign();
       break;
     case BuiltinType::OCLEvent:
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
     case BuiltinType::OCLClkEvent:
     case BuiltinType::OCLQueue:
     case BuiltinType::OCLNDRange:
     case BuiltinType::OCLReserveID:
-    case BuiltinType::OCLImage1d:
-    case BuiltinType::OCLImage1dArray:
-    case BuiltinType::OCLImage1dBuffer:
-    case BuiltinType::OCLImage2d:
-    case BuiltinType::OCLImage2dArray:
-    case BuiltinType::OCLImage2dDepth:
-    case BuiltinType::OCLImage2dArrayDepth:
-    case BuiltinType::OCLImage2dMSAA:
-    case BuiltinType::OCLImage2dArrayMSAA:
-    case BuiltinType::OCLImage2dMSAADepth:
-    case BuiltinType::OCLImage2dArrayMSAADepth:
-    case BuiltinType::OCLImage3d:
       // Currently these types are pointers to opaque types.
       Width = Target->getPointerWidth(0);
       Align = Target->getPointerAlign(0);
@@ -5460,18 +5442,9 @@ static char getObjCEncodingForPrimitiveKind(const ASTContext *C,
       llvm_unreachable("@encoding ObjC primitive type");
 
     // OpenCL and placeholder types don't need @encodings.
-    case BuiltinType::OCLImage1d:
-    case BuiltinType::OCLImage1dArray:
-    case BuiltinType::OCLImage1dBuffer:
-    case BuiltinType::OCLImage2d:
-    case BuiltinType::OCLImage2dArray:
-    case BuiltinType::OCLImage2dDepth:
-    case BuiltinType::OCLImage2dArrayDepth:
-    case BuiltinType::OCLImage2dMSAA:
-    case BuiltinType::OCLImage2dArrayMSAA:
-    case BuiltinType::OCLImage2dMSAADepth:
-    case BuiltinType::OCLImage2dArrayMSAADepth:
-    case BuiltinType::OCLImage3d:
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
     case BuiltinType::OCLEvent:
     case BuiltinType::OCLClkEvent:
     case BuiltinType::OCLQueue:
@@ -7450,13 +7423,34 @@ QualType ASTContext::mergeFunctionTypes(QualType lhs, QualType rhs,
   if (lproto && rproto) { // two C99 style function prototypes
     assert(!lproto->hasExceptionSpec() && !rproto->hasExceptionSpec() &&
            "C++ shouldn't be here");
-    // Compatible functions must have the same number of parameters
-    if (lproto->getNumParams() != rproto->getNumParams())
-      return QualType();
+    unsigned lproto_nargs = lproto->getNumParams();
+    unsigned rproto_nargs = rproto->getNumParams();
 
-    // Variadic and non-variadic functions aren't compatible
-    if (lproto->isVariadic() != rproto->isVariadic())
-      return QualType();
+    if ( LangOpts.OpenCLVersion < 200 || !lproto->isVariadic() ) {
+      // Compatible functions must have the same number of arguments
+      if (lproto_nargs != rproto_nargs)
+        return QualType();
+
+      // Variadic and non-variadic functions aren't compatible
+      if (lproto->isVariadic() != rproto->isVariadic())
+        return QualType();
+
+    } else {
+
+      if ( !lproto->isVariadic() && !lproto->isVariadic() ) {
+        if (lproto_nargs != rproto_nargs)
+          return QualType();
+
+      } else if ( lproto->isVariadic() ) {
+        if (lproto_nargs > rproto_nargs)
+          return QualType();
+
+      } else if ( rproto->isVariadic() ) {
+        if (lproto_nargs < rproto_nargs)
+          return QualType();
+
+      }
+    }
 
     if (lproto->getTypeQuals() != rproto->getTypeQuals())
       return QualType();
@@ -8350,7 +8344,7 @@ static GVALinkage basicGVALinkageForFunction(const ASTContext &Context,
   if (!FD->isInlined())
     return External;
 
-  if ((!Context.getLangOpts().CPlusPlus &&
+  if ((!Context.getLangOpts().CPlusPlus && !Context.getLangOpts().OpenCL &&
        !Context.getTargetInfo().getCXXABI().isMicrosoft() &&
        !FD->hasAttr<DLLExportAttr>()) ||
       FD->hasAttr<GNUInlineAttr>()) {
@@ -8380,7 +8374,7 @@ static GVALinkage adjustGVALinkageForAttributes(GVALinkage L, const Decl *D) {
   if (D->hasAttr<DLLImportAttr>()) {
     if (L == GVA_DiscardableODR || L == GVA_StrongODR)
       return GVA_AvailableExternally;
-  } else if (D->hasAttr<DLLExportAttr>() || D->hasAttr<CUDAGlobalAttr>()) {
+  } else if (D->hasAttr<DLLExportAttr>()) {
     if (L == GVA_DiscardableODR)
       return GVA_StrongODR;
   }
@@ -8541,6 +8535,11 @@ bool ASTContext::DeclMustBeEmitted(const Decl *D) {
 
 CallingConv ASTContext::getDefaultCallingConvention(bool IsVariadic,
                                                     bool IsCXXMethod) const {
+  // TODO/NOTE: disabling this for now, this should already be handled elsewhere (and would need applecl/metal handling here)
+  //if (getTargetInfo().getTriple().getArch() == llvm::Triple::spir ||
+  //  getTargetInfo().getTriple().getArch() == llvm::Triple::spir64)
+  //  return CC_SpirFunction;
+
   // Pass through to the C++ ABI object
   if (IsCXXMethod)
     return ABI->getDefaultMethodCallConv(IsVariadic);
diff --git a/lib/AST/ASTImporter.cpp b/lib/AST/ASTImporter.cpp
index 916f108..5c0f18c 100644
--- a/lib/AST/ASTImporter.cpp
+++ b/lib/AST/ASTImporter.cpp
@@ -1480,6 +1480,10 @@ QualType ASTNodeImporter::VisitType(const Type *T) {
 
 QualType ASTNodeImporter::VisitBuiltinType(const BuiltinType *T) {
   switch (T->getKind()) {
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id: \
+    return Importer.getToContext().SingletonId;
+#include "clang/Basic/OpenCLImageTypes.def"
 #define SHARED_SINGLETON_TYPE(Expansion)
 #define BUILTIN_TYPE(Id, SingletonId) \
   case BuiltinType::Id: return Importer.getToContext().SingletonId;
diff --git a/lib/AST/Decl.cpp b/lib/AST/Decl.cpp
index 427ca5e..3f460f9 100644
--- a/lib/AST/Decl.cpp
+++ b/lib/AST/Decl.cpp
@@ -1772,6 +1772,8 @@ const char *VarDecl::getStorageClassSpecifierString(StorageClass SC) {
   case SC_None:                 break;
   case SC_Auto:                 return "auto";
   case SC_Extern:               return "extern";
+  case SC_OpenCLConstantExtern: return "<<opencl-constant-extern>>";
+  case SC_OpenCLConstant:       return "<<opencl-constant>>";
   case SC_PrivateExtern:        return "__private_extern__";
   case SC_Register:             return "register";
   case SC_Static:               return "static";
@@ -2733,6 +2735,16 @@ unsigned FunctionDecl::getBuiltinID() const {
   if (getStorageClass() == SC_Static)
     return 0;
 
+  // OpenCL v1.2 s6.9.f:
+  // The library functions defined in the C99 standard headers assert.h,
+  // ctype.h, complex.h, errno.h, fenv.h, float.h, inttypes.h, limits.h,
+  // locale.h, setjmp.h, signal.h, stdarg.h, stdio.h, stdlib.h, string.h,
+  // tgmath.h, time.h, wchar.h and wctype.h are not available and cannot
+  // be included by a program.
+  if (Context.getLangOpts().OpenCL &&
+      Context.BuiltinInfo.isPredefinedLibFunction(BuiltinID))
+    return 0;
+
   return BuiltinID;
 }
 
diff --git a/lib/AST/DeclPrinter.cpp b/lib/AST/DeclPrinter.cpp
index 5c6002d..3fff99f 100644
--- a/lib/AST/DeclPrinter.cpp
+++ b/lib/AST/DeclPrinter.cpp
@@ -450,6 +450,7 @@ void DeclPrinter::VisitFunctionDecl(FunctionDecl *D) {
     case SC_Static: Out << "static "; break;
     case SC_PrivateExtern: Out << "__private_extern__ "; break;
     case SC_Auto: case SC_Register:
+    case SC_OpenCLConstant: case SC_OpenCLConstantExtern:
       llvm_unreachable("invalid for functions");
     }
 
diff --git a/lib/AST/Expr.cpp b/lib/AST/Expr.cpp
index 52f34df..98eceb9 100644
--- a/lib/AST/Expr.cpp
+++ b/lib/AST/Expr.cpp
@@ -1571,6 +1571,8 @@ bool CastExpr::CastConsistency() const {
   case CK_ARCReclaimReturnedObject:
   case CK_ARCExtendBlockObject:
   case CK_ZeroToOCLEvent:
+  case CK_ZeroToOCLQueue:
+  case CK_IntToOCLSampler:
     assert(!getType()->isBooleanType() && "unheralded conversion to bool");
     goto CheckNoBasePath;
 
@@ -1707,6 +1709,10 @@ const char *CastExpr::getCastKindName() const {
     return "BuiltinFnToFnPtr";
   case CK_ZeroToOCLEvent:
     return "ZeroToOCLEvent";
+  case CK_ZeroToOCLQueue:
+    return "ZeroToOCLQueue";
+  case CK_IntToOCLSampler:
+    return "IntToOCLSampler";
   case CK_AddressSpaceConversion:
     return "AddressSpaceConversion";
   }
@@ -2886,6 +2892,7 @@ bool Expr::isConstantInitializer(ASTContext &Ctx, bool IsForRef,
         CE->getCastKind() == CK_ToUnion ||
         CE->getCastKind() == CK_ConstructorConversion ||
         CE->getCastKind() == CK_NonAtomicToAtomic ||
+        CE->getCastKind() == CK_IntToOCLSampler ||
         CE->getCastKind() == CK_AtomicToNonAtomic)
       return CE->getSubExpr()->isConstantInitializer(Ctx, false, Culprit);
 
diff --git a/lib/AST/ExprConstant.cpp b/lib/AST/ExprConstant.cpp
index fa652ba..821f4af 100644
--- a/lib/AST/ExprConstant.cpp
+++ b/lib/AST/ExprConstant.cpp
@@ -911,7 +911,8 @@ CallStackFrame::~CallStackFrame() {
 APValue &CallStackFrame::createTemporary(const void *Key,
                                          bool IsLifetimeExtended) {
   APValue &Result = Temporaries[Key];
-  assert(Result.isUninit() && "temporary created multiple times");
+  // TODO: fix this!
+  //assert(Result.isUninit() && "temporary created multiple times");
   Info.CleanupStack.push_back(Cleanup(&Result, IsLifetimeExtended));
   return Result;
 }
@@ -6005,7 +6006,8 @@ public:
     : ExprEvaluatorBaseTy(info), Result(result) {}
 
   bool Success(const llvm::APSInt &SI, const Expr *E, APValue &Result) {
-    assert(E->getType()->isIntegralOrEnumerationType() &&
+    assert((E->getType()->isIntegralOrEnumerationType() ||
+            E->getType()->isSamplerT()) &&
            "Invalid evaluation result.");
     assert(SI.isSigned() == E->getType()->isSignedIntegerOrEnumerationType() &&
            "Invalid evaluation result.");
@@ -6019,7 +6021,8 @@ public:
   }
 
   bool Success(const llvm::APInt &I, const Expr *E, APValue &Result) {
-    assert(E->getType()->isIntegralOrEnumerationType() && 
+    assert((E->getType()->isIntegralOrEnumerationType() ||
+            E->getType()->isSamplerT()) &&
            "Invalid evaluation result.");
     assert(I.getBitWidth() == Info.Ctx.getIntWidth(E->getType()) &&
            "Invalid evaluation result.");
@@ -6033,7 +6036,8 @@ public:
   }
 
   bool Success(uint64_t Value, const Expr *E, APValue &Result) {
-    assert(E->getType()->isIntegralOrEnumerationType() && 
+    assert((E->getType()->isIntegralOrEnumerationType() ||
+            E->getType()->isSamplerT()) &&
            "Invalid evaluation result.");
     Result = APValue(Info.Ctx.MakeIntValue(Value, E->getType()));
     return true;
@@ -7757,10 +7761,19 @@ bool IntExprEvaluator::VisitCastExpr(const CastExpr *E) {
   case CK_IntegralComplexToFloatingComplex:
   case CK_BuiltinFnToFnPtr:
   case CK_ZeroToOCLEvent:
+  case CK_ZeroToOCLQueue:
   case CK_NonAtomicToAtomic:
   case CK_AddressSpaceConversion:
     llvm_unreachable("invalid cast kind for integral value");
 
+  case CK_IntToOCLSampler: {
+    llvm::APSInt result;
+    if(!SubExpr->EvaluateAsInt(result, Info.Ctx)) {
+      return false;
+    }
+    return Success(result, E);
+  }
+
   case CK_BitCast:
   case CK_Dependent:
   case CK_LValueBitCast:
@@ -7982,9 +7995,11 @@ bool FloatExprEvaluator::VisitCallExpr(const CallExpr *E) {
   case Builtin::BI__builtin_huge_val:
   case Builtin::BI__builtin_huge_valf:
   case Builtin::BI__builtin_huge_vall:
+  case Builtin::BI__builtin_huge_valh:
   case Builtin::BI__builtin_inf:
   case Builtin::BI__builtin_inff:
-  case Builtin::BI__builtin_infl: {
+  case Builtin::BI__builtin_infl:
+  case Builtin::BI__builtin_infh: {
     const llvm::fltSemantics &Sem =
       Info.Ctx.getFloatTypeSemantics(E->getType());
     Result = llvm::APFloat::getInf(Sem);
@@ -7994,6 +8009,7 @@ bool FloatExprEvaluator::VisitCallExpr(const CallExpr *E) {
   case Builtin::BI__builtin_nans:
   case Builtin::BI__builtin_nansf:
   case Builtin::BI__builtin_nansl:
+  case Builtin::BI__builtin_nansh:
     if (!TryEvaluateBuiltinNaN(Info.Ctx, E->getType(), E->getArg(0),
                                true, Result))
       return Error(E);
@@ -8002,6 +8018,7 @@ bool FloatExprEvaluator::VisitCallExpr(const CallExpr *E) {
   case Builtin::BI__builtin_nan:
   case Builtin::BI__builtin_nanf:
   case Builtin::BI__builtin_nanl:
+  case Builtin::BI__builtin_nanh:
     // If this is __builtin_nan() turn this into a nan, otherwise we
     // can't constant fold it.
     if (!TryEvaluateBuiltinNaN(Info.Ctx, E->getType(), E->getArg(0),
@@ -8248,8 +8265,10 @@ bool ComplexExprEvaluator::VisitCastExpr(const CastExpr *E) {
   case CK_CopyAndAutoreleaseBlockObject:
   case CK_BuiltinFnToFnPtr:
   case CK_ZeroToOCLEvent:
+  case CK_ZeroToOCLQueue:
   case CK_NonAtomicToAtomic:
   case CK_AddressSpaceConversion:
+  case CK_IntToOCLSampler:
     llvm_unreachable("invalid cast kind for complex value");
 
   case CK_LValueToRValue:
@@ -8757,6 +8776,9 @@ static bool Evaluate(APValue &Result, EvalInfo &Info, const Expr *E) {
   } else if (T->isAtomicType()) {
     if (!EvaluateAtomic(E, Result, Info))
       return false;
+  } else if (T->isSamplerT()) {
+    if (!IntExprEvaluator(Info, Result).Visit(E))
+      return false;
   } else if (Info.getLangOpts().CPlusPlus11) {
     Info.Diag(E, diag::note_constexpr_nonliteral) << E->getType();
     return false;
diff --git a/lib/AST/ItaniumMangle.cpp b/lib/AST/ItaniumMangle.cpp
index 3f6b682..1ec4815 100644
--- a/lib/AST/ItaniumMangle.cpp
+++ b/lib/AST/ItaniumMangle.cpp
@@ -174,6 +174,9 @@ public:
 
   void mangleStringLiteral(const StringLiteral *, raw_ostream &) override;
 
+  void mangleMetalFieldName(const FieldDecl *D, const CXXRecordDecl* RD, raw_ostream &) override;
+  void mangleMetalGeneric(const std::string& name, QualType Ty, const CXXRecordDecl* RD, raw_ostream &) override;
+
   bool getNextDiscriminator(const NamedDecl *ND, unsigned &disc) {
     // Lambda closure types are already numbered.
     if (isLambda(ND))
@@ -306,6 +309,7 @@ public:
   void mangleName(const NamedDecl *ND);
   void mangleType(QualType T);
   void mangleNameOrStandardSubstitution(const NamedDecl *ND);
+  void mangleMetalFieldName(const FieldDecl *D, const CXXRecordDecl* RD);
   
 private:
 
@@ -1792,10 +1796,11 @@ void CXXNameMangler::mangleQualifiers(Qualifiers Quals) {
     } else {
       switch (AS) {
       default: llvm_unreachable("Not a language specific address space");
-      //  <OpenCL-addrspace> ::= "CL" [ "global" | "local" | "constant" ]
+      //  <OpenCL-addrspace> ::= "CL" [ "global" | "local" | "constant" | "generic" ]
       case LangAS::opencl_global:   ASString = "CLglobal";   break;
       case LangAS::opencl_local:    ASString = "CLlocal";    break;
       case LangAS::opencl_constant: ASString = "CLconstant"; break;
+      case LangAS::opencl_generic:  ASString = "CLgeneric";  break;
       //  <CUDA-addrspace> ::= "CU" [ "device" | "constant" | "shared" ]
       case LangAS::cuda_device:     ASString = "CUdevice";   break;
       case LangAS::cuda_constant:   ASString = "CUconstant"; break;
@@ -1868,7 +1873,7 @@ static bool isTypeSubstitutable(Qualifiers Quals, const Type *Ty) {
   if (Ty->isSpecificBuiltinType(BuiltinType::ObjCSel))
     return true;
   if (Ty->isOpenCLSpecificType())
-    return true;
+    return false;
   if (Ty->isBuiltinType())
     return false;
 
@@ -1916,7 +1921,9 @@ void CXXNameMangler::mangleType(QualType T) {
   Qualifiers quals = split.Quals;
   const Type *ty = split.Ty;
 
-  bool isSubstitutable = isTypeSubstitutable(quals, ty);
+  bool isSubstitutable =
+      isTypeSubstitutable(quals, ty) &&
+      !(Context.getASTContext().getLangOpts().OpenCL && isa<ExtVectorType>(T));
   if (isSubstitutable && mangleSubstitution(T))
     return;
 
@@ -1960,7 +1967,39 @@ void CXXNameMangler::mangleNameOrStandardSubstitution(const NamedDecl *ND) {
     mangleName(ND);
 }
 
+void CXXNameMangler::mangleMetalFieldName(const FieldDecl *D, const CXXRecordDecl* RD) {
+	const DeclContext *DC = IgnoreLinkageSpecDecls(getEffectiveDeclContext(D));
+	const DeclContext *PDC = IgnoreLinkageSpecDecls(getEffectiveDeclContext(RD));
+	
+	if(const auto II = D->getIdentifier()) {
+		// TODO: need actual parent field entry for all nested types
+		if(DC->getParent()->Equals(PDC)) {
+			mangleSourceName(II);
+		}
+	}
+	
+	// top level: mangle directly (without enclosing record decl / PDC)
+	// all else: mangle nested type as well
+	if(!DC->getParent()->Equals(PDC)) {
+		if (GetLocalClassDecl(D)) {
+			mangleLocalName(D);
+		}
+		else {
+			mangleNestedName(D, DC);
+		}
+	}
+	mangleType(D->getType());
+}
+
 void CXXNameMangler::mangleType(const BuiltinType *T) {
+  // helper function to discern between spir and applecl name mangling depending on the triple vendor
+  static const auto mangle_opencl_name = [](const ASTContext& ast_ctx, const char* spir_name, const char* applecl_name) {
+    if(ast_ctx.getTargetInfo().getTriple().getVendorName().str() == "applecl") {
+      return applecl_name;
+    }
+    return spir_name;
+  };
+
   //  <type>         ::= <builtin-type>
   //  <builtin-type> ::= v  # void
   //                 ::= w  # wchar_t
@@ -1990,6 +2029,7 @@ void CXXNameMangler::mangleType(const BuiltinType *T) {
   //                 ::= Ds # char16_t
   //                 ::= Dn # std::nullptr_t (i.e., decltype(nullptr))
   //                 ::= u <source-name>    # vendor extended type
+  //std::string type_name;
   switch (T->getKind()) {
   case BuiltinType::Void:
     Out << 'v';
@@ -2080,48 +2120,34 @@ void CXXNameMangler::mangleType(const BuiltinType *T) {
   case BuiltinType::ObjCSel:
     Out << "13objc_selector";
     break;
-  case BuiltinType::OCLImage1d:
-    Out << "11ocl_image1d";
-    break;
-  case BuiltinType::OCLImage1dArray:
-    Out << "16ocl_image1darray";
-    break;
-  case BuiltinType::OCLImage1dBuffer:
-    Out << "17ocl_image1dbuffer";
-    break;
-  case BuiltinType::OCLImage2d:
-    Out << "11ocl_image2d";
-    break;
-  case BuiltinType::OCLImage2dArray:
-    Out << "16ocl_image2darray";
-    break;
-  case BuiltinType::OCLImage2dDepth:
-    Out << "16ocl_image2ddepth";
-    break;
-  case BuiltinType::OCLImage2dArrayDepth:
-    Out << "21ocl_image2darraydepth";
-    break;
-  case BuiltinType::OCLImage2dMSAA:
-    Out << "15ocl_image2dmsaa";
-    break;
-  case BuiltinType::OCLImage2dArrayMSAA:
-    Out << "20ocl_image2darraymsaa";
-    break;
-  case BuiltinType::OCLImage2dMSAADepth:
-    Out << "20ocl_image2dmsaadepth";
-    break;
-  case BuiltinType::OCLImage2dArrayMSAADepth:
-    Out << "35ocl_image2darraymsaadepth";
-    break;
-  case BuiltinType::OCLImage3d:
-    Out << "11ocl_image3d";
-    break;
-  case BuiltinType::OCLSampler:
-    Out << "11ocl_sampler";
-    break;
-  case BuiltinType::OCLEvent:
-    Out << "9ocl_event";
-    break;
+#if 0 // TODO: this is not correct!
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id: \
+    type_name = "ocl_" #ImgType #Suffix; \
+    Out << type_name.size() << type_name; \
+    break;
+#include "clang/Basic/OpenCLImageTypes.def"
+#else
+  case BuiltinType::OCLImage1d: Out << mangle_opencl_name(getASTContext(), "11ocl_image1d", "PU3AS110_image1d_t"); break;
+  case BuiltinType::OCLImage1dArray: Out << mangle_opencl_name(getASTContext(), "16ocl_image1darray", "PU3AS116_image1d_array_t"); break;
+  case BuiltinType::OCLImage1dBuffer: Out << mangle_opencl_name(getASTContext(), "17ocl_image1dbuffer", "PU3AS117_image1d_buffer_t"); break;
+  case BuiltinType::OCLImage2d: Out << mangle_opencl_name(getASTContext(), "11ocl_image2d", "PU3AS110_image2d_t"); break;
+  case BuiltinType::OCLImage2dArray: Out << mangle_opencl_name(getASTContext(), "16ocl_image2darray", "PU3AS116_image2d_array_t"); break;
+  case BuiltinType::OCLImage2dDepth: Out << mangle_opencl_name(getASTContext(), "16ocl_image2ddepth", "PU3AS116_image2d_depth_t"); break;
+  case BuiltinType::OCLImage2dArrayDepth: Out << mangle_opencl_name(getASTContext(), "21ocl_image2darraydepth", "PU3AS122_image2d_array_depth_t"); break;
+  case BuiltinType::OCLImage2dMSAA: Out << mangle_opencl_name(getASTContext(), "15ocl_image2dmsaa", "PU3AS115_image2d_msaa_t"); break;
+  case BuiltinType::OCLImage2dArrayMSAA: Out << mangle_opencl_name(getASTContext(), "20ocl_image2darraymsaa", "PU3AS121_image2d_array_msaa_t"); break;
+  case BuiltinType::OCLImage2dMSAADepth: Out << mangle_opencl_name(getASTContext(), "20ocl_image2dmsaadepth", "PU3AS121_image2d_msaa_depth_t"); break;
+  case BuiltinType::OCLImage2dArrayMSAADepth: Out << mangle_opencl_name(getASTContext(), "25ocl_image2darraymsaadepth", "PU3AS127_image2d_array_msaa_depth_t"); break;
+  case BuiltinType::OCLImageCube: Out << mangle_opencl_name(getASTContext(), "13ocl_imagecube", "PU3AS112_imagecube_t"); break;
+  case BuiltinType::OCLImageCubeArray: Out << mangle_opencl_name(getASTContext(), "18ocl_imagecubearray", "PU3AS117_imagecubearray_t"); break;
+  case BuiltinType::OCLImageCubeDepth: Out << mangle_opencl_name(getASTContext(), "18ocl_imagecubedepth", "PU3AS117_imagecubedepth_t"); break;
+  case BuiltinType::OCLImageCubeArrayDepth: Out << mangle_opencl_name(getASTContext(), "23ocl_imagecubearraydepth", "PU3AS122_imagecubearraydepth_t"); break;
+  case BuiltinType::OCLImage3d: Out << mangle_opencl_name(getASTContext(), "11ocl_image3d", "PU3AS110_image3d_t"); break;
+#endif
+  case BuiltinType::OCLSampler: Out << mangle_opencl_name(getASTContext(), "11ocl_sampler", "uSampler"); break;
+  case BuiltinType::OCLEvent: Out << mangle_opencl_name(getASTContext(), "9ocl_event", "i"); break;
+  // NOTE: the following are not supported by AppleCL, just standard OpenCL 2.0+
   case BuiltinType::OCLClkEvent:
     Out << "12ocl_clkevent";
     break;
@@ -4246,6 +4272,26 @@ void ItaniumMangleContextImpl::mangleStringLiteral(const StringLiteral *, raw_os
   llvm_unreachable("Can't mangle string literals");
 }
 
+void ItaniumMangleContextImpl::mangleMetalFieldName(const FieldDecl *D, const CXXRecordDecl* RD, raw_ostream &Out) {
+	assert(isa<FieldDecl>(D) &&
+		   "Invalid mangleName() call, argument is not a field decl!");
+	
+	PrettyStackTraceDecl CrashInfo(D, SourceLocation(),
+								   getASTContext().getSourceManager(),
+								   "Mangling declaration");
+	
+	CXXNameMangler Mangler(*this, Out, D);
+	Mangler.mangleMetalFieldName(D, RD);
+}
+
+void ItaniumMangleContextImpl::mangleMetalGeneric(const std::string& name, QualType Ty,
+												  const CXXRecordDecl* RD, raw_ostream &Out) {
+	CXXNameMangler Mangler(*this, Out, nullptr);
+	Out << name.size();
+	Out << name;
+	Mangler.mangleType(Ty);
+}
+
 ItaniumMangleContext *
 ItaniumMangleContext::create(ASTContext &Context, DiagnosticsEngine &Diags) {
   return new ItaniumMangleContextImpl(Context, Diags);
diff --git a/lib/AST/MicrosoftMangle.cpp b/lib/AST/MicrosoftMangle.cpp
index 4a45f9e..0760399 100644
--- a/lib/AST/MicrosoftMangle.cpp
+++ b/lib/AST/MicrosoftMangle.cpp
@@ -1681,54 +1681,11 @@ void MicrosoftCXXNameMangler::mangleType(const BuiltinType *T, Qualifiers,
     mangleArtificalTagType(TTK_Struct, "objc_selector");
     break;
 
-  case BuiltinType::OCLImage1d:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image1d");
-    break;
-  case BuiltinType::OCLImage1dArray:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image1darray");
-    break;
-  case BuiltinType::OCLImage1dBuffer:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image1dbuffer");
-    break;
-  case BuiltinType::OCLImage2d:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image2d");
-    break;
-  case BuiltinType::OCLImage2dArray:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image2darray");
-    break;
-  case BuiltinType::OCLImage2dDepth:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image2ddepth");
-    break;
-  case BuiltinType::OCLImage2dArrayDepth:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image2darraydepth");
-    break;
-  case BuiltinType::OCLImage2dMSAA:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image2dmsaa");
-    break;
-  case BuiltinType::OCLImage2dArrayMSAA:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image2darraymsaa");
-    break;
-  case BuiltinType::OCLImage2dMSAADepth:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image2dmsaadepth");
-    break;
-  case BuiltinType::OCLImage2dArrayMSAADepth:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image2darraymsaadepth");
-    break;
-  case BuiltinType::OCLImage3d:
-    Out << "PA";
-    mangleArtificalTagType(TTK_Struct, "ocl_image3d");
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id: \
+    Out << "PAUocl_" #ImgType #Suffix "@@"; \
     break;
+#include "clang/Basic/OpenCLImageTypes.def"
   case BuiltinType::OCLSampler:
     Out << "PA";
     mangleArtificalTagType(TTK_Struct, "ocl_sampler");
diff --git a/lib/AST/NSAPI.cpp b/lib/AST/NSAPI.cpp
index c562dae..4c49e4c 100644
--- a/lib/AST/NSAPI.cpp
+++ b/lib/AST/NSAPI.cpp
@@ -445,18 +445,9 @@ NSAPI::getNSNumberFactoryMethodKind(QualType T) const {
   case BuiltinType::ObjCClass:
   case BuiltinType::ObjCId:
   case BuiltinType::ObjCSel:
-  case BuiltinType::OCLImage1d:
-  case BuiltinType::OCLImage1dArray:
-  case BuiltinType::OCLImage1dBuffer:
-  case BuiltinType::OCLImage2d:
-  case BuiltinType::OCLImage2dArray:
-  case BuiltinType::OCLImage2dDepth:
-  case BuiltinType::OCLImage2dArrayDepth:
-  case BuiltinType::OCLImage2dMSAA:
-  case BuiltinType::OCLImage2dArrayMSAA:
-  case BuiltinType::OCLImage2dMSAADepth:
-  case BuiltinType::OCLImage2dArrayMSAADepth:
-  case BuiltinType::OCLImage3d:
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
   case BuiltinType::OCLSampler:
   case BuiltinType::OCLEvent:
   case BuiltinType::OCLClkEvent:
diff --git a/lib/AST/Type.cpp b/lib/AST/Type.cpp
index b467dac..469743f 100644
--- a/lib/AST/Type.cpp
+++ b/lib/AST/Type.cpp
@@ -1783,6 +1783,13 @@ bool Type::isFloatingType() const {
   return false;
 }
 
+bool Type::isDoubleType() const {
+  if (const BuiltinType *BT = dyn_cast<BuiltinType>(CanonicalType))
+    return BT->getKind() >= BuiltinType::Double &&
+           BT->getKind() <= BuiltinType::LongDouble;
+  return false;
+}
+
 bool Type::hasFloatingRepresentation() const {
   if (const VectorType *VT = dyn_cast<VectorType>(CanonicalType))
     return VT->getElementType()->isFloatingType();
@@ -1805,6 +1812,30 @@ bool Type::isRealType() const {
   return false;
 }
 
+bool Type::isFloatingVecType() const {
+  if (const VectorType *VT = dyn_cast<VectorType>(CanonicalType))
+    return VT->getElementType()->isFloatingType();
+  return false;
+}
+
+bool Type::isDoubleVecType() const {
+  if (const VectorType *VT = dyn_cast<VectorType>(CanonicalType))
+    return VT->getElementType()->isDoubleType();
+  return false;
+}
+
+bool Type::isIntegerVecType() const {
+  if (const VectorType *VT = dyn_cast<VectorType>(CanonicalType))
+    return VT->getElementType()->isIntegerType();
+  return false;
+}
+
+bool Type::isRealVecType() const {
+  if (const VectorType *VT = dyn_cast<VectorType>(CanonicalType))
+    return VT->getElementType()->isRealType();
+  return false;
+}
+
 bool Type::isArithmeticType() const {
   if (const BuiltinType *BT = dyn_cast<BuiltinType>(CanonicalType))
     return BT->getKind() >= BuiltinType::Bool &&
@@ -2150,6 +2181,9 @@ bool Type::isLiteralType(const ASTContext &Ctx) const {
   if (isDependentType())
     return false;
 
+  if (Ctx.getLangOpts().OpenCL && isSamplerT())
+    return true;
+
   // C++1y [basic.types]p10:
   //   A type is a literal type if it is:
   //   -- cv void; or
@@ -2581,30 +2615,17 @@ StringRef BuiltinType::getName(const PrintingPolicy &Policy) const {
     return "Class";
   case ObjCSel:
     return "SEL";
-  case OCLImage1d:
-    return "image1d_t";
-  case OCLImage1dArray:
-    return "image1d_array_t";
-  case OCLImage1dBuffer:
-    return "image1d_buffer_t";
-  case OCLImage2d:
-    return "image2d_t";
-  case OCLImage2dArray:
-    return "image2d_array_t";
-  case OCLImage2dDepth:
-    return "image2d_depth_t";
-  case OCLImage2dArrayDepth:
-    return "image2d_array_depth_t";
-  case OCLImage2dMSAA:
-    return "image2d_msaa_t";
-  case OCLImage2dArrayMSAA:
-    return "image2d_array_msaa_t";
-  case OCLImage2dMSAADepth:
-    return "image2d_msaa_depth_t";
-  case OCLImage2dArrayMSAADepth:
-    return "image2d_array_msaa_depth_t";
-  case OCLImage3d:
-    return "image3d_t";
+#if 0 // TODO: enable this again when using ro/wo/rw image types
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case Id: \
+    return "__" #Access " " #ImgType "_t";
+#include "clang/Basic/OpenCLImageTypes.def"
+#else
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case Id: \
+    return #ImgType "_t";
+#include "clang/Basic/OpenCLImageTypes.def"
+#endif
   case OCLSampler:
     return "sampler_t";
   case OCLEvent:
@@ -3561,18 +3582,9 @@ bool Type::canHaveNullability() const {
     case BuiltinType::ObjCId:
     case BuiltinType::ObjCClass:
     case BuiltinType::ObjCSel:
-    case BuiltinType::OCLImage1d:
-    case BuiltinType::OCLImage1dArray:
-    case BuiltinType::OCLImage1dBuffer:
-    case BuiltinType::OCLImage2d:
-    case BuiltinType::OCLImage2dArray:
-    case BuiltinType::OCLImage2dDepth:
-    case BuiltinType::OCLImage2dArrayDepth:
-    case BuiltinType::OCLImage2dMSAA:
-    case BuiltinType::OCLImage2dArrayMSAA:
-    case BuiltinType::OCLImage2dMSAADepth:
-    case BuiltinType::OCLImage2dArrayMSAADepth:
-    case BuiltinType::OCLImage3d:
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
     case BuiltinType::OCLSampler:
     case BuiltinType::OCLEvent:
     case BuiltinType::OCLClkEvent:
@@ -3787,3 +3799,43 @@ QualType::DestructionKind QualType::isDestructedTypeImpl(QualType type) {
 CXXRecordDecl *MemberPointerType::getMostRecentCXXRecordDecl() const {
   return getClass()->getAsCXXRecordDecl()->getMostRecentDecl();
 }
+
+static std::pair<bool, bool> isAggregateImageTypeRecurse(const CXXRecordDecl* decl) {
+	if(decl == nullptr) return { false, false };
+	
+	// union is not allowed
+	if(decl->isUnion()) return { false, false };
+	
+	// must have definition
+	if(!decl->hasDefinition()) return { false, false };
+	
+	// iterate over all fields/members and check if all are image types
+	bool has_any_image = false;
+	for(const auto& field : decl->fields()) {
+		if(!field->getType()->isImageType()) {
+			return { false, false };
+		}
+		has_any_image = true;
+	}
+	
+	// iterate over / recurse into all bases, check if they only consist of image types
+	for(const auto& base : decl->bases()) {
+		const auto base_ret = isAggregateImageTypeRecurse(base.getType()->getAsCXXRecordDecl());
+		if(!base_ret.first) {
+			return { false, false };
+		}
+		has_any_image |= base_ret.second;
+	}
+	
+	// all passed
+	return { true, has_any_image };
+}
+
+bool Type::isAggregateImageType() const {
+  // must be struct or class, union is not allowed
+  if(!isStructureOrClassType()) return false;
+
+  // check class/struct itself + all inherited base classes/structs
+  const auto valid_and_has_image = isAggregateImageTypeRecurse(getAsCXXRecordDecl());
+  return valid_and_has_image.first && valid_and_has_image.second;
+}
diff --git a/lib/AST/TypeLoc.cpp b/lib/AST/TypeLoc.cpp
index d08b07b..0fcad5a 100644
--- a/lib/AST/TypeLoc.cpp
+++ b/lib/AST/TypeLoc.cpp
@@ -333,18 +333,9 @@ TypeSpecifierType BuiltinTypeLoc::getWrittenTypeSpec() const {
   case BuiltinType::ObjCId:
   case BuiltinType::ObjCClass:
   case BuiltinType::ObjCSel:
-  case BuiltinType::OCLImage1d:
-  case BuiltinType::OCLImage1dArray:
-  case BuiltinType::OCLImage1dBuffer:
-  case BuiltinType::OCLImage2d:
-  case BuiltinType::OCLImage2dArray:
-  case BuiltinType::OCLImage2dDepth:
-  case BuiltinType::OCLImage2dArrayDepth:
-  case BuiltinType::OCLImage2dMSAA:
-  case BuiltinType::OCLImage2dArrayMSAA:
-  case BuiltinType::OCLImage2dMSAADepth:
-  case BuiltinType::OCLImage2dArrayMSAADepth:
-  case BuiltinType::OCLImage3d:
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
   case BuiltinType::OCLSampler:
   case BuiltinType::OCLEvent:
   case BuiltinType::OCLClkEvent:
diff --git a/lib/AST/TypePrinter.cpp b/lib/AST/TypePrinter.cpp
index b202523..60c6389 100644
--- a/lib/AST/TypePrinter.cpp
+++ b/lib/AST/TypePrinter.cpp
@@ -700,8 +700,10 @@ void TypePrinter::printFunctionProtoAfter(const FunctionProtoType *T,
       OS << " __attribute__((sysv_abi))";
       break;
     case CC_SpirFunction:
+      OS << "spir_function";
+      break;
     case CC_SpirKernel:
-      // Do nothing. These CCs are not available as attributes.
+      OS << "spir_kernel";
       break;
     }
   }
diff --git a/lib/Analysis/PrintfFormatString.cpp b/lib/Analysis/PrintfFormatString.cpp
index f0976bc..4235ce2 100644
--- a/lib/Analysis/PrintfFormatString.cpp
+++ b/lib/Analysis/PrintfFormatString.cpp
@@ -614,6 +614,9 @@ bool PrintfSpecifier::fixType(QualType QT, const LangOptions &LangOpt,
     // Various types which are non-trivial to correct.
     return false;
 
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
 #define SIGNED_TYPE(Id, SingletonId)
 #define UNSIGNED_TYPE(Id, SingletonId)
 #define FLOATING_TYPE(Id, SingletonId)
diff --git a/lib/Basic/Targets.cpp b/lib/Basic/Targets.cpp
index af8aea0..a6c6949 100644
--- a/lib/Basic/Targets.cpp
+++ b/lib/Basic/Targets.cpp
@@ -1615,8 +1615,16 @@ class NVPTXTargetInfo : public TargetInfo {
     GK_SM20,
     GK_SM21,
     GK_SM30,
+    GK_SM32,
     GK_SM35,
     GK_SM37,
+    GK_SM50,
+    GK_SM52,
+    GK_SM53,
+    GK_SM60,
+    GK_SM61,
+    GK_SM62,
+    GK_SM70,
   } GPU;
 
 public:
@@ -1629,6 +1637,7 @@ public:
     // Define available target features
     // These must be defined in sorted order!
     NoAsmVariants = true;
+    this->UserLabelPrefix = "";
     // Set the default GPU to sm20
     GPU = GK_SM20;
   }
@@ -1649,12 +1658,36 @@ public:
       case GK_SM30:
         CUDAArchCode = "300";
         break;
+      case GK_SM32:
+        CUDAArchCode = "320";
+        break;
       case GK_SM35:
         CUDAArchCode = "350";
         break;
       case GK_SM37:
         CUDAArchCode = "370";
         break;
+      case GK_SM50:
+        CUDAArchCode = "500";
+        break;
+      case GK_SM52:
+        CUDAArchCode = "520";
+        break;
+      case GK_SM53:
+        CUDAArchCode = "530";
+        break;
+      case GK_SM60:
+        CUDAArchCode = "600";
+        break;
+      case GK_SM61:
+        CUDAArchCode = "610";
+        break;
+      case GK_SM62:
+        CUDAArchCode = "620";
+        break;
+      case GK_SM70:
+        CUDAArchCode = "700";
+        break;
       default:
         llvm_unreachable("Unhandled target CPU");
       }
@@ -1685,6 +1718,7 @@ public:
     case 'l':
     case 'f':
     case 'd':
+    case 'b':
       Info.setAllowsRegister();
       return true;
     }
@@ -1702,8 +1736,16 @@ public:
               .Case("sm_20", GK_SM20)
               .Case("sm_21", GK_SM21)
               .Case("sm_30", GK_SM30)
+              .Case("sm_32", GK_SM32)
               .Case("sm_35", GK_SM35)
               .Case("sm_37", GK_SM37)
+              .Case("sm_50", GK_SM50)
+              .Case("sm_52", GK_SM52)
+              .Case("sm_53", GK_SM53)
+              .Case("sm_60", GK_SM60)
+              .Case("sm_61", GK_SM61)
+              .Case("sm_62", GK_SM62)
+              .Case("sm_70", GK_SM70)
               .Default(GK_NONE);
 
     return GPU != GK_NONE;
@@ -7349,12 +7391,11 @@ static const unsigned SPIRAddrSpaceMap[] = {
     0  // cuda_shared
 };
 class SPIRTargetInfo : public TargetInfo {
+private:
+  // true for spir-unknown-* and spir64-unknown-* (-> false for AppleCL and AIR/Metal)
+  const bool is_pure_spir;
 public:
-  SPIRTargetInfo(const llvm::Triple &Triple) : TargetInfo(Triple) {
-    assert(getTriple().getOS() == llvm::Triple::UnknownOS &&
-           "SPIR target must use unknown OS");
-    assert(getTriple().getEnvironment() == llvm::Triple::UnknownEnvironment &&
-           "SPIR target must use unknown environment type");
+  SPIRTargetInfo(const llvm::Triple &Triple) : TargetInfo(Triple), is_pure_spir(Triple.getVendorName().str() == "unknown") {
     BigEndian = false;
     TLSSupported = false;
     LongWidth = LongAlign = 64;
@@ -7363,6 +7404,7 @@ public:
     // Define available target features
     // These must be defined in sorted order!
     NoAsmVariants = true;
+    this->UserLabelPrefix = "";
   }
   void getTargetDefines(const LangOptions &Opts,
                         MacroBuilder &Builder) const override {
@@ -7372,6 +7414,8 @@ public:
     return Feature == "spir";
   }
 
+  bool isCLZForZeroUndef() const override { return false; }
+
   ArrayRef<Builtin::Info> getTargetBuiltins() const override { return None; }
   const char *getClobbers() const override { return ""; }
   ArrayRef<const char *> getGCCRegNames() const override { return None; }
@@ -7387,12 +7431,13 @@ public:
   }
 
   CallingConvCheckResult checkCallingConvention(CallingConv CC) const override {
+    if (!is_pure_spir) return CCCR_OK;
     return (CC == CC_SpirFunction || CC == CC_SpirKernel) ? CCCR_OK
                                                           : CCCR_Warning;
   }
 
   CallingConv getDefaultCallingConv(CallingConvMethodType MT) const override {
-    return CC_SpirFunction;
+    return (is_pure_spir ? CC_SpirFunction : CC_C);
   }
 };
 
@@ -7403,7 +7448,8 @@ public:
     SizeType = TargetInfo::UnsignedInt;
     PtrDiffType = IntPtrType = TargetInfo::SignedInt;
     DataLayoutString = "e-p:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-"
-                       "v96:128-v192:256-v256:256-v512:512-v1024:1024";
+                       "v96:128-v192:256-v256:256-v512:512-v1024:1024"
+                       "-n8:16:32:64";
   }
   void getTargetDefines(const LangOptions &Opts,
                         MacroBuilder &Builder) const override {
@@ -7418,7 +7464,8 @@ public:
     SizeType = TargetInfo::UnsignedLong;
     PtrDiffType = IntPtrType = TargetInfo::SignedLong;
     DataLayoutString = "e-i64:64-v16:16-v24:32-v32:32-v48:64-"
-                       "v96:128-v192:256-v256:256-v512:512-v1024:1024";
+                       "v96:128-v192:256-v256:256-v512:512-v1024:1024"
+                       "-n8:16:32:64";
   }
   void getTargetDefines(const LangOptions &Opts,
                         MacroBuilder &Builder) const override {
@@ -7426,6 +7473,26 @@ public:
   }
 };
 
+class AIR64TargetInfo : public SPIRTargetInfo {
+public:
+  AIR64TargetInfo(const llvm::Triple &Triple) : SPIRTargetInfo(Triple) {
+    PointerWidth = PointerAlign = 64;
+    SizeType     = TargetInfo::UnsignedLong;
+    PtrDiffType = IntPtrType = TargetInfo::SignedLong;
+    if(Triple.getOS() == llvm::Triple::IOS) {
+      DataLayoutString = "e-i64:64-f80:128-v16:16-v24:32-v32:32-v48:64-"
+                          "v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32";
+    }
+    else { // os x, or default
+      DataLayoutString = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-f80:128:128-v16:16:16-v24:32:32-v32:32:32-v48:64:64-v64:64:64-v96:128:128-v128:128:128-v192:256:256-v256:256:256-v512:512:512-v1024:1024:1024-f80:128:128-n8:16:32";
+    }
+  }
+  void getTargetDefines(const LangOptions &Opts,
+                        MacroBuilder &Builder) const override {
+    DefineStd(Builder, "AIR64", Opts);
+  }
+};
+
 class XCoreTargetInfo : public TargetInfo {
   static const Builtin::Info BuiltinInfo[];
 public:
@@ -7911,18 +7978,12 @@ static TargetInfo *AllocateTarget(const llvm::Triple &Triple) {
       return new X86_64TargetInfo(Triple);
     }
 
-  case llvm::Triple::spir: {
-    if (Triple.getOS() != llvm::Triple::UnknownOS ||
-        Triple.getEnvironment() != llvm::Triple::UnknownEnvironment)
-      return nullptr;
+  case llvm::Triple::spir:
     return new SPIR32TargetInfo(Triple);
-  }
-  case llvm::Triple::spir64: {
-    if (Triple.getOS() != llvm::Triple::UnknownOS ||
-        Triple.getEnvironment() != llvm::Triple::UnknownEnvironment)
-      return nullptr;
+  case llvm::Triple::spir64:
     return new SPIR64TargetInfo(Triple);
-  }
+  case llvm::Triple::air64:
+    return new AIR64TargetInfo(Triple);
   case llvm::Triple::wasm32:
     if (!(Triple == llvm::Triple("wasm32-unknown-unknown")))
       return nullptr;
diff --git a/lib/CodeGen/BackendUtil.cpp b/lib/CodeGen/BackendUtil.cpp
index 6d746c2..3614f90 100644
--- a/lib/CodeGen/BackendUtil.cpp
+++ b/lib/CodeGen/BackendUtil.cpp
@@ -31,6 +31,7 @@
 #include "llvm/Object/FunctionIndexObjectFile.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/PrettyStackTrace.h"
+#include "llvm/Support/SPIRV.h"
 #include "llvm/Support/TargetRegistry.h"
 #include "llvm/Support/Timer.h"
 #include "llvm/Support/raw_ostream.h"
@@ -44,6 +45,7 @@
 #include "llvm/Transforms/Scalar.h"
 #include "llvm/Transforms/Utils/SymbolRewriter.h"
 #include <memory>
+#include <fstream>
 using namespace clang;
 using namespace llvm;
 
@@ -301,8 +303,13 @@ void EmitAssemblyHelper::CreatePasses(FunctionInfoIndex *FunctionIndex) {
   case CodeGenOptions::NoInlining:
     break;
   case CodeGenOptions::NormalInlining: {
-    PMBuilder.Inliner =
-        createFunctionInliningPass(OptLevel, CodeGenOpts.OptimizeSize);
+    // always inline everything for metal/cuda/opencl, otherwise we run into trouble when fixing the IR
+    if (LangOpts.Metal || LangOpts.CUDA || LangOpts.OpenCL) {
+      PMBuilder.Inliner = createEverythingInlinerPass();
+    }
+    else {
+      PMBuilder.Inliner = createFunctionInliningPass(OptLevel, CodeGenOpts.OptimizeSize);
+    }
     break;
   }
   case CodeGenOptions::OnlyAlwaysInlining:
@@ -337,6 +344,36 @@ void EmitAssemblyHelper::CreatePasses(FunctionInfoIndex *FunctionIndex) {
     return;
   }
 
+  // close floor function info file, this is no longer needed
+  if ((LangOpts.Metal || LangOpts.CUDA || LangOpts.OpenCL) &&
+      LangOpts.floor_function_info != nullptr) {
+    LangOpts.floor_function_info->close();
+    delete LangOpts.floor_function_info;
+  }
+
+  PMBuilder.floor_image_capabilities = LangOpts.floor_image_capabilities;
+
+  PMBuilder.EnableAddressSpaceFix = LangOpts.OpenCL;
+  if(PMBuilder.EnableAddressSpaceFix && OptLevel == 0) {
+    unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error, "compiling OpenCL or Metal with"
+											" -O0 is not possible!");
+    Diags.Report(DiagID);
+    return;
+  }
+
+  // only enable this for CUDA
+  PMBuilder.EnableCUDAPasses = LangOpts.CUDA;
+
+  // only enable this for Metal/AIR
+  PMBuilder.EnableMetalPasses = LangOpts.Metal;
+  PMBuilder.EnableMetalIntelWorkarounds = CodeGenOpts.MetalIntelWorkarounds;
+
+  // only enable this for OpenCL/SPIR (don't want this for AppleCL or Metal)
+  PMBuilder.EnableSPIRPasses = (LangOpts.OpenCL &&
+                                (Triple(TheModule->getTargetTriple()).getArch() == Triple::spir64) &&
+                                (Triple(TheModule->getTargetTriple()).getVendorName().str() == "unknown"));
+  PMBuilder.EnableVerifySPIR = PMBuilder.EnableSPIRPasses && LangOpts.CLVerifySPIR;
+
   PMBuilder.addExtension(PassManagerBuilder::EP_EarlyAsPossible,
                          addAddDiscriminatorsPass);
 
@@ -411,6 +448,10 @@ void EmitAssemblyHelper::CreatePasses(FunctionInfoIndex *FunctionIndex) {
   if (!CodeGenOpts.RewriteMapFiles.empty())
     addSymbolRewriterPass(CodeGenOpts, MPM);
 
+  if (LangOpts.OpenCL || LangOpts.CUDA) {
+    MPM->add(createInternalizePass());
+  }
+
   if (!CodeGenOpts.DisableGCov &&
       (CodeGenOpts.EmitGcovArcs || CodeGenOpts.EmitGcovNotes)) {
     // Not using 'GCOVOptions::getDefault' allows us to avoid exiting if
@@ -632,6 +673,9 @@ void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
 
   bool UsesCodeGen = (Action != Backend_EmitNothing &&
                       Action != Backend_EmitBC &&
+                      Action != Backend_EmitBC32 &&
+                      Action != Backend_EmitBC35 &&
+                      Action != Backend_EmitSPIRV &&
                       Action != Backend_EmitLL);
   if (!TM)
     TM.reset(CreateTargetMachine(UsesCodeGen));
@@ -672,6 +716,18 @@ void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
         *OS, CodeGenOpts.EmitLLVMUseLists, CodeGenOpts.EmitFunctionSummary));
     break;
 
+  case Backend_EmitBC32:
+    getPerModulePasses()->add(createBitcode32WriterPass(*OS));
+    break;
+
+  case Backend_EmitBC35:
+    getPerModulePasses()->add(createBitcode35WriterPass(*OS));
+    break;
+
+  case Backend_EmitSPIRV:
+    getPerModulePasses()->add(createSPIRVWriterPass(*OS));
+    break;
+
   case Backend_EmitLL:
     getPerModulePasses()->add(
         createPrintModulePass(*OS, "", CodeGenOpts.EmitLLVMUseLists));
diff --git a/lib/CodeGen/CGBlocks.cpp b/lib/CodeGen/CGBlocks.cpp
index ba2941e..3de24fe 100644
--- a/lib/CodeGen/CGBlocks.cpp
+++ b/lib/CodeGen/CGBlocks.cpp
@@ -14,6 +14,7 @@
 #include "CGBlocks.h"
 #include "CGDebugInfo.h"
 #include "CGObjCRuntime.h"
+#include "CGOpenCLRuntime.h"
 #include "CodeGenFunction.h"
 #include "CodeGenModule.h"
 #include "clang/AST/DeclObjC.h"
@@ -110,8 +111,15 @@ static llvm::Constant *buildBlockDescriptor(CodeGenModule &CGM,
   // Signature.  Mandatory ObjC-style method descriptor @encode sequence.
   std::string typeAtEncoding =
     CGM.getContext().getObjCEncodingForBlock(blockInfo.getBlockExpr());
-  elements.push_back(llvm::ConstantExpr::getBitCast(
-    CGM.GetAddrOfConstantCString(typeAtEncoding).getPointer(), i8p));
+
+  if (C.getLangOpts().OpenCL) {
+    elements.push_back(llvm::ConstantExpr::getAddrSpaceCast(
+                            CGM.GetAddrOfConstantCString(typeAtEncoding).getPointer(), i8p));
+  }
+  else {
+    elements.push_back(llvm::ConstantExpr::getBitCast(
+                            CGM.GetAddrOfConstantCString(typeAtEncoding).getPointer(), i8p));
+  }
   
   // GC layout.
   if (C.getLangOpts().ObjC1) {
@@ -319,7 +327,10 @@ static void computeBlockInfo(CodeGenModule &CGM, CodeGenFunction *CGF,
   const BlockDecl *block = info.getBlockDecl();
 
   SmallVector<llvm::Type*, 8> elementTypes;
-  initializeForBlockHeader(CGM, info, elementTypes);
+
+  // OpenCL doesn't use block header (Guy)
+  if (!CGM.getLangOpts().OpenCL)
+    initializeForBlockHeader(CGM, info, elementTypes);
 
   if (!block->hasCaptures()) {
     info.StructureType =
@@ -507,7 +518,9 @@ static void computeBlockInfo(CodeGenModule &CGM, CodeGenFunction *CGF,
   
   // At this point, we just have to add padding if the end align still
   // isn't aligned right.
-  if (endAlign < maxFieldAlign) {
+  if (CGM.getLangOpts().OpenCL && blockSize.getQuantity() == 0)
+    endAlign = maxFieldAlign;
+  else if (endAlign < maxFieldAlign) {
     CharUnits newBlockSize = blockSize.RoundUpToAlignment(maxFieldAlign);
     CharUnits padding = newBlockSize - blockSize;
 
@@ -524,7 +537,7 @@ static void computeBlockInfo(CodeGenModule &CGM, CodeGenFunction *CGF,
   }
 
   assert(endAlign >= maxFieldAlign);
-  assert(endAlign == getLowBit(blockSize));
+  assert((CGM.getLangOpts().OpenCL && blockSize.isZero()) || (endAlign == getLowBit(blockSize)));
   // Slam everything else on now.  This works because they have
   // strictly decreasing alignment and we expect that size is always a
   // multiple of alignment.
@@ -574,6 +587,11 @@ static void enterBlockScope(CodeGenFunction &CGF, BlockDecl *block) {
   blockInfo.LocalAddress = CGF.CreateTempAlloca(blockInfo.StructureType,
                                                 blockInfo.BlockAlign, "block");
 
+  if (CGF.getLangOpts().OpenCL) {
+    blockInfo.LocalAddress.getPointer()->setName("captured");
+    return;
+  }
+
   // If there are cleanups to emit, enter them (but inactive).
   if (!blockInfo.NeedsCopyDispose) return;
 
@@ -685,6 +703,24 @@ llvm::Value *CodeGenFunction::EmitBlockLiteral(const BlockExpr *blockExpr) {
   return EmitBlockLiteral(*blockInfo);
 }
 
+llvm::Value *CodeGenFunction::GenerateOCLBlockBind(llvm::Constant *blockFunc,
+                                                   int ctxSize,
+                                                   int ctxAlign,
+                                                   llvm::Value *ctx) {
+    llvm::Type *ArgTys[] = {VoidPtrTy, IntTy, IntTy, VoidPtrTy};
+    llvm::FunctionType *FTy = llvm::FunctionType::get(
+                                            CGM.getOpenCLRuntime().getBlockType(),
+                                            llvm::ArrayRef<llvm::Type*>(ArgTys),
+                                            false);
+    return Builder.CreateCall(CGM.CreateRuntimeFunction(FTy, "spir_block_bind"),
+                              {
+                                blockFunc,
+                                Builder.getInt32(ctxSize),
+                                Builder.getInt32(ctxAlign),
+                                ctx
+                              });
+}
+
 llvm::Value *CodeGenFunction::EmitBlockLiteral(const CGBlockInfo &blockInfo) {
   // Using the computed layout, generate the actual block function.
   bool isLambdaConv = blockInfo.getBlockDecl()->isConversionFromLambda();
@@ -694,27 +730,7 @@ llvm::Value *CodeGenFunction::EmitBlockLiteral(const CGBlockInfo &blockInfo) {
                                                        isLambdaConv);
   blockFn = llvm::ConstantExpr::getBitCast(blockFn, VoidPtrTy);
 
-  // If there is nothing to capture, we can emit this as a global block.
-  if (blockInfo.CanBeGlobal)
-    return buildGlobalBlock(CGM, blockInfo, blockFn);
-
-  // Otherwise, we have to emit this as a local block.
-
-  llvm::Constant *isa = CGM.getNSConcreteStackBlock();
-  isa = llvm::ConstantExpr::getBitCast(isa, VoidPtrTy);
-
-  // Build the block descriptor.
-  llvm::Constant *descriptor = buildBlockDescriptor(CGM, blockInfo);
-
   Address blockAddr = blockInfo.LocalAddress;
-  assert(blockAddr.isValid() && "block has no address!");
-
-  // Compute the initial on-stack block flags.
-  BlockFlags flags = BLOCK_HAS_SIGNATURE;
-  if (blockInfo.HasCapturedVariableLayout) flags |= BLOCK_HAS_EXTENDED_LAYOUT;
-  if (blockInfo.NeedsCopyDispose) flags |= BLOCK_HAS_COPY_DISPOSE;
-  if (blockInfo.HasCXXObject) flags |= BLOCK_HAS_CXX_OBJ;
-  if (blockInfo.UsesStret) flags |= BLOCK_USE_STRET;
 
   auto projectField =
     [&](unsigned index, CharUnits offset, const Twine &name) -> Address {
@@ -726,25 +742,53 @@ llvm::Value *CodeGenFunction::EmitBlockLiteral(const CGBlockInfo &blockInfo) {
       Builder.CreateStore(value, projectField(index, offset, name));
     };
 
-  // Initialize the block header.
-  {
-    // We assume all the header fields are densely packed.
-    unsigned index = 0;
-    CharUnits offset;
-    auto addHeaderField =
-      [&](llvm::Value *value, CharUnits size, const Twine &name) {
-        storeField(value, index, offset, name);
-        offset += size;
-        index++;
-      };
-
-    addHeaderField(isa, getPointerSize(), "block.isa");
-    addHeaderField(llvm::ConstantInt::get(IntTy, flags.getBitMask()),
-                   getIntSize(), "block.flags");
-    addHeaderField(llvm::ConstantInt::get(IntTy, 0),
-                   getIntSize(), "block.reserved");
-    addHeaderField(blockFn, getPointerSize(), "block.invoke");
-    addHeaderField(descriptor, getPointerSize(), "block.descriptor");
+  if (CGM.getLangOpts().OpenCL) {
+    if (blockInfo.CanBeGlobal)
+      return GenerateOCLBlockBind(blockFn, blockInfo.BlockSize.getQuantity(),
+                                  blockInfo.BlockAlign.getQuantity(),
+                                  llvm::Constant::getNullValue(VoidPtrTy));
+  } else {
+    // If there is nothing to capture, we can emit this as a global block.
+    if (blockInfo.CanBeGlobal)
+      return buildGlobalBlock(CGM, blockInfo, blockFn);
+
+    // Otherwise, we have to emit this as a local block.
+
+    llvm::Constant *isa = CGM.getNSConcreteStackBlock();
+    isa = llvm::ConstantExpr::getBitCast(isa, VoidPtrTy);
+
+    // Build the block descriptor.
+    llvm::Constant *descriptor = buildBlockDescriptor(CGM, blockInfo);
+    blockAddr = blockInfo.LocalAddress;
+    assert(blockAddr.isValid() && "block has no address!");
+
+    // Compute the initial on-stack block flags.
+    BlockFlags flags = BLOCK_HAS_SIGNATURE;
+    if (blockInfo.HasCapturedVariableLayout) flags |= BLOCK_HAS_EXTENDED_LAYOUT;
+    if (blockInfo.NeedsCopyDispose) flags |= BLOCK_HAS_COPY_DISPOSE;
+    if (blockInfo.HasCXXObject) flags |= BLOCK_HAS_CXX_OBJ;
+    if (blockInfo.UsesStret) flags |= BLOCK_USE_STRET;
+
+    // Initialize the block header.
+    {
+      // We assume all the header fields are densely packed.
+      unsigned index = 0;
+      CharUnits offset;
+      auto addHeaderField =
+        [&](llvm::Value *value, CharUnits size, const Twine &name) {
+          storeField(value, index, offset, name);
+          offset += size;
+          index++;
+        };
+
+      addHeaderField(isa, getPointerSize(), "block.isa");
+      addHeaderField(llvm::ConstantInt::get(IntTy, flags.getBitMask()),
+                     getIntSize(), "block.flags");
+      addHeaderField(llvm::ConstantInt::get(IntTy, 0),
+                     getIntSize(), "block.reserved");
+      addHeaderField(blockFn, getPointerSize(), "block.invoke");
+      addHeaderField(descriptor, getPointerSize(), "block.descriptor");
+    }
   }
 
   // Finally, capture all the values into the block.
@@ -891,8 +935,13 @@ llvm::Value *CodeGenFunction::EmitBlockLiteral(const CGBlockInfo &blockInfo) {
   // Cast to the converted block-pointer type, which happens (somewhat
   // unfortunately) to be a pointer to function type.
   llvm::Value *result =
-    Builder.CreateBitCast(blockAddr.getPointer(),
-                          ConvertType(blockInfo.getBlockExpr()->getType()));
+      (CGM.getLangOpts().OpenCL)
+          ? GenerateOCLBlockBind(
+                blockFn, blockInfo.BlockSize.getQuantity(),
+                blockInfo.BlockAlign.getQuantity(),
+                Builder.CreateBitCast(blockInfo.LocalAddress.getPointer(), VoidPtrTy))
+          : Builder.CreateBitCast(
+                blockAddr.getPointer(), ConvertType(blockInfo.getBlockExpr()->getType()));
 
   return result;
 }
@@ -956,19 +1005,33 @@ RValue CodeGenFunction::EmitBlockCallExpr(const CallExpr *E,
 
   llvm::Value *Callee = EmitScalarExpr(E->getCallee());
 
-  // Get a pointer to the generic block literal.
-  llvm::Type *BlockLiteralTy =
-    llvm::PointerType::getUnqual(CGM.getGenericBlockLiteralType());
+  llvm::Value *Func;
+  llvm::Value *BlockLiteral;
+  llvm::Value *FuncPtr = nullptr;
+
+  if (CGM.getLangOpts().OpenCL) {
+    llvm::Type *ArgTy[] = {CGM.getOpenCLRuntime().getBlockType()};
+    llvm::FunctionType *FTy = llvm::FunctionType::get(
+                                            VoidPtrTy,
+                                            llvm::ArrayRef<llvm::Type*>(ArgTy),
+                                            false);
+    Func = Builder.CreateCall(CGM.CreateRuntimeFunction(FTy, "spir_get_block_invoke"), Callee);
+    BlockLiteral = Builder.CreateCall(CGM.CreateRuntimeFunction(FTy, "spir_get_block_context"), Callee);
+  } else {
+    // Get a pointer to the generic block literal.
+    llvm::Type *BlockLiteralTy =
+      llvm::PointerType::getUnqual(CGM.getGenericBlockLiteralType());
 
-  // Bitcast the callee to a block literal.
-  llvm::Value *BlockLiteral =
-    Builder.CreateBitCast(Callee, BlockLiteralTy, "block.literal");
+    // Bitcast the callee to a block literal.
+    BlockLiteral =
+      Builder.CreateBitCast(Callee, BlockLiteralTy, "block.literal");
 
-  // Get the function pointer from the literal.
-  llvm::Value *FuncPtr =
-    Builder.CreateStructGEP(CGM.getGenericBlockLiteralType(), BlockLiteral, 3);
+    // Get the function pointer from the literal.
+    FuncPtr =
+      Builder.CreateStructGEP(CGM.getGenericBlockLiteralType(), BlockLiteral, 3);
 
-  BlockLiteral = Builder.CreateBitCast(BlockLiteral, VoidPtrTy);
+    BlockLiteral = Builder.CreateBitCast(BlockLiteral, VoidPtrTy);
+  }
 
   // Add the block literal.
   CallArgList Args;
@@ -979,8 +1042,11 @@ RValue CodeGenFunction::EmitBlockCallExpr(const CallExpr *E,
   // And the rest of the arguments.
   EmitCallArgs(Args, FnType->getAs<FunctionProtoType>(), E->arguments());
 
-  // Load the function.
-  llvm::Value *Func = Builder.CreateAlignedLoad(FuncPtr, getPointerAlign());
+  if (!CGM.getLangOpts().OpenCL) {
+    assert(FuncPtr);
+    // Load the function.
+    Func = Builder.CreateAlignedLoad(FuncPtr, getPointerAlign());
+  }
 
   const FunctionType *FuncTy = FnType->castAs<FunctionType>();
   const CGFunctionInfo &FnInfo =
@@ -1047,6 +1113,13 @@ CodeGenModule::GetAddrOfGlobalBlock(const BlockExpr *blockExpr,
                                                            LocalDeclMap,
                                                            false);
   }
+
+  if (getLangOpts().OpenCL) {
+    // In OpenCL, we bind the block lazily, so here we just generate the
+    // block invoke function
+    return blockFn;
+  }
+
   blockFn = llvm::ConstantExpr::getBitCast(blockFn, VoidPtrTy);
 
   return buildGlobalBlock(*this, blockInfo, blockFn);
diff --git a/lib/CodeGen/CGBuiltin.cpp b/lib/CodeGen/CGBuiltin.cpp
index 787ac53..9af0cf8 100644
--- a/lib/CodeGen/CGBuiltin.cpp
+++ b/lib/CodeGen/CGBuiltin.cpp
@@ -15,9 +15,11 @@
 #include "CGCXXABI.h"
 #include "CGObjCRuntime.h"
 #include "CodeGenModule.h"
+#include "CGOpenCLRuntime.h"
 #include "TargetInfo.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/Decl.h"
+#include "clang/AST/Expr.h"
 #include "clang/Basic/TargetBuiltins.h"
 #include "clang/Basic/TargetInfo.h"
 #include "clang/CodeGen/CGFunctionInfo.h"
@@ -1318,29 +1320,29 @@ RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
       int ord = cast<llvm::ConstantInt>(Order)->getZExtValue();
       AtomicRMWInst *Result = nullptr;
       switch (ord) {
-      case 0:  // memory_order_relaxed
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_relaxed:
       default: // invalid order
         Result = Builder.CreateAtomicRMW(llvm::AtomicRMWInst::Xchg,
                                          Ptr, NewVal,
                                          llvm::Monotonic);
         break;
-      case 1:  // memory_order_consume
-      case 2:  // memory_order_acquire
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_consume:
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_acquire:
         Result = Builder.CreateAtomicRMW(llvm::AtomicRMWInst::Xchg,
                                          Ptr, NewVal,
                                          llvm::Acquire);
         break;
-      case 3:  // memory_order_release
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_release:
         Result = Builder.CreateAtomicRMW(llvm::AtomicRMWInst::Xchg,
                                          Ptr, NewVal,
                                          llvm::Release);
         break;
-      case 4:  // memory_order_acq_rel
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_acq_rel:
         Result = Builder.CreateAtomicRMW(llvm::AtomicRMWInst::Xchg,
                                          Ptr, NewVal,
                                          llvm::AcquireRelease);
         break;
-      case 5:  // memory_order_seq_cst
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_seq_cst:
         Result = Builder.CreateAtomicRMW(llvm::AtomicRMWInst::Xchg,
                                          Ptr, NewVal,
                                          llvm::SequentiallyConsistent);
@@ -1404,14 +1406,14 @@ RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
       int ord = cast<llvm::ConstantInt>(Order)->getZExtValue();
       StoreInst *Store = Builder.CreateStore(NewVal, Ptr, Volatile);
       switch (ord) {
-      case 0:  // memory_order_relaxed
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_relaxed:
       default: // invalid order
         Store->setOrdering(llvm::Monotonic);
         break;
-      case 3:  // memory_order_release
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_release:
         Store->setOrdering(llvm::Release);
         break;
-      case 5:  // memory_order_seq_cst
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_seq_cst:
         Store->setOrdering(llvm::SequentiallyConsistent);
         break;
       }
@@ -1461,20 +1463,20 @@ RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
     if (isa<llvm::ConstantInt>(Order)) {
       int ord = cast<llvm::ConstantInt>(Order)->getZExtValue();
       switch (ord) {
-      case 0:  // memory_order_relaxed
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_relaxed:
       default: // invalid order
         break;
-      case 1:  // memory_order_consume
-      case 2:  // memory_order_acquire
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_consume:
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_acquire:
         Builder.CreateFence(llvm::Acquire, Scope);
         break;
-      case 3:  // memory_order_release
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_release:
         Builder.CreateFence(llvm::Release, Scope);
         break;
-      case 4:  // memory_order_acq_rel
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_acq_rel:
         Builder.CreateFence(llvm::AcquireRelease, Scope);
         break;
-      case 5:  // memory_order_seq_cst
+      case AtomicExpr::AtomicOrderingKind::AO_ABI_memory_order_seq_cst:
         Builder.CreateFence(llvm::SequentiallyConsistent, Scope);
         break;
       }
@@ -1885,6 +1887,182 @@ RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
     RMWI->setVolatile(true);
     return RValue::get(RMWI);
   }
+  case Builtin::BIread_pipe:
+  case Builtin::BIwrite_pipe: {
+    const char *NamePrefix = (BuiltinID == Builtin::BIread_pipe) ?
+                             "_Z9read_pipe" : "_Z10write_pipe";
+    llvm::LLVMContext& Ctxt = getLLVMContext();
+    Value *Arg0 = EmitScalarExpr(E->getArg(0)),
+          *Arg1 = EmitScalarExpr(E->getArg(1));
+    Value *PacketSize = CGOpenCLRuntime(CGM).getPipeElemSize(E->getArg(0));
+    Value *PacketAlign = CGOpenCLRuntime(CGM).getPipeElemAlign(E->getArg(0));
+    llvm::SmallString<128> Out;
+
+    // Type of the packet parameter.
+    llvm::Type *I8PTy = llvm::PointerType::get(llvm::Type::getInt8Ty(Ctxt), 4U);
+
+    // Testing which overloaded version we should generate the call for.
+    if (2U == E->getNumArgs()) {
+      // The name is mangled with hard-coded, since we would like to avoid the
+      // AST rewrite.
+      SmallString<64> SS;
+      Ocl20Mangler Mangler(SS);
+      Mangler.appendPointer(1).appendPipe().appendPointer(4).appendVoid().
+              appendUint().appendUint();
+
+      llvm::StringRef ManglerRef = SS.str();
+      Twine NameTwine(NamePrefix, ManglerRef);
+      StringRef Name = NameTwine.toStringRef(Out);
+      // Re-Creating the function type for this call, since the original type
+      // is variadic, which we convert to a specific type to match this call.
+      llvm::Type *ArgTys[] = {Arg0->getType(), I8PTy, Int32Ty, Int32Ty};
+      llvm::FunctionType *FTy = llvm::FunctionType::get(
+                                            Int32Ty,
+                                            llvm::ArrayRef<llvm::Type*>(ArgTys),
+                                            false);
+      Value *BCast = Builder.CreatePointerCast(Arg1, I8PTy);
+      return RValue::get(Builder.CreateCall(CGM.CreateRuntimeFunction(FTy,
+                                                                       Name),
+											{Arg0,
+                                             BCast,
+                                             PacketSize,
+                                             PacketAlign}));
+    } else {
+      assert(4 == E->getNumArgs() && "Illegal number of parameters to pipe function");
+
+      SmallString<64> SS;
+      Ocl20Mangler Mangler(SS);
+      Mangler.appendPointer(1).appendPipe().appendReservedId().
+              appendUint().appendPointer(4).appendVoid().appendUint().appendUint();
+
+      llvm::StringRef ManglerRef = SS.str();
+      Twine NameTwine(NamePrefix, ManglerRef);
+      StringRef Name = NameTwine.toStringRef(Out);
+      llvm::Type *ArgTys[] = {Arg0->getType(), Arg1->getType(), Int32Ty, I8PTy,
+                              Int32Ty, Int32Ty};
+      Value *Arg2 = EmitScalarExpr(E->getArg(2)),
+            *Arg3 = EmitScalarExpr(E->getArg(3));
+      llvm::FunctionType *FTy = llvm::FunctionType::get(
+                                            Int32Ty,
+                                            llvm::ArrayRef<llvm::Type*>(ArgTys),
+                                            false);
+      Value *BCast = Builder.CreatePointerCast(Arg3, I8PTy);
+      // We know the third argument is an integer type (Verified by Sema, but
+      // we may need to cast it.
+      if (Arg2->getType() != Int32Ty)
+        Arg2 = Builder.CreateZExtOrTrunc(Arg2, Int32Ty);
+      return RValue::get(Builder.CreateCall(CGM.CreateRuntimeFunction(FTy,
+                                                                      Name),
+											{Arg0,
+                                             Arg1,
+                                             Arg2,
+                                             BCast,
+                                             PacketSize,
+                                             PacketAlign}));
+    }
+  }
+  case Builtin::BIreserve_read_pipe:
+  case Builtin::BIreserve_write_pipe:
+  case Builtin::BIwork_group_reserve_read_pipe:
+  case Builtin::BIwork_group_reserve_write_pipe:
+  case Builtin::BIsub_group_reserve_read_pipe:
+  case Builtin::BIsub_group_reserve_write_pipe: {
+    // Composing the mangled name for the function.
+    const char *NamePrefix;
+    if (BuiltinID == Builtin::BIreserve_read_pipe)
+      NamePrefix = "_Z17reserve_read_pipe";
+    else if (BuiltinID == Builtin::BIreserve_write_pipe)
+      NamePrefix = "_Z18reserve_write_pipe";
+    else if(BuiltinID == Builtin::BIwork_group_reserve_read_pipe)
+      NamePrefix = "_Z28work_group_reserve_read_pipe";
+    else if(BuiltinID == Builtin::BIwork_group_reserve_write_pipe)
+      NamePrefix = "_Z29work_group_reserve_write_pipe";
+    else if(BuiltinID == Builtin::BIsub_group_reserve_read_pipe)
+      NamePrefix = "_Z27sub_group_reserve_read_pipe";
+    else
+      NamePrefix = "_Z28sub_group_reserve_write_pipe";
+
+    SmallString<64> SS;
+    Ocl20Mangler Mangler(SS);
+    Mangler.appendPointer(1).appendPipe().appendUint().appendUint().appendUint();
+    llvm::StringRef ManglerRef = SS.str();
+    llvm::Twine NameTwine(NamePrefix, ManglerRef);
+
+    llvm::SmallString<128> Out;
+    llvm::StringRef Name = NameTwine.toStringRef(Out);
+    CGOpenCLRuntime CGOcl(CGM);
+
+    Value *PacketSize = CGOcl.getPipeElemSize(E->getArg(0));
+    Value *PacketAlign = CGOpenCLRuntime(CGM).getPipeElemAlign(E->getArg(0));
+    Value *Arg0 = EmitScalarExpr(E->getArg(0)),
+          *Arg1 = EmitScalarExpr(E->getArg(1));
+    llvm::Type *ReservedIDTy = ConvertType(getContext().OCLReserveIDTy);
+
+    // Building the function's prototype.
+    llvm::Type *ArgTys[] = {Arg0->getType(), Int32Ty, Int32Ty, Int32Ty};
+    llvm::FunctionType *FTy = llvm::FunctionType::get(
+                                            ReservedIDTy,
+                                            llvm::ArrayRef<llvm::Type*>(ArgTys),
+                                            false);
+    // We know the third argument is an integer type (Verified by Sema, but
+    // we may need to cast it.
+    if (Arg1->getType() != Int32Ty)
+      Arg1 = Builder.CreateZExtOrTrunc(Arg1, Int32Ty);
+    return RValue::get( Builder.CreateCall(CGM.CreateRuntimeFunction(FTy, Name),
+										   {Arg0,
+                                            Arg1,
+                                            PacketSize,
+                                            PacketAlign}));
+  }
+  case Builtin::BIcommit_read_pipe:
+  case Builtin::BIcommit_write_pipe:
+  case Builtin::BIwork_group_commit_read_pipe:
+  case Builtin::BIwork_group_commit_write_pipe:
+  case Builtin::BIsub_group_commit_read_pipe:
+  case Builtin::BIsub_group_commit_write_pipe: {
+    // Composing the mangled name for the function.
+    const char *NamePrefix;
+    if (BuiltinID == Builtin::BIcommit_read_pipe)
+      NamePrefix = "_Z16commit_read_pipe";
+    else if(BuiltinID == Builtin::BIcommit_write_pipe)
+      NamePrefix = "_Z17commit_write_pipe";
+    else if(BuiltinID == Builtin::BIwork_group_commit_read_pipe)
+      NamePrefix = "_Z27work_group_commit_read_pipe";
+    else if(BuiltinID == Builtin::BIwork_group_commit_write_pipe)
+      NamePrefix = "_Z28work_group_commit_write_pipe";
+    else if(BuiltinID == Builtin::BIsub_group_commit_read_pipe)
+      NamePrefix = "_Z26sub_group_commit_read_pipe";
+    else
+      NamePrefix = "_Z27sub_group_commit_write_pipe";
+
+    SmallString<64> SS;
+    Ocl20Mangler Mangler(SS);
+    Mangler.appendPointer(1).appendPipe().appendReservedId().appendUint().appendUint();
+    llvm::StringRef ManglerRef = SS.str();
+    llvm::Twine NameTwine(NamePrefix, ManglerRef);
+
+    llvm::SmallString<128> Out;
+    llvm::StringRef Name = NameTwine.toStringRef(Out);
+    CGOpenCLRuntime CGOcl(CGM);
+
+    Value *PacketSize = CGOcl.getPipeElemSize(E->getArg(0));
+    Value *PacketAlign = CGOcl.getPipeElemAlign(E->getArg(0));
+    Value *Arg0 = EmitScalarExpr(E->getArg(0)),
+          *Arg1 = EmitScalarExpr(E->getArg(1));
+
+    // Building the function's prototype.
+    llvm::Type *ArgTys[] = {Arg0->getType(), Arg1->getType(), Int32Ty, Int32Ty};
+    llvm::FunctionType *FTy = llvm::FunctionType::get(
+                                        llvm::Type::getVoidTy(getLLVMContext()),
+                                        llvm::ArrayRef<llvm::Type*>(ArgTys),
+                                        false);
+
+    return RValue::get(Builder.CreateCall(CGM.CreateRuntimeFunction(FTy, Name),
+										  {Arg0,
+                                           Arg1,
+                                           PacketSize,
+                                           PacketAlign}));
+  }
   case Builtin::BI__readfsdword: {
     Value *IntToPtr =
       Builder.CreateIntToPtr(EmitScalarExpr(E->getArg(0)),
@@ -1963,6 +2141,37 @@ RValue CodeGenFunction::EmitBuiltinExpr(const FunctionDecl *FD,
       return RValue::get(llvm::ConstantExpr::getBitCast(GV, CGM.Int8PtrTy));
     break;
   }
+  case Builtin::BIget_pipe_num_packets:
+  case Builtin::BIget_pipe_max_packets: {
+    // Composing the builtin's name.
+    const char *NamePrefix;
+    if (BuiltinID == Builtin::BIget_pipe_num_packets)
+      NamePrefix = "_Z20get_pipe_num_packets";
+    else
+      NamePrefix = "_Z20get_pipe_max_packets";
+    SmallString<64> SS;
+    Ocl20Mangler Mangler(SS);
+    Mangler.appendPointer(1).appendPipe().appendUint().appendUint();
+    llvm::StringRef ManglerRef = SS.str();
+    llvm::Twine NameTwine(NamePrefix, ManglerRef);
+    llvm::SmallString<128> Out;
+    llvm::StringRef Name = NameTwine.toStringRef(Out);
+
+    // Building the function's prototype.
+    CGOpenCLRuntime CGOcl(CGM);
+    Value *PacketSize = CGOcl.getPipeElemSize(E->getArg(0));
+    Value *PacketAlign = CGOcl.getPipeElemAlign(E->getArg(0));
+    Value *Arg0 = EmitScalarExpr(E->getArg(0));
+    llvm::Type *ArgTys[] = {Arg0->getType(), Int32Ty, Int32Ty};
+    llvm::FunctionType *FTy = llvm::FunctionType::get(Int32Ty,
+                                           llvm::ArrayRef<llvm::Type*>(ArgTys),
+                                           false);
+
+    return RValue::get(Builder.CreateCall(CGM.CreateRuntimeFunction(FTy, Name),
+										  {Arg0,
+										   PacketSize,
+										   PacketAlign}));
+  }
   }
 
   // If this is an alias for a lib function (e.g. __builtin_sin), emit
diff --git a/lib/CodeGen/CGCall.cpp b/lib/CodeGen/CGCall.cpp
index 9359850..a7f0169 100644
--- a/lib/CodeGen/CGCall.cpp
+++ b/lib/CodeGen/CGCall.cpp
@@ -606,6 +606,10 @@ struct TypeExpansion {
     TEK_Record,
     // For complex types, real and imaginary parts are expanded recursively.
     TEK_Complex,
+    // Special libfloor vector compat expansion (aggregate -> clang/llvm vector).
+    TEK_FloorVectorCompat,
+    // Special libfloor aggregate/record expansion.
+    TEK_FloorAggregate,
     // All other types are not expandable.
     TEK_None
   };
@@ -649,6 +653,31 @@ struct ComplexExpansion : TypeExpansion {
   }
 };
 
+struct FloorVectorCompatExpansion : TypeExpansion {
+  QualType orig_type;
+  QualType vector_type;
+
+  FloorVectorCompatExpansion(QualType orig_type_, QualType vector_type_)
+      : TypeExpansion(TEK_FloorVectorCompat), orig_type(orig_type_), vector_type(vector_type_) {}
+  static bool classof(const TypeExpansion *TE) {
+    return TE->Kind == TEK_FloorVectorCompat;
+  }
+};
+
+struct FloorAggregateExpansion : TypeExpansion {
+  SmallVector<const CXXBaseSpecifier *, 1> bases;
+  SmallVector<const FieldDecl *, 1> field_decls;
+  std::vector<CodeGenTypes::aggregate_scalar_entry> fields;
+
+  FloorAggregateExpansion(SmallVector<const CXXBaseSpecifier *, 1> &&bases_,
+                          SmallVector<const FieldDecl *, 1> &&field_decls_,
+                          std::vector<CodeGenTypes::aggregate_scalar_entry> &&fields_)
+      : TypeExpansion(TEK_FloorAggregate), bases(bases_), field_decls(field_decls_), fields(fields_) {}
+  static bool classof(const TypeExpansion *TE) {
+    return TE->Kind == TEK_FloorAggregate;
+  }
+};
+
 struct NoExpansion : TypeExpansion {
   NoExpansion() : TypeExpansion(TEK_None) {}
   static bool classof(const TypeExpansion *TE) {
@@ -658,12 +687,45 @@ struct NoExpansion : TypeExpansion {
 }  // namespace
 
 static std::unique_ptr<TypeExpansion>
-getTypeExpansion(QualType Ty, const ASTContext &Context) {
+getTypeExpansion(QualType Ty, const ASTContext &Context, const CodeGenTypes& CGT) {
   if (const ConstantArrayType *AT = Context.getAsConstantArrayType(Ty)) {
     return llvm::make_unique<ConstantArrayExpansion>(
         AT->getElementType(), AT->getSize().getZExtValue());
   }
-  if (const RecordType *RT = Ty->getAs<RecordType>()) {
+  const RecordType *RT = Ty->getAs<RecordType>();
+  const CXXRecordDecl* cxx_rdecl = (RT != nullptr ? RT->getAsCXXRecordDecl() : nullptr);
+  if (Context.getLangOpts().Metal && cxx_rdecl && cxx_rdecl->hasAttr<VectorCompatAttr>()) {
+    // libfloor vector compat expansion
+    const auto vec_type = CGT.get_compat_vector_type(cxx_rdecl);
+    return llvm::make_unique<FloorVectorCompatExpansion>(Ty, vec_type);
+  }
+  if (cxx_rdecl &&
+      (Ty->isAggregateImageType() || Context.getLangOpts().Metal) &&
+      !cxx_rdecl->isUnion()) {
+    // libfloor aggregate expansion (image or metal)
+    // similar to (non-union) record expansion below, but also stores some additional information
+    SmallVector<const CXXBaseSpecifier *, 1> bases;
+    SmallVector<const FieldDecl *, 1> field_decls;
+
+    assert(!cxx_rdecl->isDynamicClass() &&
+           "cannot expand vtable pointers in dynamic classes");
+    for (const CXXBaseSpecifier &BS : cxx_rdecl->bases()) {
+      bases.push_back(&BS);
+    }
+
+    for (const auto *FD : cxx_rdecl->fields()) {
+      // Skip zero length bitfields.
+      if (FD->isBitField() && FD->getBitWidthValue(Context) == 0)
+        continue;
+      assert(!FD->isBitField() &&
+             "Cannot expand structure with bit-field members.");
+      field_decls.push_back(FD);
+    }
+
+    auto fields = CGT.get_aggregate_scalar_fields(cxx_rdecl, cxx_rdecl, false, false);
+    return llvm::make_unique<FloorAggregateExpansion>(std::move(bases), std::move(field_decls), std::move(fields));
+  }
+  if (RT) {
     SmallVector<const CXXBaseSpecifier *, 1> Bases;
     SmallVector<const FieldDecl *, 1> Fields;
     const RecordDecl *RD = RT->getDecl();
@@ -715,17 +777,23 @@ getTypeExpansion(QualType Ty, const ASTContext &Context) {
   return llvm::make_unique<NoExpansion>();
 }
 
-static int getExpansionSize(QualType Ty, const ASTContext &Context) {
-  auto Exp = getTypeExpansion(Ty, Context);
+static int getExpansionSize(QualType Ty, const ASTContext &Context, const CodeGenTypes& CGT) {
+  auto Exp = getTypeExpansion(Ty, Context, CGT);
   if (auto CAExp = dyn_cast<ConstantArrayExpansion>(Exp.get())) {
-    return CAExp->NumElts * getExpansionSize(CAExp->EltTy, Context);
+    return CAExp->NumElts * getExpansionSize(CAExp->EltTy, Context, CGT);
+  }
+  if (isa<FloorVectorCompatExpansion>(Exp.get())) {
+    return 1;
+  }
+  if (auto FAExp = dyn_cast<FloorAggregateExpansion>(Exp.get())) {
+    return FAExp->fields.size();
   }
   if (auto RExp = dyn_cast<RecordExpansion>(Exp.get())) {
     int Res = 0;
     for (auto BS : RExp->Bases)
-      Res += getExpansionSize(BS->getType(), Context);
+      Res += getExpansionSize(BS->getType(), Context, CGT);
     for (auto FD : RExp->Fields)
-      Res += getExpansionSize(FD->getType(), Context);
+      Res += getExpansionSize(FD->getType(), Context, CGT);
     return Res;
   }
   if (isa<ComplexExpansion>(Exp.get()))
@@ -737,11 +805,17 @@ static int getExpansionSize(QualType Ty, const ASTContext &Context) {
 void
 CodeGenTypes::getExpandedTypes(QualType Ty,
                                SmallVectorImpl<llvm::Type *>::iterator &TI) {
-  auto Exp = getTypeExpansion(Ty, Context);
+  auto Exp = getTypeExpansion(Ty, Context, *this);
   if (auto CAExp = dyn_cast<ConstantArrayExpansion>(Exp.get())) {
     for (int i = 0, n = CAExp->NumElts; i < n; i++) {
       getExpandedTypes(CAExp->EltTy, TI);
     }
+  } else if (auto FVCExp = dyn_cast<FloorVectorCompatExpansion>(Exp.get())) {
+    *TI++ = ConvertType(FVCExp->vector_type);
+  } else if (auto FAExp = dyn_cast<FloorAggregateExpansion>(Exp.get())) {
+    for(const auto& field : FAExp->fields) {
+      *TI++ = ConvertType(field.type);
+    }
   } else if (auto RExp = dyn_cast<RecordExpansion>(Exp.get())) {
     for (auto BS : RExp->Bases)
       getExpandedTypes(BS->getType(), TI);
@@ -777,13 +851,36 @@ void CodeGenFunction::ExpandTypeFromArgs(
   assert(LV.isSimple() &&
          "Unexpected non-simple lvalue during struct expansion.");
 
-  auto Exp = getTypeExpansion(Ty, getContext());
+  auto Exp = getTypeExpansion(Ty, getContext(), getTypes());
   if (auto CAExp = dyn_cast<ConstantArrayExpansion>(Exp.get())) {
     forConstantArrayExpansion(*this, CAExp, LV.getAddress(),
                               [&](Address EltAddr) {
       LValue LV = MakeAddrLValue(EltAddr, CAExp->EltTy);
       ExpandTypeFromArgs(CAExp->EltTy, LV, AI);
     });
+  } else if (auto FVCExp = dyn_cast<FloorVectorCompatExpansion>(Exp.get())) {
+    LValue VecLV = MakeAddrLValue(LV.getAddress(), FVCExp->vector_type);
+    ExpandTypeFromArgs(FVCExp->vector_type, VecLV, AI);
+  } else if (auto FAExp = dyn_cast<FloorAggregateExpansion>(Exp.get())) {
+    // TODO: should this recurse into bases with ExpandTypeFromArgs or do this manually?
+    Address This = LV.getAddress();
+    for (const CXXBaseSpecifier *BS : FAExp->bases) {
+      // Perform a single step derived-to-base conversion.
+      Address Base =
+          GetAddressOfBaseClass(This, Ty->getAsCXXRecordDecl(), &BS, &BS + 1,
+                                /*NullCheckValue=*/false, SourceLocation());
+      LValue SubLV = MakeAddrLValue(Base, BS->getType());
+
+      // Recurse onto bases.
+      ExpandTypeFromArgs(BS->getType(), SubLV, AI);
+    }
+
+    for(const auto& field : FAExp->fields) {
+      if(field.is_in_base) continue; // already handled
+      // TODO: arrays -> these have no FD
+      LValue SubLV = EmitLValueForField(LV, field.field_decl);
+      ExpandTypeFromArgs(SubLV.getType(), SubLV, AI);
+    }
   } else if (auto RExp = dyn_cast<RecordExpansion>(Exp.get())) {
     Address This = LV.getAddress();
     for (const CXXBaseSpecifier *BS : RExp->Bases) {
@@ -814,7 +911,7 @@ void CodeGenFunction::ExpandTypeFromArgs(
 void CodeGenFunction::ExpandTypeToArgs(
     QualType Ty, RValue RV, llvm::FunctionType *IRFuncTy,
     SmallVectorImpl<llvm::Value *> &IRCallArgs, unsigned &IRCallArgPos) {
-  auto Exp = getTypeExpansion(Ty, getContext());
+  auto Exp = getTypeExpansion(Ty, getContext(), getTypes());
   if (auto CAExp = dyn_cast<ConstantArrayExpansion>(Exp.get())) {
     forConstantArrayExpansion(*this, CAExp, RV.getAggregateAddress(),
                               [&](Address EltAddr) {
@@ -822,6 +919,34 @@ void CodeGenFunction::ExpandTypeToArgs(
           convertTempToRValue(EltAddr, CAExp->EltTy, SourceLocation());
       ExpandTypeToArgs(CAExp->EltTy, EltRV, IRFuncTy, IRCallArgs, IRCallArgPos);
     });
+  } else if (auto FVCExp = dyn_cast<FloorVectorCompatExpansion>(Exp.get())) {
+    const auto llvm_vec_type = getTypes().ConvertType(FVCExp->vector_type);
+    auto vec_ptr = Builder.CreateBitCast(RV.getAggregateAddress().getPointer(),
+                                         llvm::PointerType::get(llvm_vec_type, Ty.getAddressSpace()));
+    Address vec_ptr_addr(vec_ptr, RV.getAggregateAddress().getAlignment());
+    IRCallArgs[IRCallArgPos++] = Builder.CreateLoad(vec_ptr_addr);
+  } else if (auto FAExp = dyn_cast<FloorAggregateExpansion>(Exp.get())) {
+    // TODO: should this recurse into bases with ExpandTypeToArgs or do this manually?
+    Address This = RV.getAggregateAddress();
+    for (const CXXBaseSpecifier *BS : FAExp->bases) {
+      // Perform a single step derived-to-base conversion.
+      Address Base =
+          GetAddressOfBaseClass(This, Ty->getAsCXXRecordDecl(), &BS, &BS + 1,
+                                /*NullCheckValue=*/false, SourceLocation());
+      RValue BaseRV = RValue::getAggregate(Base);
+
+      // Recurse onto bases.
+      ExpandTypeToArgs(BS->getType(), BaseRV, IRFuncTy, IRCallArgs,
+                       IRCallArgPos);
+    }
+
+    LValue LV = MakeAddrLValue(This, Ty);
+    for(const auto& field : FAExp->fields) {
+      if(field.is_in_base) continue; // already handled
+      // TODO: arrays -> these have no FD
+      RValue FldRV = EmitRValueForField(LV, field.field_decl, SourceLocation());
+      ExpandTypeToArgs(field.field_decl->getType(), FldRV, IRFuncTy, IRCallArgs, IRCallArgPos);
+    }
   } else if (auto RExp = dyn_cast<RecordExpansion>(Exp.get())) {
     Address This = RV.getAggregateAddress();
     for (const CXXBaseSpecifier *BS : RExp->Bases) {
@@ -1132,11 +1257,11 @@ class ClangToLLVMArgMapping {
   SmallVector<IRArgs, 8> ArgInfo;
 
 public:
-  ClangToLLVMArgMapping(const ASTContext &Context, const CGFunctionInfo &FI,
+  ClangToLLVMArgMapping(const ASTContext &Context, const CGFunctionInfo &FI, const CodeGenTypes& CGT,
                         bool OnlyRequiredArgs = false)
       : InallocaArgNo(InvalidIndex), SRetArgNo(InvalidIndex), TotalIRArgs(0),
         ArgInfo(OnlyRequiredArgs ? FI.getNumRequiredArgs() : FI.arg_size()) {
-    construct(Context, FI, OnlyRequiredArgs);
+    construct(Context, FI, CGT, OnlyRequiredArgs);
   }
 
   bool hasInallocaArg() const { return InallocaArgNo != InvalidIndex; }
@@ -1171,12 +1296,13 @@ public:
   }
 
 private:
-  void construct(const ASTContext &Context, const CGFunctionInfo &FI,
+  void construct(const ASTContext &Context, const CGFunctionInfo &FI, const CodeGenTypes& CGT,
                  bool OnlyRequiredArgs);
 };
 
 void ClangToLLVMArgMapping::construct(const ASTContext &Context,
                                       const CGFunctionInfo &FI,
+                                      const CodeGenTypes& CGT,
                                       bool OnlyRequiredArgs) {
   unsigned IRArgNo = 0;
   bool SwapThisWithSRet = false;
@@ -1221,7 +1347,7 @@ void ClangToLLVMArgMapping::construct(const ASTContext &Context,
       IRArgs.NumberOfArgs = 0;
       break;
     case ABIArgInfo::Expand: {
-      IRArgs.NumberOfArgs = getExpansionSize(ArgType, Context);
+      IRArgs.NumberOfArgs = getExpansionSize(ArgType, Context, CGT);
       break;
     }
     }
@@ -1325,7 +1451,7 @@ CodeGenTypes::GetFunctionType(const CGFunctionInfo &FI) {
     break;
   }
 
-  ClangToLLVMArgMapping IRFunctionArgs(getContext(), FI, true);
+  ClangToLLVMArgMapping IRFunctionArgs(getContext(), FI, *this, true);
   SmallVector<llvm::Type*, 8> ArgTypes(IRFunctionArgs.totalIRArgs());
 
   // Add type for sret argument.
@@ -1594,7 +1720,7 @@ void CodeGenModule::ConstructAttributeList(
     }
   }
 
-  ClangToLLVMArgMapping IRFunctionArgs(getContext(), FI);
+  ClangToLLVMArgMapping IRFunctionArgs(getContext(), FI, getTypes());
 
   QualType RetTy = FI.getReturnType();
   const ABIArgInfo &RetAI = FI.getReturnInfo();
@@ -1833,7 +1959,7 @@ void CodeGenFunction::EmitFunctionProlog(const CGFunctionInfo &FI,
   // FIXME: We no longer need the types from FunctionArgList; lift up and
   // simplify.
 
-  ClangToLLVMArgMapping IRFunctionArgs(CGM.getContext(), FI);
+  ClangToLLVMArgMapping IRFunctionArgs(CGM.getContext(), FI, getTypes());
   // Flattened function arguments.
   SmallVector<llvm::Argument *, 16> FnArgs;
   FnArgs.reserve(IRFunctionArgs.totalIRArgs());
@@ -3201,7 +3327,7 @@ RValue CodeGenFunction::EmitCall(const CGFunctionInfo &CallInfo,
     return Builder.CreateStructGEP(ArgMemory, FieldIndex, FieldOffset);
   };
 
-  ClangToLLVMArgMapping IRFunctionArgs(CGM.getContext(), CallInfo);
+  ClangToLLVMArgMapping IRFunctionArgs(CGM.getContext(), CallInfo, getTypes());
   SmallVector<llvm::Value *, 16> IRCallArgs(IRFunctionArgs.totalIRArgs());
 
   // If the call returns a temporary with struct return, create a temporary
@@ -3342,8 +3468,14 @@ RValue CodeGenFunction::EmitCall(const CGFunctionInfo &CallInfo,
         // If the argument doesn't match, perform a bitcast to coerce it.  This
         // can happen due to trivial type mismatches.
         if (FirstIRArg < IRFuncTy->getNumParams() &&
-            V->getType() != IRFuncTy->getParamType(FirstIRArg))
-          V = Builder.CreateBitCast(V, IRFuncTy->getParamType(FirstIRArg));
+            V->getType() != IRFuncTy->getParamType(FirstIRArg)) {
+          const auto src_as = V->getType()->getPointerAddressSpace();
+          auto param_type = IRFuncTy->getParamType(FirstIRArg);
+          if(src_as > 0 && src_as != param_type->getPointerAddressSpace()) {
+            param_type = llvm::PointerType::get(cast<llvm::PointerType>(param_type->getScalarType())->getElementType(), src_as);
+          }
+          V = Builder.CreateBitCast(V, param_type);
+        }
         IRCallArgs[FirstIRArg] = V;
         break;
       }
@@ -3483,8 +3615,17 @@ RValue CodeGenFunction::EmitCall(const CGFunctionInfo &CallInfo,
     if (IRFunctionArgs.hasInallocaArg() &&
         i == IRFunctionArgs.getInallocaArgNo())
       continue;
-    if (i < IRFuncTy->getNumParams())
+    if (i < IRFuncTy->getNumParams()) {
+      if (getLangOpts().OpenCL &&
+          IRFuncTy->getParamType(i)->isPointerTy() &&
+          IRCallArgs[i]->getType()->isPointerTy() &&
+          llvm::PointerType::get(IRFuncTy->getParamType(i)->getPointerElementType(), 0) ==
+          llvm::PointerType::get(IRCallArgs[i]->getType()->getPointerElementType(), 0)) {
+        // ignore address space mismatches for opencl/metal
+        continue;
+      }
       assert(IRCallArgs[i]->getType() == IRFuncTy->getParamType(i));
+    }
   }
 
   unsigned CallingConv;
@@ -3619,6 +3760,13 @@ RValue CodeGenFunction::EmitCall(const CGFunctionInfo &CallInfo,
             DestPtr = CreateMemTemp(RetTy, "agg.tmp");
             DestIsVolatile = false;
           }
+
+          // handle [[vector_compat]] stores from an aggregate to a vector type
+          if(DestPtr.getType()->getPointerElementType()->isVectorTy()) {
+            CreateCoercedStore(CI, DestPtr, DestIsVolatile, *this);
+            return RValue::get(DestPtr.getPointer());
+          }
+
           BuildAggStore(*this, CI, DestPtr, DestIsVolatile);
           return RValue::getAggregate(DestPtr);
         }
diff --git a/lib/CodeGen/CGClass.cpp b/lib/CodeGen/CGClass.cpp
index 2e566de..49de167 100644
--- a/lib/CodeGen/CGClass.cpp
+++ b/lib/CodeGen/CGClass.cpp
@@ -297,9 +297,16 @@ Address CodeGenFunction::GetAddressOfBaseClass(
     VBase = nullptr; // we no longer have a virtual step
   }
 
-  // Get the base pointer type.
+  // Get the base pointer type, and keep the Values address space if it has one
+  const auto val_type = Value.getType();
+  unsigned val_as = 0;
+  if(val_type != nullptr &&
+     val_type->isPointerTy() &&
+     val_type->getPointerAddressSpace() != 0) {
+    val_as = val_type->getPointerAddressSpace();
+  }
   llvm::Type *BasePtrTy =
-    ConvertType((PathEnd[-1])->getType())->getPointerTo();
+    ConvertType((PathEnd[-1])->getType())->getPointerTo(val_as);
 
   QualType DerivedTy = getContext().getRecordType(Derived);
   CharUnits DerivedAlign = CGM.getClassPointerAlignment(Derived);
diff --git a/lib/CodeGen/CGDebugInfo.cpp b/lib/CodeGen/CGDebugInfo.cpp
index 5df8519..cd329d1 100644
--- a/lib/CodeGen/CGDebugInfo.cpp
+++ b/lib/CodeGen/CGDebugInfo.cpp
@@ -463,39 +463,11 @@ llvm::DIType *CGDebugInfo::CreateType(const BuiltinType *BT) {
     return SelTy;
   }
 
-  case BuiltinType::OCLImage1d:
-    return getOrCreateStructPtrType("opencl_image1d_t", OCLImage1dDITy);
-  case BuiltinType::OCLImage1dArray:
-    return getOrCreateStructPtrType("opencl_image1d_array_t",
-                                    OCLImage1dArrayDITy);
-  case BuiltinType::OCLImage1dBuffer:
-    return getOrCreateStructPtrType("opencl_image1d_buffer_t",
-                                    OCLImage1dBufferDITy);
-  case BuiltinType::OCLImage2d:
-    return getOrCreateStructPtrType("opencl_image2d_t", OCLImage2dDITy);
-  case BuiltinType::OCLImage2dArray:
-    return getOrCreateStructPtrType("opencl_image2d_array_t",
-                                    OCLImage2dArrayDITy);
-  case BuiltinType::OCLImage2dDepth:
-    return getOrCreateStructPtrType("opencl_image2d_depth_t",
-                                    OCLImage2dDepthDITy);
-  case BuiltinType::OCLImage2dArrayDepth:
-    return getOrCreateStructPtrType("opencl_image2d_array_depth_t",
-                                    OCLImage2dArrayDepthDITy);
-  case BuiltinType::OCLImage2dMSAA:
-    return getOrCreateStructPtrType("opencl_image2d_msaa_t",
-                                    OCLImage2dMSAADITy);
-  case BuiltinType::OCLImage2dArrayMSAA:
-    return getOrCreateStructPtrType("opencl_image2d_array_msaa_t",
-                                    OCLImage2dArrayMSAADITy);
-  case BuiltinType::OCLImage2dMSAADepth:
-    return getOrCreateStructPtrType("opencl_image2d_msaa_depth_t",
-                                    OCLImage2dMSAADepthDITy);
-  case BuiltinType::OCLImage2dArrayMSAADepth:
-    return getOrCreateStructPtrType("opencl_image2d_array_msaa_depth_t",
-                                    OCLImage2dArrayMSAADepthDITy);
-  case BuiltinType::OCLImage3d:
-    return getOrCreateStructPtrType("opencl_image3d_t", OCLImage3dDITy);
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id: \
+    return getOrCreateStructPtrType("opencl_" #ImgType #Suffix "_t", \
+                                    SingletonId);
+#include "clang/Basic/OpenCLImageTypes.def"
   case BuiltinType::OCLSampler:
     return DBuilder.createBasicType(
         "opencl_sampler_t", CGM.getContext().getTypeSize(BT),
@@ -552,13 +524,19 @@ llvm::DIType *CGDebugInfo::CreateType(const BuiltinType *BT) {
 
   switch (BT->getKind()) {
   case BuiltinType::Long:
-    BTName = "long int";
+    if (CGM.getLangOpts().OpenCL)
+      BTName = "long";
+    else
+      BTName = "long int";
     break;
   case BuiltinType::LongLong:
     BTName = "long long int";
     break;
   case BuiltinType::ULong:
-    BTName = "long unsigned int";
+    if (CGM.getLangOpts().OpenCL)
+      BTName = "unsigned long";
+    else
+      BTName = "long unsigned int";
     break;
   case BuiltinType::ULongLong:
     BTName = "long long unsigned int";
@@ -2027,6 +2005,8 @@ llvm::DIType *CGDebugInfo::CreateType(const AtomicType *Ty, llvm::DIFile *U) {
 
 llvm::DIType* CGDebugInfo::CreateType(const PipeType *Ty,
                                      llvm::DIFile *U) {
+  // Ignore the atomic wrapping
+  // FIXME: What is the correct representation?
   return getOrCreateType(Ty->getElementType(), U);
 }
 
diff --git a/lib/CodeGen/CGDebugInfo.h b/lib/CodeGen/CGDebugInfo.h
index a68dd33..e32ad01 100644
--- a/lib/CodeGen/CGDebugInfo.h
+++ b/lib/CodeGen/CGDebugInfo.h
@@ -62,18 +62,9 @@ class CGDebugInfo {
   llvm::DIType *ClassTy = nullptr;
   llvm::DICompositeType *ObjTy = nullptr;
   llvm::DIType *SelTy = nullptr;
-  llvm::DIType *OCLImage1dDITy = nullptr;
-  llvm::DIType *OCLImage1dArrayDITy = nullptr;
-  llvm::DIType *OCLImage1dBufferDITy = nullptr;
-  llvm::DIType *OCLImage2dDITy = nullptr;
-  llvm::DIType *OCLImage2dArrayDITy = nullptr;
-  llvm::DIType *OCLImage2dDepthDITy = nullptr;
-  llvm::DIType *OCLImage2dArrayDepthDITy = nullptr;
-  llvm::DIType *OCLImage2dMSAADITy = nullptr;
-  llvm::DIType *OCLImage2dArrayMSAADITy = nullptr;
-  llvm::DIType *OCLImage2dMSAADepthDITy = nullptr;
-  llvm::DIType *OCLImage2dArrayMSAADepthDITy = nullptr;
-  llvm::DIType *OCLImage3dDITy = nullptr;
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  llvm::DIType *SingletonId = nullptr;
+#include "clang/Basic/OpenCLImageTypes.def"
   llvm::DIType *OCLEventDITy = nullptr;
   llvm::DIType *OCLClkEventDITy = nullptr;
   llvm::DIType *OCLQueueDITy = nullptr;
diff --git a/lib/CodeGen/CGDecl.cpp b/lib/CodeGen/CGDecl.cpp
index b78e80d..71895a6 100644
--- a/lib/CodeGen/CGDecl.cpp
+++ b/lib/CodeGen/CGDecl.cpp
@@ -144,7 +144,9 @@ void CodeGenFunction::EmitVarDecl(const VarDecl &D) {
     // Don't emit it now, allow it to be emitted lazily on its first use.
     return;
 
-  if (D.getType().getAddressSpace() == LangAS::opencl_local)
+  if (D.getType().getAddressSpace() == LangAS::opencl_local ||
+      // TODO: -> SC_OpenCLConstant TODO
+      (D.getStorageClass() == SC_OpenCLConstant))
     return CGM.getOpenCLRuntime().EmitWorkGroupLocalVarDecl(*this, D);
 
   assert(D.hasLocalStorage());
@@ -152,8 +154,12 @@ void CodeGenFunction::EmitVarDecl(const VarDecl &D) {
 }
 
 static std::string getStaticDeclName(CodeGenModule &CGM, const VarDecl &D) {
-  if (CGM.getLangOpts().CPlusPlus)
+  // don't cxx mangle OpenCL "local" variables (affects SPIR and AppleCL - Metal/AIR use cxx mangling)
+  if (CGM.getLangOpts().CPlusPlus &&
+      !(D.getType().getAddressSpace() == LangAS::opencl_local &&
+        CGM.getContext().getLangOpts().OpenCL && !CGM.getContext().getLangOpts().Metal)) {
     return CGM.getMangledName(&D).str();
+  }
 
   // If this isn't C++, we don't need a mangled name, just a pretty one.
   assert(!D.isExternallyVisible() && "name shouldn't matter");
diff --git a/lib/CodeGen/CGExpr.cpp b/lib/CodeGen/CGExpr.cpp
index 507ce3d..cd7d6ba 100644
--- a/lib/CodeGen/CGExpr.cpp
+++ b/lib/CodeGen/CGExpr.cpp
@@ -2102,8 +2102,19 @@ LValue CodeGenFunction::EmitDeclRefLValue(const DeclRefExpr *E) {
 
   if (const auto *VD = dyn_cast<VarDecl>(ND)) {
     // Check if this is a global variable.
-    if (VD->hasLinkage() || VD->isStaticDataMember())
+    if (VD->hasLinkage() || VD->isStaticDataMember()) {
+      if (CGM.getLangOpts().OpenCL && VD->getType()->isBlockPointerType()) {
+        // Look up the block function and bind it with NULL
+        llvm::Constant *blockFnc = CGM.GetOCLGlobalBlockFunction(VD);
+        blockFnc = llvm::ConstantExpr::getBitCast(blockFnc, Int8PtrTy);
+        llvm::Value *block = GenerateOCLBlockBind(blockFnc, 0, 0, llvm::Constant::getNullValue(Int8PtrTy));
+        Address addr = CreateMemTemp(VD->getType());
+        llvm::Value *Ptr = addr.getPointer();
+        Builder.CreateStore(block, addr);
+        return MakeNaturalAlignAddrLValue(Ptr, VD->getType());
+      }
       return EmitGlobalVarDeclLValue(*this, E, VD);
+    }
 
     Address addr = Address::invalid();
 
@@ -3076,11 +3087,11 @@ LValue CodeGenFunction::EmitLValueForLambdaField(const FieldDecl *Field) {
 ///
 /// The resulting address doesn't necessarily have the right type.
 static Address emitAddrOfFieldStorage(CodeGenFunction &CGF, Address base,
-                                      const FieldDecl *field) {
+                                      const FieldDecl *field, llvm::Type* elem_type) {
   const RecordDecl *rec = field->getParent();
   
   unsigned idx =
-    CGF.CGM.getTypes().getCGRecordLayout(rec).getLLVMFieldNo(field);
+    CGF.CGM.getTypes().getCGRecordLayout(rec, elem_type).getLLVMFieldNo(field);
 
   CharUnits offset;
   // Adjust the alignment down to the given offset.
@@ -3100,36 +3111,37 @@ static Address emitAddrOfFieldStorage(CodeGenFunction &CGF, Address base,
 
 LValue CodeGenFunction::EmitLValueForField(LValue base,
                                            const FieldDecl *field) {
+  Address addr = base.getAddress();
+  llvm::Type* elem_type = addr.getType()->getPointerElementType();
+  const RecordDecl *rec = field->getParent();
+  const CGRecordLayout &RL = CGM.getTypes().getCGRecordLayout(rec, elem_type);
   AlignmentSource fieldAlignSource =
     getFieldAlignmentSource(base.getAlignmentSource());
 
   if (field->isBitField()) {
-    const CGRecordLayout &RL =
-      CGM.getTypes().getCGRecordLayout(field->getParent());
     const CGBitFieldInfo &Info = RL.getBitFieldInfo(field);
-    Address Addr = base.getAddress();
     unsigned Idx = RL.getLLVMFieldNo(field);
     if (Idx != 0)
       // For structs, we GEP to the field that the record layout suggests.
-      Addr = Builder.CreateStructGEP(Addr, Idx, Info.StorageOffset,
+      addr = Builder.CreateStructGEP(addr, Idx, Info.StorageOffset,
                                      field->getName());
     // Get the access type.
     llvm::Type *FieldIntTy =
       llvm::Type::getIntNTy(getLLVMContext(), Info.StorageSize);
-    if (Addr.getElementType() != FieldIntTy)
-      Addr = Builder.CreateElementBitCast(Addr, FieldIntTy);
+    if (addr.getElementType() != FieldIntTy)
+      addr = Builder.CreateElementBitCast(addr, FieldIntTy);
+
+    // TODO: (clang/llvm 3.8) check if address space is correct
 
     QualType fieldType =
       field->getType().withCVRQualifiers(base.getVRQualifiers());
-    return LValue::MakeBitfield(Addr, Info, fieldType, fieldAlignSource);
+    return LValue::MakeBitfield(addr, Info, fieldType, fieldAlignSource);
   }
 
-  const RecordDecl *rec = field->getParent();
   QualType type = field->getType();
 
   bool mayAlias = rec->hasAttr<MayAliasAttr>();
 
-  Address addr = base.getAddress();
   unsigned cvr = base.getVRQualifiers();
   bool TBAAPath = CGM.getCodeGenOpts().StructPathTBAA;
   if (rec->isUnion()) {
@@ -3139,7 +3151,7 @@ LValue CodeGenFunction::EmitLValueForField(LValue base,
     TBAAPath = false;
   } else {
     // For structs, we GEP to the field that the record layout suggests.
-    addr = emitAddrOfFieldStorage(*this, addr, field);
+    addr = emitAddrOfFieldStorage(*this, addr, field, elem_type);
 
     // If this is a reference field, load the reference right now.
     if (const ReferenceType *refType = type->getAs<ReferenceType>()) {
@@ -3217,7 +3229,8 @@ CodeGenFunction::EmitLValueForFieldInitialization(LValue Base,
   if (!FieldType->isReferenceType())
     return EmitLValueForField(Base, Field);
 
-  Address V = emitAddrOfFieldStorage(*this, Base.getAddress(), Field);
+  llvm::Type* elem_type = Base.getAddress().getType()->getPointerElementType();
+  Address V = emitAddrOfFieldStorage(*this, Base.getAddress(), Field, elem_type);
 
   // Make sure that the address is pointing to the right type.
   llvm::Type *llvmType = ConvertTypeForMem(FieldType);
@@ -3487,6 +3500,10 @@ LValue CodeGenFunction::EmitCastLValue(const CastExpr *E) {
   }
   case CK_ZeroToOCLEvent:
     llvm_unreachable("NULL to OpenCL event lvalue cast is not valid");
+  case CK_ZeroToOCLQueue:
+    llvm_unreachable("NULL to OpenCL queue lvalue cast is not valid");
+  case CK_IntToOCLSampler:
+    llvm_unreachable("int to OpenCL sampler lvalue cast is not valid");
   }
 
   llvm_unreachable("Unhandled lvalue cast kind?");
diff --git a/lib/CodeGen/CGExprAgg.cpp b/lib/CodeGen/CGExprAgg.cpp
index a4547a9..4a5aa23 100644
--- a/lib/CodeGen/CGExprAgg.cpp
+++ b/lib/CodeGen/CGExprAgg.cpp
@@ -748,7 +748,9 @@ void AggExprEmitter::VisitCastExpr(CastExpr *E) {
   case CK_CopyAndAutoreleaseBlockObject:
   case CK_BuiltinFnToFnPtr:
   case CK_ZeroToOCLEvent:
+  case CK_ZeroToOCLQueue:
   case CK_AddressSpaceConversion:
+  case CK_IntToOCLSampler:
     llvm_unreachable("cast kind invalid for aggregate types");
   }
 }
@@ -1429,13 +1431,14 @@ void CodeGenFunction::EmitAggregateCopy(Address DestPtr,
   if (getLangOpts().CPlusPlus) {
     if (const RecordType *RT = Ty->getAs<RecordType>()) {
       CXXRecordDecl *Record = cast<CXXRecordDecl>(RT->getDecl());
-      assert((Record->hasTrivialCopyConstructor() || 
+      // TODO: fix this!
+      /*assert((Record->hasTrivialCopyConstructor() ||
               Record->hasTrivialCopyAssignment() ||
               Record->hasTrivialMoveConstructor() ||
               Record->hasTrivialMoveAssignment() ||
               Record->isUnion()) &&
              "Trying to aggregate-copy a type without a trivial copy/move "
-             "constructor or assignment operator");
+             "constructor or assignment operator");*/
       // Ignore empty classes in C++.
       if (Record->isEmpty())
         return;
diff --git a/lib/CodeGen/CGExprCXX.cpp b/lib/CodeGen/CGExprCXX.cpp
index 604cde7..a2249cb 100644
--- a/lib/CodeGen/CGExprCXX.cpp
+++ b/lib/CodeGen/CGExprCXX.cpp
@@ -24,6 +24,8 @@
 using namespace clang;
 using namespace CodeGen;
 
+// TODO: fix other This uses?
+
 static RequiredArgs commonEmitCXXMemberOrOperatorCall(
     CodeGenFunction &CGF, const CXXMethodDecl *MD, llvm::Value *Callee,
     ReturnValueSlot ReturnValue, llvm::Value *This, llvm::Value *ImplicitParam,
@@ -45,7 +47,9 @@ static RequiredArgs commonEmitCXXMemberOrOperatorCall(
       CallLoc, This, CGF.getContext().getRecordType(MD->getParent()));
 
   // Push the this ptr.
-  Args.add(RValue::get(This), MD->getThisType(CGF.getContext()));
+  auto this_type = CGF.getContext().getAddrSpaceQualType(MD->getThisType(CGF.getContext()),
+                                                         This->getType()->getPointerAddressSpace());
+  Args.add(RValue::get(This), this_type);
 
   // If there is an implicit parameter (e.g. VTT), emit it.
   if (ImplicitParam) {
diff --git a/lib/CodeGen/CGExprComplex.cpp b/lib/CodeGen/CGExprComplex.cpp
index 22910d9..73d5a68 100644
--- a/lib/CodeGen/CGExprComplex.cpp
+++ b/lib/CodeGen/CGExprComplex.cpp
@@ -483,6 +483,8 @@ ComplexPairTy ComplexExprEmitter::EmitCast(CastKind CK, Expr *Op,
   case CK_CopyAndAutoreleaseBlockObject:
   case CK_BuiltinFnToFnPtr:
   case CK_ZeroToOCLEvent:
+  case CK_ZeroToOCLQueue:
+  case CK_IntToOCLSampler:
   case CK_AddressSpaceConversion:
     llvm_unreachable("invalid cast kind for complex value");
 
diff --git a/lib/CodeGen/CGExprConstant.cpp b/lib/CodeGen/CGExprConstant.cpp
index ee049f1..84f2818 100644
--- a/lib/CodeGen/CGExprConstant.cpp
+++ b/lib/CodeGen/CGExprConstant.cpp
@@ -684,6 +684,12 @@ public:
     case CK_ConstructorConversion:
       return C;
 
+    case CK_IntToOCLSampler: {
+      if (!CGM.getLangOpts().CLSamplerOpaque)
+        return C;
+      return CGM.createIntToSamplerConversion(subExpr, CGF);
+    }
+
     case CK_Dependent: llvm_unreachable("saw dependent cast!");
 
     case CK_BuiltinFnToFnPtr:
@@ -743,6 +749,7 @@ public:
     case CK_FloatingToBoolean:
     case CK_FloatingCast:
     case CK_ZeroToOCLEvent:
+    case CK_ZeroToOCLQueue:
       return nullptr;
     }
     llvm_unreachable("Invalid CastKind");
diff --git a/lib/CodeGen/CGExprScalar.cpp b/lib/CodeGen/CGExprScalar.cpp
index 268e7967..97009d8 100644
--- a/lib/CodeGen/CGExprScalar.cpp
+++ b/lib/CodeGen/CGExprScalar.cpp
@@ -1394,8 +1394,14 @@ Value *ScalarExprEmitter::VisitCastExpr(CastExpr *CE) {
     llvm::Type *DstTy = ConvertType(DestTy);
     if (SrcTy->isPtrOrPtrVectorTy() && DstTy->isPtrOrPtrVectorTy() &&
         SrcTy->getPointerAddressSpace() != DstTy->getPointerAddressSpace()) {
-      llvm_unreachable("wrong cast for pointers in different address spaces"
-                       "(must be an address space cast)!");
+      // allow this with opencl/metal
+      if (CGF.getLangOpts().OpenCL) {
+        llvm::Type *MidTy = CGF.CGM.getDataLayout().getIntPtrType(SrcTy);
+        return Builder.CreateIntToPtr(Builder.CreatePtrToInt(Src, MidTy), DstTy);
+      } else {
+        llvm_unreachable("wrong cast for pointers in different address spaces"
+                         "(must be an address space cast)!");
+      }
     }
 
     if (CGF.SanOpts.has(SanitizerKind::CFIUnrelatedCast)) {
@@ -1588,8 +1594,28 @@ Value *ScalarExprEmitter::VisitCastExpr(CastExpr *CE) {
     return llvm::Constant::getNullValue(ConvertType(DestTy));
   }
 
+  case CK_ZeroToOCLQueue: {
+    assert(DestTy->isQueueT() && "CK_ZeroToOCLQueue cast on non queue_t type");
+    return llvm::Constant::getNullValue(ConvertType(DestTy));
+  }
+
+  case CK_IntToOCLSampler: {
+    assert(DestTy->isSamplerT() && "CK_IntToOCLSampler cast to non sampler type");
+    if (!CGF.CGM.getLangOpts().CLSamplerOpaque)
+      return Visit(E);
+    if (const CastExpr* SCE = dyn_cast<CastExpr>(E)) {
+      if (const DeclRefExpr *DRE = cast<DeclRefExpr>(SCE->getSubExpr())) {
+        if (const VarDecl *VD = cast<VarDecl>(DRE->getDecl())) {
+          assert(VD->getInit() && "Invalid sampler initializer");
+          E = const_cast<Expr*>(VD->getInit());
+        }
+      }
+    }
+    return CGF.CGM.createIntToSamplerConversion(E, &CGF);
   }
 
+  } // end of switch
+
   llvm_unreachable("unknown scalar cast");
 }
 
@@ -2495,9 +2521,9 @@ static Value *emitPointerArithmetic(CodeGenFunction &CGF,
   // GNU void* casts amount to no-ops since our void* type is i8*, but this is
   // future proof.
   if (elementType->isVoidType() || elementType->isFunctionType()) {
-    Value *result = CGF.Builder.CreateBitCast(pointer, CGF.VoidPtrTy);
+    Value *result = CGF.Builder.CreatePointerCast(pointer, CGF.VoidPtrTy);
     result = CGF.Builder.CreateGEP(result, index, "add.ptr");
-    return CGF.Builder.CreateBitCast(result, pointer->getType());
+    return CGF.Builder.CreatePointerCast(result, pointer->getType());
   }
 
   if (CGF.getLangOpts().isSignedOverflowDefined())
@@ -3264,35 +3290,9 @@ VisitAbstractConditionalOperator(const AbstractConditionalOperator *E) {
     llvm::Type *condType = ConvertType(condExpr->getType());
     llvm::VectorType *vecTy = cast<llvm::VectorType>(condType);
 
-    unsigned numElem = vecTy->getNumElements();
-    llvm::Type *elemType = vecTy->getElementType();
-
     llvm::Value *zeroVec = llvm::Constant::getNullValue(vecTy);
     llvm::Value *TestMSB = Builder.CreateICmpSLT(CondV, zeroVec);
-    llvm::Value *tmp = Builder.CreateSExt(TestMSB,
-                                          llvm::VectorType::get(elemType,
-                                                                numElem),
-                                          "sext");
-    llvm::Value *tmp2 = Builder.CreateNot(tmp);
-
-    // Cast float to int to perform ANDs if necessary.
-    llvm::Value *RHSTmp = RHS;
-    llvm::Value *LHSTmp = LHS;
-    bool wasCast = false;
-    llvm::VectorType *rhsVTy = cast<llvm::VectorType>(RHS->getType());
-    if (rhsVTy->getElementType()->isFloatingPointTy()) {
-      RHSTmp = Builder.CreateBitCast(RHS, tmp2->getType());
-      LHSTmp = Builder.CreateBitCast(LHS, tmp->getType());
-      wasCast = true;
-    }
-
-    llvm::Value *tmp3 = Builder.CreateAnd(RHSTmp, tmp2);
-    llvm::Value *tmp4 = Builder.CreateAnd(LHSTmp, tmp);
-    llvm::Value *tmp5 = Builder.CreateOr(tmp3, tmp4, "cond");
-    if (wasCast)
-      tmp5 = Builder.CreateBitCast(tmp5, RHS->getType());
-
-    return tmp5;
+    return Builder.CreateSelect(TestMSB, LHS, RHS);
   }
 
   // If this is a really simple expression (like x ? 4 : 5), emit this as a
@@ -3392,30 +3392,35 @@ Value *ScalarExprEmitter::VisitAsTypeExpr(AsTypeExpr *E) {
   Value *Src  = CGF.EmitScalarExpr(E->getSrcExpr());
   llvm::Type *DstTy = ConvertType(E->getType());
 
-  // Going from vec4->vec3 or vec3->vec4 is a special case and requires
+  // Going from or to 3-element vector is a special case and requires
   // a shuffle vector instead of a bitcast.
   llvm::Type *SrcTy = Src->getType();
-  if (isa<llvm::VectorType>(DstTy) && isa<llvm::VectorType>(SrcTy)) {
-    unsigned numElementsDst = cast<llvm::VectorType>(DstTy)->getNumElements();
-    unsigned numElementsSrc = cast<llvm::VectorType>(SrcTy)->getNumElements();
-    if ((numElementsDst == 3 && numElementsSrc == 4)
-        || (numElementsDst == 4 && numElementsSrc == 3)) {
-
-
-      // In the case of going from int4->float3, a bitcast is needed before
-      // doing a shuffle.
-      llvm::Type *srcElemTy =
-      cast<llvm::VectorType>(SrcTy)->getElementType();
-      llvm::Type *dstElemTy =
-      cast<llvm::VectorType>(DstTy)->getElementType();
-
-      if ((srcElemTy->isIntegerTy() && dstElemTy->isFloatTy())
-          || (srcElemTy->isFloatTy() && dstElemTy->isIntegerTy())) {
-        // Create a float type of the same size as the source or destination.
-        llvm::VectorType *newSrcTy = llvm::VectorType::get(dstElemTy,
-                                                                 numElementsSrc);
-
-        Src = Builder.CreateBitCast(Src, newSrcTy, "astypeCast");
+  bool srcIsVectorType = isa<llvm::VectorType>(SrcTy);
+  bool dstIsVectorType = isa<llvm::VectorType>(DstTy);
+
+  if ( srcIsVectorType || dstIsVectorType ) {
+
+    llvm::VectorType *DstVecTy = dstIsVectorType ? cast<llvm::VectorType>(DstTy) : 0;
+    unsigned numElementsDst    = dstIsVectorType ? DstVecTy->getNumElements()    : 1;
+    unsigned elemSizeDst       = dstIsVectorType ? DstVecTy->getElementType()->getPrimitiveSizeInBits() : DstTy->getPrimitiveSizeInBits();
+    unsigned bitWidthDst       = dstIsVectorType ? DstVecTy->getBitWidth() : elemSizeDst;
+
+    llvm::VectorType *SrcVecTy = srcIsVectorType ? cast<llvm::VectorType>(SrcTy) : 0;
+    unsigned numElementsSrc    = srcIsVectorType ? SrcVecTy->getNumElements()    : 1;
+    unsigned elemSizeSrc       = srcIsVectorType ? SrcVecTy->getElementType()->getPrimitiveSizeInBits() : SrcTy->getPrimitiveSizeInBits();
+    unsigned bitWidthSrc       = srcIsVectorType ? SrcVecTy->getBitWidth() : elemSizeSrc;
+
+    if ((numElementsDst == 3 && numElementsSrc != 3
+         && bitWidthSrc == 4 * elemSizeDst)
+        || (numElementsSrc == 3 && numElementsDst != 3
+         && bitWidthDst == 4 * elemSizeSrc)) {
+
+      // Make the source vector element sizes to be the same as 3-element
+      // vector element sizes.
+      if (numElementsDst == 3) {
+        llvm::Type *dstElemTy = dstIsVectorType ? DstVecTy->getElementType() : DstTy;
+        llvm::VectorType *newSrcTy = llvm::VectorType::get(dstElemTy, 4);
+        Src = Builder.CreateBitCast(Src, newSrcTy, "astypeTo4ElemVector");
       }
 
       llvm::Value *UnV = llvm::UndefValue::get(Src->getType());
@@ -3425,15 +3430,25 @@ Value *ScalarExprEmitter::VisitAsTypeExpr(AsTypeExpr *E) {
       Args.push_back(Builder.getInt32(1));
       Args.push_back(Builder.getInt32(2));
 
-      if (numElementsDst == 4)
+      if (numElementsSrc == 3)
         Args.push_back(llvm::UndefValue::get(CGF.Int32Ty));
 
       llvm::Constant *Mask = llvm::ConstantVector::get(Args);
 
-      return Builder.CreateShuffleVector(Src, UnV, Mask, "astype");
+      Src = Builder.CreateShuffleVector(Src, UnV, Mask, "astype");
+
+      if (numElementsSrc == 3) {
+        llvm::Type *newDstTy = dstIsVectorType ? DstVecTy : DstTy;
+        Src = Builder.CreateBitCast(Src, newDstTy, "astypeTo4ElemVector");
+      }
+
+      return Src;
     }
   }
 
+  if (SrcTy->isPointerTy() || DstTy->isPointerTy())
+    return Builder.CreatePointerCast(Src, DstTy, "astype");
+
   return Builder.CreateBitCast(Src, DstTy, "astype");
 }
 
diff --git a/lib/CodeGen/CGOpenCLRuntime.cpp b/lib/CodeGen/CGOpenCLRuntime.cpp
index 6866789..2ace4db 100644
--- a/lib/CodeGen/CGOpenCLRuntime.cpp
+++ b/lib/CodeGen/CGOpenCLRuntime.cpp
@@ -36,72 +36,183 @@ llvm::Type *CGOpenCLRuntime::convertOpenCLSpecificType(const Type *T) {
   llvm::LLVMContext& Ctx = CGM.getLLVMContext();
   uint32_t ImgAddrSpc =
     CGM.getContext().getTargetAddressSpace(LangAS::opencl_global);
-  switch (cast<BuiltinType>(T)->getKind()) {
-  default: 
-    llvm_unreachable("Unexpected opencl builtin type!");
-    return nullptr;
-  case BuiltinType::OCLImage1d:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image1d_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage1dArray:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image1d_array_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage1dBuffer:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image1d_buffer_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage2d:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image2d_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage2dArray:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image2d_array_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage2dDepth:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.image2d_depth_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage2dArrayDepth:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.image2d_array_depth_t"),
-        ImgAddrSpc);
-  case BuiltinType::OCLImage2dMSAA:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.image2d_msaa_t"), ImgAddrSpc);
-  case BuiltinType::OCLImage2dArrayMSAA:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.image2d_array_msaa_t"),
-        ImgAddrSpc);
-  case BuiltinType::OCLImage2dMSAADepth:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.image2d_msaa_depth_t"),
-        ImgAddrSpc);
-  case BuiltinType::OCLImage2dArrayMSAADepth:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.image2d_array_msaa_depth_t"),
-        ImgAddrSpc);
-  case BuiltinType::OCLImage3d:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.image3d_t"), ImgAddrSpc);
-  case BuiltinType::OCLSampler:
-    return llvm::IntegerType::get(Ctx, 32);
-  case BuiltinType::OCLEvent:
-    return llvm::PointerType::get(llvm::StructType::create(
-                           Ctx, "opencl.event_t"), 0);
-  case BuiltinType::OCLClkEvent:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.clk_event_t"), 0);
-  case BuiltinType::OCLQueue:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.queue_t"), 0);
-  case BuiltinType::OCLNDRange:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.ndrange_t"), 0);
-  case BuiltinType::OCLReserveID:
-    return llvm::PointerType::get(
-        llvm::StructType::create(Ctx, "opencl.reserve_id_t"), 0);
+
+  if(!CGM.getCodeGenOpts().EmitAppleCLMetadata && !CGM.getLangOpts().Metal) {
+    switch (cast<BuiltinType>(T)->getKind()) {
+    default:
+      llvm_unreachable("Unexpected opencl builtin type!");
+      return nullptr;
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    case BuiltinType::Id: \
+      return llvm::PointerType::get( \
+          llvm::StructType::create(Ctx, "opencl." #ImgType #Suffix "_t"), \
+          ImgAddrSpc);
+#include "clang/Basic/OpenCLImageTypes.def"
+    case BuiltinType::OCLSampler:
+      if (CGM.getLangOpts().CLSamplerOpaque)
+        return llvm::PointerType::get(llvm::StructType::create(
+                             Ctx, "spirv.Sampler"),
+                             CGM.getContext().getTargetAddressSpace(
+                             LangAS::opencl_constant));
+      else
+        return llvm::IntegerType::get(Ctx, 32);
+    case BuiltinType::OCLEvent:
+      return llvm::PointerType::get(llvm::StructType::create(
+                             Ctx, "opencl.event_t"), 0);
+    case BuiltinType::OCLClkEvent:
+      return llvm::PointerType::get(
+          llvm::StructType::create(Ctx, "opencl.clk_event_t"), 0);
+    case BuiltinType::OCLQueue:
+      return llvm::PointerType::get(
+          llvm::StructType::create(Ctx, "opencl.queue_t"), 0);
+    case BuiltinType::OCLNDRange:
+      return llvm::PointerType::get(
+          llvm::StructType::create(Ctx, "opencl.ndrange_t"), 0);
+    case BuiltinType::OCLReserveID:
+      return llvm::PointerType::get(
+          llvm::StructType::create(Ctx, "opencl.reserve_id_t"), 0);
+    }
+  }
+  else if(CGM.getCodeGenOpts().EmitAppleCLMetadata) {
+    switch (cast<BuiltinType>(T)->getKind()) {
+      default:
+        llvm_unreachable("Unexpected opencl builtin type!");
+        return nullptr;
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    case BuiltinType::Id: \
+      return llvm::PointerType::get( \
+          llvm::StructType::create(Ctx, "struct._" #ImgType "_t"), \
+          ImgAddrSpc);
+#include "clang/Basic/OpenCLImageTypes.def"
+      case BuiltinType::OCLSampler:
+        return llvm::IntegerType::get(Ctx, 32);
+      case BuiltinType::OCLEvent:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._event_t"), 0);
+    }
   }
+  else if(CGM.getLangOpts().Metal) {
+    switch (cast<BuiltinType>(T)->getKind()) {
+      default:
+        llvm_unreachable("Unexpected metal builtin type!");
+        return nullptr;
+#if 0 // TODO: enable this again when using ro/wo/rw image types
+      case BuiltinType::OCLImage1dRO:
+      case BuiltinType::OCLImage1dWO:
+      case BuiltinType::OCLImage1dRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_1d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage1dArrayRO:
+      case BuiltinType::OCLImage1dArrayWO:
+      case BuiltinType::OCLImage1dArrayRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_1d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage1dBufferRO:
+      case BuiltinType::OCLImage1dBufferWO:
+      case BuiltinType::OCLImage1dBufferRW:
+        llvm_unreachable("Unsupported image type (1D-buffer is not supported by metal)!");
+        return nullptr;
+      case BuiltinType::OCLImage2dRO:
+      case BuiltinType::OCLImage2dWO:
+      case BuiltinType::OCLImage2dRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_2d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayRO:
+      case BuiltinType::OCLImage2dArrayWO:
+      case BuiltinType::OCLImage2dArrayRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_2d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dDepthRO:
+      case BuiltinType::OCLImage2dDepthWO:
+      case BuiltinType::OCLImage2dDepthRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_2d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayDepthRO:
+      case BuiltinType::OCLImage2dArrayDepthWO:
+      case BuiltinType::OCLImage2dArrayDepthRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_2d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dMSAARO:
+      case BuiltinType::OCLImage2dMSAAWO:
+      case BuiltinType::OCLImage2dMSAARW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_2d_ms_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayMSAARO:
+      case BuiltinType::OCLImage2dArrayMSAAWO:
+      case BuiltinType::OCLImage2dArrayMSAARW:
+        llvm_unreachable("Unsupported image type (2D-Array-MSAA is not supported by metal)!");
+        return nullptr;
+      case BuiltinType::OCLImage2dMSAADepthRO:
+      case BuiltinType::OCLImage2dMSAADepthWO:
+      case BuiltinType::OCLImage2dMSAADepthRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_2d_ms_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayMSAADepthRO:
+      case BuiltinType::OCLImage2dArrayMSAADepthWO:
+      case BuiltinType::OCLImage2dArrayMSAADepthRW:
+        llvm_unreachable("Unsupported image type (2D-Array-MSAA-Depth is not supported by metal)!");
+        return nullptr;
+      case BuiltinType::OCLImageCubeRO:
+      case BuiltinType::OCLImageCubeWO:
+      case BuiltinType::OCLImageCubeRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_cube_t"), ImgAddrSpc);
+      case BuiltinType::OCLImageCubeArrayRO:
+      case BuiltinType::OCLImageCubeArrayWO:
+      case BuiltinType::OCLImageCubeArrayRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_cube_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImageCubeDepthRO:
+      case BuiltinType::OCLImageCubeDepthWO:
+      case BuiltinType::OCLImageCubeDepthRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_cube_t"), ImgAddrSpc);
+      case BuiltinType::OCLImageCubeArrayDepthRO:
+      case BuiltinType::OCLImageCubeArrayDepthWO:
+      case BuiltinType::OCLImageCubeArrayDepthRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_cube_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage3dRO:
+      case BuiltinType::OCLImage3dWO:
+      case BuiltinType::OCLImage3dRW:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_3d_t"), ImgAddrSpc);
+#else
+      case BuiltinType::OCLImage1d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_1d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage1dArray:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_1d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage1dBuffer:
+        llvm_unreachable("Unsupported image type (1D-buffer is not supported by metal)!");
+        return nullptr;
+      case BuiltinType::OCLImage2d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_2d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArray:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_2d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dDepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_2d_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayDepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_2d_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dMSAA:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_2d_ms_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayMSAA:
+        llvm_unreachable("Unsupported image type (2D-Array-MSAA is not supported by metal)!");
+        return nullptr;
+      case BuiltinType::OCLImage2dMSAADepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_2d_ms_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage2dArrayMSAADepth:
+        llvm_unreachable("Unsupported image type (2D-Array-MSAA-Depth is not supported by metal)!");
+        return nullptr;
+      case BuiltinType::OCLImageCube:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_cube_t"), ImgAddrSpc);
+      case BuiltinType::OCLImageCubeArray:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_cube_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImageCubeDepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_cube_t"), ImgAddrSpc);
+      case BuiltinType::OCLImageCubeArrayDepth:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._depth_cube_array_t"), ImgAddrSpc);
+      case BuiltinType::OCLImage3d:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._texture_3d_t"), ImgAddrSpc);
+#endif
+      case BuiltinType::OCLSampler:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._sampler_t"),
+                                      CGM.getContext().getTargetAddressSpace(LangAS::opencl_constant));
+      case BuiltinType::OCLEvent:
+        return llvm::PointerType::get(llvm::StructType::create(Ctx, "struct._event_t"), 0);
+    }
+  }
+  llvm_unreachable("Unexpected builtin type!");
+  return nullptr;
 }
 
 llvm::Type *CGOpenCLRuntime::getPipeType() {
-  if (!PipeTy){
+  if (!PipeTy) {
     uint32_t PipeAddrSpc =
       CGM.getContext().getTargetAddressSpace(LangAS::opencl_global);
     PipeTy = llvm::PointerType::get(llvm::StructType::create(
@@ -110,3 +221,87 @@ llvm::Type *CGOpenCLRuntime::getPipeType() {
 
   return PipeTy;
 }
+
+llvm::Type *CGOpenCLRuntime::getBlockType() {
+  if (!BlockTy) {
+    // TODO: correct address space?
+    BlockTy = llvm::PointerType::get(llvm::StructType::create(
+                                     CGM.getLLVMContext(), "opencl.block"), 0);
+  }
+
+  return BlockTy;
+}
+
+llvm::Value *CGOpenCLRuntime::getPipeElemSize(const Expr *PipeArg) {
+  const PipeType* PipeTy = PipeArg->getType()->getAs<PipeType>();
+  // The type of the last (implicit) argument to be passed.
+  llvm::Type *Int32Ty = llvm::IntegerType::getInt32Ty(CGM.getLLVMContext());
+  unsigned TypeSizeInBits = CGM.getContext().getTypeSize(
+                                                      PipeTy->getElementType());
+  return llvm::ConstantInt::get(Int32Ty,
+                                TypeSizeInBits/8, // Size in bytes.
+                                false);
+}
+
+llvm::Value *CGOpenCLRuntime::getPipeElemAlign(const Expr *PipeArg) {
+  const PipeType* PipeTy = PipeArg->getType()->getAs<PipeType>();
+  // The type of the last (implicit) argument to be passed.
+  llvm::Type *Int32Ty = llvm::IntegerType::getInt32Ty(CGM.getLLVMContext());
+  unsigned TypeSizeInBits = CGM.getContext().getTypeAlign(
+                                                      PipeTy->getElementType());
+  return llvm::ConstantInt::get(Int32Ty,
+                                TypeSizeInBits/8, // Size in bytes.
+                                false);
+}
+
+//
+// Ocl20Mangler
+//
+
+Ocl20Mangler::Ocl20Mangler(llvm::SmallVectorImpl<char>& SS): MangledString(&SS) {}
+
+Ocl20Mangler& Ocl20Mangler::appendReservedId() {
+  this->appendString("13ocl_reserveid");
+  return *this;
+}
+
+Ocl20Mangler& Ocl20Mangler::appendPipe() {
+  this->appendString("8ocl_pipe");
+  return *this;
+}
+
+Ocl20Mangler& Ocl20Mangler::appendInt() {
+  MangledString->push_back('i');
+  return *this;
+}
+
+Ocl20Mangler& Ocl20Mangler::appendUint() {
+  MangledString->push_back('j');
+  return *this;
+}
+
+Ocl20Mangler& Ocl20Mangler::appendVoid() {
+  MangledString->push_back('v');
+  return *this;
+}
+
+Ocl20Mangler& Ocl20Mangler::appendPointer() {
+  this->appendString("P");
+  return *this;
+}
+
+Ocl20Mangler& Ocl20Mangler::appendPointer(int addressSpace) {
+  assert(addressSpace >=0 && addressSpace <= 4 &&
+         "Illegal address space for OpenCL");
+  if (!addressSpace)
+    return appendPointer();
+
+  this->appendString("PU3AS");
+  MangledString->push_back('0' + addressSpace);
+  return *this;
+}
+
+Ocl20Mangler& Ocl20Mangler::appendString(llvm::StringRef S) {
+  MangledString->append(S.begin(), S.end());
+  return *this;
+}
diff --git a/lib/CodeGen/CGOpenCLRuntime.h b/lib/CodeGen/CGOpenCLRuntime.h
index f1a7a31..0e791c3 100644
--- a/lib/CodeGen/CGOpenCLRuntime.h
+++ b/lib/CodeGen/CGOpenCLRuntime.h
@@ -33,9 +33,10 @@ class CGOpenCLRuntime {
 protected:
   CodeGenModule &CGM;
   llvm::Type *PipeTy;
+  llvm::Type *BlockTy;
 
 public:
-  CGOpenCLRuntime(CodeGenModule &CGM) : CGM(CGM), PipeTy(nullptr) {}
+  CGOpenCLRuntime(CodeGenModule &CGM) : CGM(CGM), PipeTy(nullptr), BlockTy(nullptr) {}
   virtual ~CGOpenCLRuntime();
 
   /// Emit the IR required for a work-group-local variable declaration, and add
@@ -47,6 +48,53 @@ public:
   virtual llvm::Type *convertOpenCLSpecificType(const Type *T);
 
   virtual llvm::Type *getPipeType();
+
+  virtual llvm::Type *getBlockType();
+
+  // \brief Returnes a value which indicates the size in bytes of the pipe
+  // element.
+  llvm::Value *getPipeElemSize(const Expr *PipeArg);
+  llvm::Value *getPipeElemAlign(const Expr *PipeArg);
+};
+
+class Ocl20Mangler {
+public:
+  Ocl20Mangler(llvm::SmallVectorImpl<char>&);
+
+  // \brief Appends the mangled representation of reserve_id_t parameter to the
+  //  mangled string.
+  Ocl20Mangler& appendReservedId();
+
+  // \brief Appends the mangled representation of pipe_t parameter to the
+  //  mangled string.
+  Ocl20Mangler& appendPipe();
+
+  // \brief Appends the mangled representation of 'int' parameter to the
+  //  mangled string.
+  Ocl20Mangler& appendInt();
+
+  // \brief Appends the mangled representation of 'unsigned int' parameter to the
+  // mangled string.
+  Ocl20Mangler& appendUint();
+
+  // \brief Appends the mangled representation of a pointer.
+  Ocl20Mangler& appendPointer();
+
+  // \brief Appends the mangled representation of void.
+  Ocl20Mangler& appendVoid();
+
+  // \brief Appends the mangled representation of a pointer with a given address
+  // space.
+  // \param addressSapace The address space of the pointer. Valid values are
+  // [0,4].
+  Ocl20Mangler& appendPointer(int addressSapace);
+
+private:
+
+  // \brief Appends the given string to the mangled prototype.
+  Ocl20Mangler& appendString(llvm::StringRef);
+
+  llvm::SmallVectorImpl<char> *MangledString;
 };
 
 }
diff --git a/lib/CodeGen/CGRecordLayoutBuilder.cpp b/lib/CodeGen/CGRecordLayoutBuilder.cpp
index 375b59c..80fd250 100644
--- a/lib/CodeGen/CGRecordLayoutBuilder.cpp
+++ b/lib/CodeGen/CGRecordLayoutBuilder.cpp
@@ -812,6 +812,42 @@ CGRecordLayout *CodeGenTypes::ComputeRecordLayout(const RecordDecl *D,
   return RL;
 }
 
+void CodeGenTypes::create_flattened_cg_layout(const CXXRecordDecl* D, llvm::StructType* Ty,
+											  const std::vector<CodeGenTypes::aggregate_scalar_entry>& fields) {
+	bool zero_init = true;
+	for(const auto& field : fields) {
+		// vector types (or replaced vector types) are always zero initializable
+		if(field.type->isExtVectorType() ||
+		   field.type->isVectorType()) {
+			continue;
+		}
+		
+		// else: need to make some calls based on the field decl type
+		const Type *Type = field.field_decl->getType()->getBaseElementTypeUnsafe();
+		if (const MemberPointerType *MPT = Type->getAs<MemberPointerType>()) {
+			if(!TheCXXABI.isZeroInitializable(MPT)) {
+				zero_init = false;
+				break;
+			}
+		}
+		else if (const CXXRecordDecl* cxx_rdecl = Type->getAsCXXRecordDecl()) {
+			if(!isZeroInitializable(cxx_rdecl)) {
+				zero_init = false;
+				break;
+			}
+		}
+		// else: it is zero initializable
+	}
+	
+	CGRecordLayout *RL = new CGRecordLayout(Ty, Ty, zero_init, zero_init);
+	uint32_t field_idx = 0;
+	for(const auto& field : fields) {
+		RL->FieldInfo.insert({ field.field_decl, field_idx++ });
+	}
+	
+	FlattenedCGRecordLayouts.insert({ Ty, RL });
+}
+
 void CGRecordLayout::print(raw_ostream &OS) const {
   OS << "<CGRecordLayout\n";
   OS << "  LLVMType:" << *CompleteObjectType << "\n";
diff --git a/lib/CodeGen/CGSPIRMetadataAdder.cpp b/lib/CodeGen/CGSPIRMetadataAdder.cpp
new file mode 100644
index 0000000..8e96cca
--- /dev/null
+++ b/lib/CodeGen/CGSPIRMetadataAdder.cpp
@@ -0,0 +1,316 @@
+//===- SPIRMetadataAdder.cpp - Add SPIR related module scope metadata -----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//===----------------------------------------------------------------------===//
+
+
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SmallString.h"
+#include "llvm/Transforms/IPO.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/Type.h"
+#include "llvm/IR/TypeFinder.h"
+#include "CGSPIRMetadataAdder.h"
+#include <set>
+
+using namespace llvm;
+using namespace clang;
+using namespace CodeGen;
+
+static const char *ImageTypeNames[] = {
+  "opencl.image1d_t", "opencl.image1d_array_t", "opencl.image1d_buffer_t",
+  "opencl.image2d_t", "opencl.image2d_array_t",
+  "opencl.image2d_depth_t", "opencl.image2d_array_depth_t",
+  "opencl.image2d_msaa_t", "opencl.image2d_array_msaa_t",
+  "opencl.image2d_msaa_depth_t", "opencl.image2d_array_msaa_depth_t",
+  "opencl.image3d_t"
+};
+
+static const char *ImageDepthTypeNames[] = {
+  "opencl.image2d_depth_t", "opencl.image2d_array_depth_t"
+};
+
+static const char *ImageMSAATypeNames[] = {
+  "opencl.image2d_msaa_t", "opencl.image2d_array_msaa_t",
+  "opencl.image2d_msaa_depth_t", "opencl.image2d_array_msaa_depth_t"
+};
+
+struct OCLExtensionsTy {
+#define OPENCLEXT(nm)  unsigned _##nm : 1;
+#include "clang/Basic/OpenCLExtensions.def"
+
+  OCLExtensionsTy() {
+#define OPENCLEXT(nm)   _##nm = 0;
+#include "clang/Basic/OpenCLExtensions.def"
+  }
+};
+
+typedef void (*func_call_handler)(CallInst *callInstr, OCLExtensionsTy &exts);
+
+void baseAtomics64(CallInst *callInstr, OCLExtensionsTy &exts) {
+  PointerType *firstArgType = dyn_cast<PointerType>(callInstr->getArgOperand(0)->getType());
+
+  if (firstArgType &&
+      firstArgType->getPointerElementType()->isIntegerTy() &&
+      firstArgType->getPointerElementType()->getScalarSizeInBits() == 64)
+    exts._cl_khr_int64_base_atomics = 1;
+}
+
+void extAtomics64(CallInst *callInstr, OCLExtensionsTy &exts) {
+  PointerType *firstArgType = dyn_cast<PointerType>(callInstr->getArgOperand(0)->getType());
+
+  if (firstArgType &&
+      firstArgType->getPointerElementType()->isIntegerTy() &&
+      firstArgType->getPointerElementType()->getScalarSizeInBits() == 64)
+    exts._cl_khr_int64_extended_atomics = 1;
+}
+
+void image3DWrite(CallInst *callInstr, OCLExtensionsTy &exts) {
+  PointerType *firstArgType = dyn_cast<PointerType>(callInstr->getArgOperand(0)->getType());
+
+  if (firstArgType &&
+      firstArgType->getPointerElementType()->isStructTy() &&
+      !firstArgType->getPointerElementType()->getStructName().compare("opencl.image3d_t"))
+    exts._cl_khr_3d_image_writes = 1;
+}
+
+typedef struct {
+  const char *funcName;
+  func_call_handler handler;
+} funcCallHandlersTy;
+
+static const funcCallHandlersTy funcCallHandlers[] = {
+  {"_Z8atom_add", baseAtomics64},
+  {"_Z8atom_sub", baseAtomics64},
+  {"_Z9atom_xchg", baseAtomics64},
+  {"_Z8atom_inc", baseAtomics64},
+  {"_Z8atom_dec", baseAtomics64},
+  {"_Z12atom_cmpxchg", baseAtomics64},
+  {"_Z8atom_min", extAtomics64},
+  {"_Z8atom_max", extAtomics64},
+  {"_Z8atom_and", extAtomics64},
+  {"_Z7atom_or", extAtomics64},
+  {"_Z8atom_xor", extAtomics64},
+  {"_Z12write_imagef", image3DWrite},
+  {"_Z12write_imagei", image3DWrite},
+  {"_Z13write_imageui", image3DWrite}
+};
+
+static bool searchTypeInType (llvm::Type *ty1, llvm::Type *ty2, bool ignorePtrs);
+
+static bool searchTypeInType (llvm::Type *ty1, llvm::Type *ty2, bool ignorePtrs, std::set<llvm::Type*> &typesList) {
+  if (ty1 == ty2)
+    return true;
+
+  if (ty1->isVectorTy())
+    return searchTypeInType(ty1->getVectorElementType(), ty2, ignorePtrs, typesList);
+
+  if (ty1->isArrayTy())
+    return searchTypeInType(ty1->getArrayElementType(), ty2, ignorePtrs, typesList);
+
+  if (!ignorePtrs && ty1->isPointerTy()) {
+    // prevent infinte loop (such a struct that conatinc pointer to itself)
+    std::set<llvm::Type*>::iterator itr = typesList.find(ty1->getPointerElementType());
+    if ( itr != typesList.end() ) {
+      return false;
+    }
+    return searchTypeInType(ty1->getPointerElementType(), ty2, ignorePtrs, typesList);
+  }
+
+  if (ty1->isStructTy()) {
+    typesList.insert( ty1 );
+    llvm::StructType *strTy = dyn_cast<llvm::StructType>(ty1);
+
+    for (StructType::element_iterator EI = strTy->element_begin(),
+         EE = strTy->element_end(); EI != EE; ++EI)
+      if (searchTypeInType((*EI), ty2, ignorePtrs, typesList))
+        return true;
+  }
+
+  if (ty1->isFunctionTy()) {
+    typesList.insert( ty1 );
+    FunctionType *FuncTy = dyn_cast<llvm::FunctionType>(ty1);
+
+    if (searchTypeInType(FuncTy->getReturnType(), ty2, ignorePtrs))
+      return true;
+
+    for (FunctionType::param_iterator PI = FuncTy->param_begin(),
+         PE = FuncTy->param_end(); PI != PE; ++PI)
+      if (searchTypeInType((*PI), ty2, ignorePtrs))
+        return true;
+  }
+
+  return false;
+}
+
+static bool searchTypeInType (llvm::Type *ty1, llvm::Type *ty2, bool ignorePtrs) {
+  std::set<llvm::Type*> typesList;
+  return searchTypeInType( ty1, ty2, ignorePtrs, typesList);
+}
+
+static void FunctionAddSPIRMetadata(Function &F, bool &bUseDoubles, OCLExtensionsTy &sUsedExts);
+
+void clang::CodeGen::AddSPIRMetadata(Module &M, int OCLVersion, std::list<std::string> sBuildOptions, const OpenCLOptions& cl_options) {
+  Type *pDoubleType = Type::getDoubleTy(M.getContext());
+  Type *pHalfType = Type::getHalfTy(M.getContext());
+
+  OCLExtensionsTy sUsedExts;
+
+  bool bUseDoubles = false;
+  bool bUseImages  = false;
+
+  for (Module::global_iterator GI = M.global_begin(), GE = M.global_end();
+       GI != GE; ++GI) {
+    if (searchTypeInType(GI->getType(), pDoubleType, false))
+      bUseDoubles = true;
+    if (searchTypeInType(GI->getType(), pHalfType, true))
+      sUsedExts._cl_khr_fp16 = true;
+  }
+
+  //check if image types are defined
+  for (size_t i = 0; i < sizeof(ImageTypeNames)/sizeof(ImageTypeNames[0]); i++) {
+    if (M.getTypeByName(ImageTypeNames[i])) {
+      bUseImages = true;
+      break;
+    }
+  }
+
+  //check if depth image types are defined
+  for (size_t i = 0; i < sizeof(ImageDepthTypeNames)/sizeof(ImageDepthTypeNames[0]); i++) {
+    if (M.getTypeByName(ImageDepthTypeNames[i])) {
+      sUsedExts._cl_khr_depth_images = true;
+      break;
+    }
+  }
+
+  //check if msaa image types are defined
+  for (size_t i = 0; i < sizeof(ImageMSAATypeNames)/sizeof(ImageMSAATypeNames[0]); i++) {
+    if (M.getTypeByName(ImageMSAATypeNames[i])) {
+      sUsedExts._cl_khr_gl_msaa_sharing = true;
+      break;
+    }
+  }
+
+  // scan all functions
+  for (Module::iterator FI = M.begin(), FE = M.end();
+       FI != FE; ++FI) {
+    FunctionAddSPIRMetadata(*FI, bUseDoubles, sUsedExts);
+  }
+
+  // enable/add explicitly enabled pragma extensions
+#define OPENCLEXT(nm) if (cl_options.nm) sUsedExts._##nm = true;
+#include "clang/Basic/OpenCLExtensions.def"
+
+  // Add SPIR version (1.2)
+  llvm::Metadata *SPIRVerElts[] = {
+    llvm::ConstantAsMetadata::get(ConstantInt::get(Type::getInt32Ty(M.getContext()), 1)),
+    llvm::ConstantAsMetadata::get(ConstantInt::get(Type::getInt32Ty(M.getContext()), 2))
+  };
+  llvm::NamedMDNode *SPIRVerMD =
+    M.getOrInsertNamedMetadata("opencl.spir.version");
+  SPIRVerMD->addOperand(llvm::MDNode::get(M.getContext(), SPIRVerElts));
+
+  // Add OpenCL version
+  llvm::Metadata *OCLVerElts[] = {
+    llvm::ConstantAsMetadata::get(ConstantInt::get(Type::getInt32Ty(M.getContext()), OCLVersion / 100)),
+    llvm::ConstantAsMetadata::get(ConstantInt::get(Type::getInt32Ty(M.getContext()), (OCLVersion % 100) / 10))
+  };
+  llvm::NamedMDNode *OCLVerMD =
+    M.getOrInsertNamedMetadata("opencl.ocl.version");
+  OCLVerMD->addOperand(llvm::MDNode::get(M.getContext(), OCLVerElts));
+
+  // Add used extensions
+  llvm::SmallVector<llvm::Metadata*, 5> OCLExtElts;
+
+#define OPENCLEXT(nm)  if (sUsedExts._##nm) \
+  OCLExtElts.push_back(llvm::MDString::get(M.getContext(), #nm));
+#include "clang/Basic/OpenCLExtensions.def"
+
+  llvm::NamedMDNode *OCLExtMD =
+    M.getOrInsertNamedMetadata("opencl.used.extensions");
+
+  OCLExtMD->addOperand(llvm::MDNode::get(M.getContext(), OCLExtElts));
+
+  // Add used optional core features
+  llvm::SmallVector<llvm::Metadata*, 5> OCLOptCoreElts;
+
+  // TODO: flag for this?
+  if (bUseDoubles)
+    OCLOptCoreElts.push_back(llvm::MDString::get(M.getContext(), "cl_doubles"));
+
+  if (bUseImages)
+    OCLOptCoreElts.push_back(llvm::MDString::get(M.getContext(), "cl_images"));
+
+  llvm::NamedMDNode *OptCoreMD =
+    M.getOrInsertNamedMetadata("opencl.used.optional.core.features");
+  OptCoreMD->addOperand(llvm::MDNode::get(M.getContext(), OCLOptCoreElts));
+
+  // Add build options
+  llvm::NamedMDNode *OCLCompOptsMD =
+    M.getOrInsertNamedMetadata("opencl.compiler.options");
+      llvm::SmallVector<llvm::Metadata*,5> OCLBuildOptions;
+  // TODO: should probably parse clang args, -cl-spir-compile-options doesn't seem to work?
+  sBuildOptions.push_back("-cl-kernel-arg-info");
+  sBuildOptions.push_back("-cl-mad-enable");
+  sBuildOptions.push_back("-cl-denorms-are-zero");
+  sBuildOptions.push_back("-cl-unsafe-math-optimizations");
+  for (std::list<std::string>::const_iterator it = sBuildOptions.begin(),
+       e = sBuildOptions.end(); it != e ; ++it) {
+    OCLBuildOptions.push_back(llvm::MDString::get(M.getContext(), *it));
+  }
+  OCLCompOptsMD->addOperand(llvm::MDNode::get(M.getContext(), OCLBuildOptions));
+}
+
+static void FunctionAddSPIRMetadata(Function &F, bool &bUseDoubles, OCLExtensionsTy &sUsedExts) {
+  Type *pDoubleType = Type::getDoubleTy(F.getParent()->getContext());
+  Type *pHalfType = Type::getHalfTy(F.getParent()->getContext());
+
+  for (Function::arg_iterator AI = F.arg_begin(), AE = F.arg_end();
+       AI != AE; ++AI) {
+    if (searchTypeInType(AI->getType(), pDoubleType, false))
+      bUseDoubles = true;
+    if (searchTypeInType(AI->getType(), pHalfType, true))
+      sUsedExts._cl_khr_fp16 = true;
+  }
+
+  for (Function::iterator BB = F.begin(), E = F.end(); BB != E; ++BB)
+    for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ++I) {
+      if (searchTypeInType(I->getType(), pDoubleType, false))
+        if (!(dyn_cast<FPExtInst>(I)))
+          bUseDoubles = true;
+      if (searchTypeInType(I->getType(), pHalfType, true))
+        sUsedExts._cl_khr_fp16 = true;
+
+      for (Instruction::op_iterator OI = (*I).op_begin(), OE = (*I).op_end();
+           OI != OE; ++OI) {
+        if (searchTypeInType((*OI)->getType(), pDoubleType, false))
+          if (!(dyn_cast<CallInst>(I) &&
+                dyn_cast<CallInst>(I)->getCalledFunction() &&
+                dyn_cast<CallInst>(I)->getCalledFunction()->isVarArg()))
+            bUseDoubles = true;
+        if (searchTypeInType((*OI)->getType(), pHalfType, true))
+          sUsedExts._cl_khr_fp16 = true;
+      }
+
+      CallInst* pCallInst = dyn_cast<CallInst>(I);
+      if (pCallInst && pCallInst->getCalledFunction()) {
+        std::string funcName = pCallInst->getCalledFunction()->getName().str();
+
+        for (size_t i = 0; i < sizeof(funcCallHandlers)/sizeof(funcCallHandlers[0]); i++) {
+          if (funcName.find(funcCallHandlers[i].funcName) == 0)
+            funcCallHandlers[i].handler(pCallInst, sUsedExts);
+        }
+      }
+    }
+}
diff --git a/lib/CodeGen/CGSPIRMetadataAdder.h b/lib/CodeGen/CGSPIRMetadataAdder.h
new file mode 100644
index 0000000..863ee98
--- /dev/null
+++ b/lib/CodeGen/CGSPIRMetadataAdder.h
@@ -0,0 +1,29 @@
+//===- SPIRMetadataAdder.h - Add SPIR related module scope metadata -------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/IR/Module.h"
+#include "clang/Basic/LangOptions.h"
+#include <list>
+#include <string>
+
+#ifndef CLANG_CODEGEN_SPIRMETADATAADDER_H
+#define CLANG_CODEGEN_SPIRMETADATAADDER_H
+
+namespace clang {
+
+namespace CodeGen {
+
+  void AddSPIRMetadata(llvm::Module &M, int OCLVersion, std::list<std::string> sBuildOptions, const OpenCLOptions& cl_options);
+
+} // end namespace CodeGen
+} // end namespace clang
+#endif
diff --git a/lib/CodeGen/CMakeLists.txt b/lib/CodeGen/CMakeLists.txt
index 10bda76..d2992e2 100644
--- a/lib/CodeGen/CMakeLists.txt
+++ b/lib/CodeGen/CMakeLists.txt
@@ -2,6 +2,8 @@ set(LLVM_LINK_COMPONENTS
   Analysis
   BitReader
   BitWriter
+  BitWriter32
+  BitWriter35
   Core
   IPO
   IRReader
@@ -13,6 +15,7 @@ set(LLVM_LINK_COMPONENTS
   Object
   ProfileData
   ScalarOpts
+  SPIRVlib
   Support
   Target
   TransformUtils
@@ -57,6 +60,7 @@ add_clang_library(clangCodeGen
   CGOpenCLRuntime.cpp
   CGOpenMPRuntime.cpp
   CGRecordLayoutBuilder.cpp
+  CGSPIRMetadataAdder.cpp
   CGStmt.cpp
   CGStmtOpenMP.cpp
   CGVTT.cpp
diff --git a/lib/CodeGen/CodeGenAction.cpp b/lib/CodeGen/CodeGenAction.cpp
index 0a670ab..2f18243 100644
--- a/lib/CodeGen/CodeGenAction.cpp
+++ b/lib/CodeGen/CodeGenAction.cpp
@@ -665,7 +665,11 @@ GetOutputStream(CompilerInstance &CI, StringRef InFile, BackendAction Action) {
   case Backend_EmitLL:
     return CI.createDefaultOutputFile(false, InFile, "ll");
   case Backend_EmitBC:
+  case Backend_EmitBC32:
+  case Backend_EmitBC35:
     return CI.createDefaultOutputFile(true, InFile, "bc");
+  case Backend_EmitSPIRV:
+    return CI.createDefaultOutputFile(true, InFile, "spv");
   case Backend_EmitNothing:
     return nullptr;
   case Backend_EmitMCNull:
@@ -801,6 +805,18 @@ void EmitBCAction::anchor() { }
 EmitBCAction::EmitBCAction(llvm::LLVMContext *_VMContext)
   : CodeGenAction(Backend_EmitBC, _VMContext) {}
 
+void EmitBC32Action::anchor() { }
+EmitBC32Action::EmitBC32Action(llvm::LLVMContext *_VMContext)
+  : CodeGenAction(Backend_EmitBC32, _VMContext) {}
+
+void EmitBC35Action::anchor() { }
+EmitBC35Action::EmitBC35Action(llvm::LLVMContext *_VMContext)
+  : CodeGenAction(Backend_EmitBC35, _VMContext) {}
+
+void EmitSPIRVAction::anchor() { }
+EmitSPIRVAction::EmitSPIRVAction(llvm::LLVMContext *_VMContext)
+  : CodeGenAction(Backend_EmitSPIRV, _VMContext) {}
+
 void EmitLLVMAction::anchor() { }
 EmitLLVMAction::EmitLLVMAction(llvm::LLVMContext *_VMContext)
   : CodeGenAction(Backend_EmitLL, _VMContext) {}
diff --git a/lib/CodeGen/CodeGenFunction.cpp b/lib/CodeGen/CodeGenFunction.cpp
index e38ff0a..2475dc7 100644
--- a/lib/CodeGen/CodeGenFunction.cpp
+++ b/lib/CodeGen/CodeGenFunction.cpp
@@ -34,6 +34,9 @@
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/MDBuilder.h"
 #include "llvm/IR/Operator.h"
+#include <sstream>
+#include <unordered_set>
+#include <fstream>
 using namespace clang;
 using namespace CodeGen;
 
@@ -429,6 +432,149 @@ void CodeGenFunction::EmitMCountInstrumentation() {
   EmitNounwindRuntimeCall(MCountFn);
 }
 
+// will recurse through the specified class/struct decl and its base classes,
+// returning a vector containing all iterators to all contained fields
+static std::vector<RecordDecl::field_iterator> get_aggregate_fields(const CXXRecordDecl* decl) {
+	if(decl == nullptr) return {};
+	
+	// must have definition
+	if(!decl->hasDefinition()) return {};
+	
+	//
+	std::vector<RecordDecl::field_iterator> ret;
+	
+	// iterate over / recurse into all bases
+	for(const auto& base : decl->bases()) {
+		const auto base_ret = get_aggregate_fields(base.getType()->getAsCXXRecordDecl());
+		if(!base_ret.empty()) {
+			ret.insert(ret.end(), base_ret.begin(), base_ret.end());
+		}
+	}
+	
+	// iterate over all fields/members
+	for(auto iter = decl->field_begin(); iter != decl->field_end(); ++iter) {
+		ret.push_back(iter);
+	}
+	
+	return ret;
+}
+
+// will recurse through the specified class/struct decl and its base classes,
+// returning a vector containing all iterators to all contained image types
+// NOTE: will return an empty vector if not a proper aggregate image
+static std::vector<RecordDecl::field_iterator> get_aggregate_image_fields(const CXXRecordDecl* decl) {
+	// extract all fields, then check if all are image types (if one isn't, fail)
+	const auto ret = get_aggregate_fields(decl);
+	for(const auto& iter : ret) {
+		if(!iter->getType()->isImageType()) {
+			return {};
+		}
+	}
+	return ret;
+}
+
+// will recurse through the specified class/struct decl and its base classes,
+// returning the first image access attribute that it encounters (or nullptr if none)
+static const ImageAccessAttr* get_aggregate_access_attr(const CXXRecordDecl* decl) {
+	if(decl == nullptr) return nullptr;
+	
+	// must have definition
+	if(!decl->hasDefinition()) return nullptr;
+	
+	// iterate over / recurse into all bases
+	for(const auto& base : decl->bases()) {
+		const auto base_ret = get_aggregate_access_attr(base.getTypeSourceInfo()->getType()->getAsCXXRecordDecl());
+		if(base_ret != nullptr) {
+			return base_ret;
+		}
+	}
+	
+	// iterate over all fields/members and return the first access attr
+	for(auto iter = decl->field_begin(); iter != decl->field_end(); ++iter) {
+		// try direct attr first
+		const ImageAccessAttr* access_attr = iter->getAttr<ImageAccessAttr>();
+		if(access_attr != nullptr) {
+			return access_attr;
+		}
+		
+		// then check if this is a c++ decl (struct/union/class) and check if it has the attr
+		const auto as_decl = iter->getType()->getAsCXXRecordDecl();
+		if(as_decl != nullptr) {
+			access_attr = as_decl->getAttr<ImageAccessAttr>();
+			if(access_attr != nullptr) {
+				return access_attr;
+			}
+		}
+	}
+	
+	return nullptr;
+}
+
+
+// Metadata values extractors.
+static std::string getScalarMetadataValue(const clang::Type *Ty,
+										  const PrintingPolicy &Policy) {
+	assert(Ty && "NULL type");
+
+	if (Ty->isHalfType()) return "half";
+	
+	if (!Ty->isUnsignedIntegerType()) {
+		return QualType(Ty, 0).getAsString(Policy);
+	}
+	
+	std::string TyName = QualType(Ty, 0).getAsString();
+	if (llvm::StringRef(TyName).startswith("unsigned")) {
+		// Replace unsigned <ty> with u<ty>
+		TyName.erase(1, 8);
+	}
+	
+	return TyName;
+}
+static std::string getVectorMetadataValue(const clang::ExtVectorType *Ty,
+										  const PrintingPolicy &Policy) {
+	assert(Ty && "NULL type");
+
+	const clang::VectorType *VTy = llvm::dyn_cast<clang::VectorType>(Ty);
+	assert(VTy && "Cast to vector failed");
+	
+	std::stringstream Ret;
+	Ret << getScalarMetadataValue(VTy->getElementType().getTypePtr(), Policy);
+	Ret << VTy->getNumElements();
+	
+	return Ret.str();
+}
+
+// Returns true if the given module has SPIR (32/64) target
+static bool isSpirTarget(const llvm::Module *M) {
+  assert (M && "NULL module given");
+  return llvm::StringRef(M->getTargetTriple()).startswith("spir");
+}
+
+static std::string getPipeMetadataValue(const clang::PipeType *Ty,
+                                        const PrintingPolicy &Policy) {
+  assert(Ty && "Null type");
+
+  const clang::QualType ElemTy = Ty->getElementType();
+  if (const clang::ExtVectorType *VTy = ElemTy->getAs<ExtVectorType>())
+    return getVectorMetadataValue(VTy, Policy);
+
+  return getScalarMetadataValue(ElemTy.getTypePtr(), Policy);
+}
+
+// NOTE/TODO: unused for now, until pipe metadata generation works correctly
+/*static llvm::MDString *getAccessAttribute(const ParmVarDecl *PDecl,
+                                          llvm::LLVMContext &Context) {
+  if (PDecl->hasAttr<ImageAccessAttr>() &&
+    PDecl->getAttr<ImageAccessAttr>()->isWriteOnly())
+    return llvm::MDString::get(Context, "write_only");
+
+  if (PDecl->hasAttr<ImageAccessAttr>() &&
+    PDecl->getAttr<ImageAccessAttr>()->isReadWrite())
+    return llvm::MDString::get(Context, "read_write");
+
+  return llvm::MDString::get(Context, "read_only");
+}*/
+
 // OpenCL v1.2 s5.6.4.6 allows the compiler to store kernel argument
 // information in the program executable. The argument information stored
 // includes the argument name, its type, the address and access qualifiers used.
@@ -436,183 +582,1456 @@ static void GenOpenCLArgMetadata(const FunctionDecl *FD, llvm::Function *Fn,
                                  CodeGenModule &CGM, llvm::LLVMContext &Context,
                                  SmallVector<llvm::Metadata *, 5> &kernelMDArgs,
                                  CGBuilderTy &Builder, ASTContext &ASTCtx) {
-  // Create MDNodes that represent the kernel arg metadata.
-  // Each MDNode is a list in the form of "key", N number of values which is
-  // the same number of values as their are kernel arguments.
-
-  const PrintingPolicy &Policy = ASTCtx.getPrintingPolicy();
-
-  // MDNode for the kernel argument address space qualifiers.
-  SmallVector<llvm::Metadata *, 8> addressQuals;
-  addressQuals.push_back(llvm::MDString::get(Context, "kernel_arg_addr_space"));
-
-  // MDNode for the kernel argument access qualifiers (images only).
-  SmallVector<llvm::Metadata *, 8> accessQuals;
-  accessQuals.push_back(llvm::MDString::get(Context, "kernel_arg_access_qual"));
-
-  // MDNode for the kernel argument type names.
-  SmallVector<llvm::Metadata *, 8> argTypeNames;
-  argTypeNames.push_back(llvm::MDString::get(Context, "kernel_arg_type"));
-
-  // MDNode for the kernel argument base type names.
-  SmallVector<llvm::Metadata *, 8> argBaseTypeNames;
-  argBaseTypeNames.push_back(
-      llvm::MDString::get(Context, "kernel_arg_base_type"));
-
-  // MDNode for the kernel argument type qualifiers.
-  SmallVector<llvm::Metadata *, 8> argTypeQuals;
-  argTypeQuals.push_back(llvm::MDString::get(Context, "kernel_arg_type_qual"));
-
-  // MDNode for the kernel argument names.
-  SmallVector<llvm::Metadata *, 8> argNames;
-  argNames.push_back(llvm::MDString::get(Context, "kernel_arg_name"));
-
-  for (unsigned i = 0, e = FD->getNumParams(); i != e; ++i) {
-    const ParmVarDecl *parm = FD->getParamDecl(i);
-    QualType ty = parm->getType();
-    std::string typeQuals;
-
-    if (ty->isPointerType()) {
-      QualType pointeeTy = ty->getPointeeType();
-
-      // Get address qualifier.
-      addressQuals.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(
-          ASTCtx.getTargetAddressSpace(pointeeTy.getAddressSpace()))));
-
-      // Get argument type name.
-      std::string typeName =
-          pointeeTy.getUnqualifiedType().getAsString(Policy) + "*";
-
-      // Turn "unsigned type" to "utype"
-      std::string::size_type pos = typeName.find("unsigned");
-      if (pointeeTy.isCanonical() && pos != std::string::npos)
-        typeName.erase(pos+1, 8);
-
-      argTypeNames.push_back(llvm::MDString::get(Context, typeName));
-
-      std::string baseTypeName =
-          pointeeTy.getUnqualifiedType().getCanonicalType().getAsString(
-              Policy) +
-          "*";
-
-      // Turn "unsigned type" to "utype"
-      pos = baseTypeName.find("unsigned");
-      if (pos != std::string::npos)
-        baseTypeName.erase(pos+1, 8);
-
-      argBaseTypeNames.push_back(llvm::MDString::get(Context, baseTypeName));
-
-      // Get argument type qualifiers:
-      if (ty.isRestrictQualified())
-        typeQuals = "restrict";
-      if (pointeeTy.isConstQualified() ||
-          (pointeeTy.getAddressSpace() == LangAS::opencl_constant))
-        typeQuals += typeQuals.empty() ? "const" : " const";
-      if (pointeeTy.isVolatileQualified())
-        typeQuals += typeQuals.empty() ? "volatile" : " volatile";
-    } else {
-      uint32_t AddrSpc = 0;
-      bool isPipe = ty->isPipeType();
-      if (ty->isImageType() || isPipe)
-        AddrSpc =
-          CGM.getContext().getTargetAddressSpace(LangAS::opencl_global);
-
-      addressQuals.push_back(
-          llvm::ConstantAsMetadata::get(Builder.getInt32(AddrSpc)));
-
-      // Get argument type name.
-      std::string typeName;
-      if (isPipe)
-        typeName = cast<PipeType>(ty)->getElementType().getAsString(Policy);
-      else
-        typeName = ty.getUnqualifiedType().getAsString(Policy);
-
-      // Turn "unsigned type" to "utype"
-      std::string::size_type pos = typeName.find("unsigned");
-      if (ty.isCanonical() && pos != std::string::npos)
-        typeName.erase(pos+1, 8);
-
-      argTypeNames.push_back(llvm::MDString::get(Context, typeName));
-
-      std::string baseTypeName;
-      if (isPipe)
-        baseTypeName =
-          cast<PipeType>(ty)->getElementType().getCanonicalType().getAsString(Policy);
-      else
-        baseTypeName =
-          ty.getUnqualifiedType().getCanonicalType().getAsString(Policy);
-
-      // Turn "unsigned type" to "utype"
-      pos = baseTypeName.find("unsigned");
-      if (pos != std::string::npos)
-        baseTypeName.erase(pos+1, 8);
-
-      argBaseTypeNames.push_back(llvm::MDString::get(Context, baseTypeName));
-
-      // Get argument type qualifiers:
-      if (ty.isConstQualified())
-        typeQuals = "const";
-      if (ty.isVolatileQualified())
-        typeQuals += typeQuals.empty() ? "volatile" : " volatile";
-      if (isPipe)
-        typeQuals = "pipe";
-    }
+	// Create MDNodes that represent the kernel arg metadata.
+	// Each MDNode is a list in the form of "key", N number of values which is
+	// the same number of values as their are kernel arguments.
+
+	const bool EmitVerbose = CGM.getCodeGenOpts().EmitOpenCLArgMetadata;
+
+	if (!isSpirTarget(Fn->getParent()) && !EmitVerbose) {
+		return;
+	}
+	
+	// MDNode for the kernel argument address space qualifiers.
+	SmallVector<llvm::Metadata*, 8> addressQuals;
+	addressQuals.push_back(llvm::MDString::get(Context, "kernel_arg_addr_space"));
+	
+	// MDNode for the kernel argument access qualifiers (images only).
+	SmallVector<llvm::Metadata*, 8> accessQuals;
+	accessQuals.push_back(llvm::MDString::get(Context, "kernel_arg_access_qual"));
+	
+	// MDNode for the kernel argument type names.
+	SmallVector<llvm::Metadata*, 8> argTypeNames;
+	argTypeNames.push_back(llvm::MDString::get(Context, "kernel_arg_type"));
+	
+	// MDNode for the kernel argument base type names.
+	SmallVector<llvm::Metadata*, 8> argBaseTypeNames;
+	argBaseTypeNames.push_back(llvm::MDString::get(Context, "kernel_arg_base_type"));
+	
+	// MDNode for the kernel argument type qualifiers.
+	SmallVector<llvm::Metadata*, 8> argTypeQuals;
+	argTypeQuals.push_back(llvm::MDString::get(Context, "kernel_arg_type_qual"));
+	
+	// MDNode for the kernel argument names.
+	SmallVector<llvm::Metadata*, 8> argNames;
+	if (EmitVerbose) {
+		argNames.push_back(llvm::MDString::get(Context, "kernel_arg_name"));
+	}
+	// TODO: proper handling of EmitVerbose + kernel arg names
+	
+	const PrintingPolicy &Policy = ASTCtx.getPrintingPolicy();
+	
+	// Creates a canonical name for complex types. In case of anonymous types, the
+	// function appends the meta-type name as prefix: e.g., in case the type is
+	// defined as: typedef struct {...} S, the method returns struct S.
+	static const auto canonicalName = [](const std::string &TyName,
+										 const std::string &MetaTyName) {
+		if (StringRef(TyName).startswith(MetaTyName)) {
+			return TyName;
+		}
+		
+		return std::string(MetaTyName) + " __" + TyName;
+	};
+	
+	static const auto getComplexMetadataValue = [](const clang::Type *Ty,
+												   const PrintingPolicy &Policy) {
+		std::string TyName = QualType(Ty, 0).getCanonicalType().getAsString();
+		
+		if (Ty->isStructureOrClassType()) {
+			return canonicalName(TyName, "struct");
+		}
+		
+		if (Ty->isUnionType()) {
+			return canonicalName(TyName, "union");
+		}
+		
+		if (Ty->isEnumeralType()) {
+			return canonicalName(TyName, "enum");
+		}
+		
+		return getScalarMetadataValue(Ty, Policy);
+	};
+	
+	static const auto getPointerOrRefMetadataValue = [](const clang::Type *PTy,
+														bool CanTy,
+														const PrintingPolicy &Policy) {
+		assert(PTy && "Null type");
+		
+		std::string Ret;
+		
+		if (const ExtVectorType *VTy = llvm::dyn_cast<ExtVectorType>(PTy)) {
+			Ret = getVectorMetadataValue(VTy, Policy);
+		}
+		else {
+			Ret = CanTy ? getComplexMetadataValue(PTy, Policy) : getScalarMetadataValue(PTy, Policy);
+		}
+		
+		return Ret + "*";
+	};
+	
+	const auto add_image_arg = [&Builder, &Context, &CGM, &Policy,
+								&addressQuals, &accessQuals, &argTypeNames, &argBaseTypeNames,
+								&argNames, &argTypeQuals](const clang::QualType& type,
+														  const ImageAccessAttr* access_attr,
+														  const std::string& name) {
+		// image is always in global address space
+		addressQuals.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(CGM.getContext().getTargetAddressSpace(LangAS::opencl_global))));
+		
+		// set access qualifier
+		if (access_attr && access_attr->isWriteOnly()) {
+			accessQuals.push_back(llvm::MDString::get(Context, "write_only"));
+		}
+		else if (access_attr && access_attr->isReadWrite()) {
+			accessQuals.push_back(llvm::MDString::get(Context, "read_write"));
+		}
+		else {
+			accessQuals.push_back(llvm::MDString::get(Context, "read_only"));
+		}
+		
+		// image type / base type
+		// NOTE: always set base type, because types in image aggregates might be "weird", but should be considered normal
+		const QualType baseTy = type.isCanonical() ? type : type.getCanonicalType();
+		const auto type_name = getComplexMetadataValue(baseTy.getTypePtr(), Policy);
+		argTypeNames.push_back(llvm::MDString::get(Context, type_name));
+		argBaseTypeNames.push_back(llvm::MDString::get(Context, type_name));
+		
+		// set arg name
+		argNames.push_back(llvm::MDString::get(Context, name));
+		
+		// type quals is always empty for images
+		argTypeQuals.push_back(llvm::MDString::get(Context, ""));
+	};
+	
+	for(const auto& parm : FD->params()) {
+		const auto clang_type = parm->getType();
+		const bool IsCanonical = clang_type.isCanonical();
+		
+		// pointer / buffer
+		if (clang_type->isPointerType() || clang_type->isReferenceType()) {
+			// Get argument type name.
+			std::string tyName;
+			if (const PointerType *PTy = dyn_cast<PointerType>(clang_type.getTypePtr())) {
+				tyName = getPointerOrRefMetadataValue(PTy->getPointeeType().getTypePtr(), false, Policy);
+			}
+			else if (const ReferenceType *RTy = dyn_cast<ReferenceType>(clang_type.getTypePtr())) {
+				tyName = getPointerOrRefMetadataValue(RTy->getPointeeType().getTypePtr(), false, Policy);
+			}
+			else if (const DecayedType *DTy = dyn_cast<DecayedType>(clang_type.getTypePtr())) {
+				tyName = getPointerOrRefMetadataValue(DTy->getPointeeType().getTypePtr(), false, Policy);
+			}
+			else {
+				tyName = getScalarMetadataValue(clang_type.getTypePtr(), Policy);
+			}
+			argTypeNames.push_back(llvm::MDString::get(Context, tyName));
+			
+			// Acquiring the base type of the parameter.
+			std::string baseTyName;
+			if (IsCanonical) baseTyName = tyName;
+			else {
+				QualType can_pointee_type;
+				if(clang_type->isPointerType()) {
+					can_pointee_type = clang_type.getCanonicalType()->getAs<PointerType>()->getPointeeType();
+				}
+				else { // ref
+					can_pointee_type = clang_type.getCanonicalType()->getAs<ReferenceType>()->getPointeeType();
+				}
+				baseTyName = getPointerOrRefMetadataValue(can_pointee_type.getTypePtr(), true, Policy);
+			}
+			argBaseTypeNames.push_back(llvm::MDString::get(Context, baseTyName));
+			
+			// Get address qualifier.
+			QualType pointeeTy = clang_type->getPointeeType();
+			addressQuals.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(ASTCtx.getTargetAddressSpace(pointeeTy.getAddressSpace()))));
+			
+			// Get argument type qualifiers:
+			std::string typeQuals;
+			if (clang_type.isRestrictQualified()) {
+				typeQuals = "restrict";
+			}
+			if (pointeeTy.isConstQualified() ||
+				(pointeeTy.getAddressSpace() == LangAS::opencl_constant)) {
+				typeQuals += typeQuals.empty() ? "const" : " const";
+			}
+			if (pointeeTy.isVolatileQualified()) {
+				typeQuals += typeQuals.empty() ? "volatile" : " volatile";
+			}
+			argTypeQuals.push_back(llvm::MDString::get(Context, typeQuals));
+			
+			accessQuals.push_back(llvm::MDString::get(Context, "none"));
+			argNames.push_back(llvm::MDString::get(Context, parm->getName()));
+		}
+		// normal image
+		else if(clang_type->isImageType()) {
+			add_image_arg(clang_type, parm->getAttr<ImageAccessAttr>(),
+						  parm->getName().str());
+		}
+		// aggregate image
+		else if(clang_type->isAggregateImageType()) {
+			const auto decl = clang_type->getAsCXXRecordDecl();
+			const auto agg_images = get_aggregate_image_fields(decl);
+			
+			const std::string base_name = parm->getName().str() + ".";
+			unsigned int img_idx = 0;
+			for(const auto& img : agg_images) {
+				const auto img_type = img->getType();
+				
+				add_image_arg(img_type, img->getAttr<ImageAccessAttr>(),
+							  base_name + std::to_string(img_idx));
+				++img_idx;
+			}
+		}
+		else if (clang_type->isPipeType()) {
+			// Get argument type name.
+			std::string tyName = getPipeMetadataValue(clang_type->getAs<PipeType>(), Policy);
+			
+			// Acquiring the base type of the parameter.
+			std::string baseTyName;
+			if (IsCanonical) {
+				baseTyName = tyName;
+			}
+			else {
+				baseTyName = getPipeMetadataValue(clang_type.getCanonicalType()->getAs<PipeType>(), Policy);
+			}
+			
+			// Get address qualifier.
+			addressQuals.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(ASTCtx.getTargetAddressSpace(LangAS::opencl_global))));
+			
+			// Get argument type qualifiers.
+			std::string typeQuals = "pipe";
+			
+			// Adding the type and base type to the metadata.
+			assert(!tyName.empty() && "Empty type name");
+			argTypeNames.push_back(llvm::MDString::get(Context, tyName));
+			assert(!baseTyName.empty() && "Empty base type name");
+			argBaseTypeNames.push_back(llvm::MDString::get(Context, baseTyName));
+			
+			argTypeQuals.push_back(llvm::MDString::get(Context, typeQuals));
+			
+			// TODO: Get image access qualifier: (also for pipe?)
+			//accessQuals.push_back(getAccessAttribute(parm, Context));
+			
+			if (EmitVerbose) {
+				// Get argument name.
+				argNames.push_back(llvm::MDString::get(Context, parm->getName()));
+			}
+		}
+		// kernel parameter
+		else {
+			// TODO: merge pipe functionality
+			
+			addressQuals.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(0 /* private address space*/)));
+			
+			// Get argument type name.
+			std::string tyName = getScalarMetadataValue(clang_type.getTypePtr(), Policy);
+			argTypeNames.push_back(llvm::MDString::get(Context, tyName));
+			
+			// Acquiring the base type of the parameter.
+			QualType baseTy = IsCanonical ? clang_type : clang_type.getCanonicalType();
+			std::string baseTyName;
+			if (clang_type->isVectorType()) {
+				baseTyName = getVectorMetadataValue(llvm::dyn_cast<clang::ExtVectorType>(baseTy.getTypePtr()), Policy);
+			}
+			else {
+				baseTyName = getComplexMetadataValue(baseTy.getTypePtr(), Policy);
+			}
+			argBaseTypeNames.push_back(llvm::MDString::get(Context, baseTyName));
+			
+			// Get argument type qualifiers:
+			std::string typeQuals;
+			if (clang_type.isConstQualified()) {
+				typeQuals = "const";
+			}
+			if (clang_type.isVolatileQualified()) {
+				typeQuals += typeQuals.empty() ? "volatile" : " volatile";
+			}
+			argTypeQuals.push_back(llvm::MDString::get(Context, typeQuals));
+			
+			accessQuals.push_back(llvm::MDString::get(Context, "none"));
+			argNames.push_back(llvm::MDString::get(Context, parm->getName()));
+		}
+	}
+	
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, addressQuals));
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, accessQuals));
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, argTypeNames));
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, argBaseTypeNames));
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, argTypeQuals));
+	if(EmitVerbose) {
+		kernelMDArgs.push_back(llvm::MDNode::get(Context, argNames));
+	}
+}
 
-    argTypeQuals.push_back(llvm::MDString::get(Context, typeQuals));
-
-    // Get image and pipe access qualifier:
-    // FIXME: now image and pipe share the same access qualifier maybe we can
-    // refine it to OpenCL access qualifier and also handle write_read
-    if (ty->isImageType()|| ty->isPipeType()) {
-      const OpenCLImageAccessAttr *A = parm->getAttr<OpenCLImageAccessAttr>();
-      if (A && A->isWriteOnly())
-        accessQuals.push_back(llvm::MDString::get(Context, "write_only"));
-      else
-        accessQuals.push_back(llvm::MDString::get(Context, "read_only"));
-      // FIXME: what about read_write?
-    } else
-      accessQuals.push_back(llvm::MDString::get(Context, "none"));
+static void GenAIRMetadata(const FunctionDecl *FD, llvm::Function *Fn,
+						   CodeGenModule &CGM,llvm::LLVMContext &Context,
+						   SmallVector <llvm::Metadata*, 5> &kernelMDArgs,
+						   CGBuilderTy& Builder, ASTContext &ASTCtx) {
+	const bool is_kernel = FD->hasAttr<ComputeKernelAttr>();
+	const bool is_vertex = FD->hasAttr<GraphicsVertexShaderAttr>();
+	const bool is_fragment = FD->hasAttr<GraphicsFragmentShaderAttr>();
+	
+	//
+	SmallVector<llvm::Metadata*, 4> stage_infos;
+	SmallVector<llvm::Metadata*, 8> arg_infos;
+	
+	//
+	const PrintingPolicy &Policy = ASTCtx.getPrintingPolicy();
+	const auto make_type_name = [&Policy](const clang::QualType& type) {
+		// NOTE: air wants the type w/o qualifiers
+		const auto base_unq_type = type.getTypePtr()->getBaseElementTypeUnsafe();
+		const auto unqualified_type = base_unq_type->getCanonicalTypeInternal();
+		std::string type_name = "";
+		if(type->isVectorType()) {
+			type_name = getVectorMetadataValue(llvm::dyn_cast<clang::ExtVectorType>(unqualified_type.getTypePtr()), Policy);
+		}
+		else if(type->isHalfType()) type_name = "half";
+		else type_name = unqualified_type.getAsString(Policy);
+		// Turn "unsigned type" to "utype"
+		const auto pos = type_name.find("unsigned");
+		if(pos != std::string::npos) type_name.erase(pos + 1, 8);
+		return type_name;
+	};
+	
+	//
+	unsigned int arg_idx = 0, buffer_idx = 0, tex_idx = 0;
+	for(const auto& parm : FD->params()) {
+		const auto clang_type = parm->getType();
+		const auto llvm_type = next(Fn->getArgumentList().begin(), arg_idx)->getType();
+		const auto cxx_rdecl = clang_type->getAsCXXRecordDecl();
+
+		const auto add_image_arg = [&Builder, &tex_idx, &arg_infos, &arg_idx, &parm,
+									&Context, &ASTCtx, &CGM](const clang::QualType& type,
+															 const ImageAccessAttr* access_attr,
+															 const FloorImageDataTypeAttr* data_type,
+															 const std::string& name) {
+			SmallVector<llvm::Metadata*, 16> arg_info;
+			
+			// #0: param index
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(arg_idx)));
+			// #1: storage type
+			arg_info.push_back(llvm::MDString::get(Context, "air.texture"));
+			// #2/#3: location_index (note: separate for buffers and textures)
+			arg_info.push_back(llvm::MDString::get(Context, "air.location_index"));
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(tex_idx)));
+			++tex_idx;
+			// #4: unknown? always 1
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(1)));
+			// #5: access type (sample = 0, read = 1 or write = 2)
+			// note that "read" is essentially a subset of "sample" -> use "sample" for r/o
+			if(access_attr && access_attr->isWriteOnly()) {
+				arg_info.push_back(llvm::MDString::get(Context, "air.write"));
+			}
+			else if(access_attr && access_attr->isReadWrite()) {
+				// TODO: this isn't really supported
+				arg_info.push_back(llvm::MDString::get(Context, "air.write"));
+			}
+			else {
+				arg_info.push_back(llvm::MDString::get(Context, "air.sample"));
+			}
+			
+			// #6/#7: texture type
+			arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+			// proper type is necessary for metal debugging purposes
+			std::string tex_type_name;
+			const auto builtin_type = type->getAs<BuiltinType>();
+			if(!builtin_type) {
+				CGM.Error(parm->getSourceRange().getBegin(), StringRef("invalid image type (not a builtin type)!"));
+				return;
+			}
+			switch(builtin_type->getKind()) {
+#if 0 // TODO: enable this again when using ro/wo/rw image types
+				case BuiltinType::OCLImage1dRO:
+				case BuiltinType::OCLImage1dWO:
+				case BuiltinType::OCLImage1dRW:
+					tex_type_name = "texture1d";
+					break;
+				case BuiltinType::OCLImage1dArrayRO:
+				case BuiltinType::OCLImage1dArrayWO:
+				case BuiltinType::OCLImage1dArrayRW:
+					tex_type_name = "texture1d_array";
+					break;
+				case BuiltinType::OCLImage2dRO:
+				case BuiltinType::OCLImage2dWO:
+				case BuiltinType::OCLImage2dRW:
+					tex_type_name = "texture2d";
+					break;
+				case BuiltinType::OCLImage2dArrayRO:
+				case BuiltinType::OCLImage2dArrayWO:
+				case BuiltinType::OCLImage2dArrayRW:
+					tex_type_name = "texture2d_array";
+					break;
+				case BuiltinType::OCLImage2dDepthRO:
+				case BuiltinType::OCLImage2dDepthWO:
+				case BuiltinType::OCLImage2dDepthRW:
+					tex_type_name = "depth2d";
+					break;
+				case BuiltinType::OCLImage2dArrayDepthRO:
+				case BuiltinType::OCLImage2dArrayDepthWO:
+				case BuiltinType::OCLImage2dArrayDepthRW:
+					tex_type_name = "depth2d_array";
+					break;
+				case BuiltinType::OCLImage2dMSAARO:
+				case BuiltinType::OCLImage2dMSAAWO:
+				case BuiltinType::OCLImage2dMSAARW:
+					tex_type_name = "texture2d_ms";
+					break;
+				case BuiltinType::OCLImage2dMSAADepthRO:
+				case BuiltinType::OCLImage2dMSAADepthWO:
+				case BuiltinType::OCLImage2dMSAADepthRW:
+					tex_type_name = "depth2d_ms";
+					break;
+				case BuiltinType::OCLImage3dRO:
+				case BuiltinType::OCLImage3dWO:
+				case BuiltinType::OCLImage3dRW:
+					tex_type_name = "texture3d";
+					break;
+				case BuiltinType::OCLImageCubeRO:
+				case BuiltinType::OCLImageCubeWO:
+				case BuiltinType::OCLImageCubeRW:
+					tex_type_name = "texturecube";
+					break;
+				case BuiltinType::OCLImageCubeArrayRO:
+				case BuiltinType::OCLImageCubeArrayWO:
+				case BuiltinType::OCLImageCubeArrayRW:
+					tex_type_name = "texturecube_array";
+					break;
+				case BuiltinType::OCLImageCubeDepthRO:
+				case BuiltinType::OCLImageCubeDepthWO:
+				case BuiltinType::OCLImageCubeDepthRW:
+					tex_type_name = "depthcube";
+					break;
+				case BuiltinType::OCLImageCubeArrayDepthRO:
+				case BuiltinType::OCLImageCubeArrayDepthWO:
+				case BuiltinType::OCLImageCubeArrayDepthRW:
+					tex_type_name = "depthcube_array";
+					break;
+#else
+				case BuiltinType::OCLImage1d:
+					tex_type_name = "texture1d";
+					break;
+				case BuiltinType::OCLImage1dArray:
+					tex_type_name = "texture1d_array";
+					break;
+				case BuiltinType::OCLImage2d:
+					tex_type_name = "texture2d";
+					break;
+				case BuiltinType::OCLImage2dArray:
+					tex_type_name = "texture2d_array";
+					break;
+				case BuiltinType::OCLImage2dDepth:
+					tex_type_name = "depth2d";
+					break;
+				case BuiltinType::OCLImage2dArrayDepth:
+					tex_type_name = "depth2d_array";
+					break;
+				case BuiltinType::OCLImage2dMSAA:
+					tex_type_name = "texture2d_ms";
+					break;
+				case BuiltinType::OCLImage2dMSAADepth:
+					tex_type_name = "depth2d_ms";
+					break;
+				case BuiltinType::OCLImage3d:
+					tex_type_name = "texture3d";
+					break;
+				case BuiltinType::OCLImageCube:
+					tex_type_name = "texturecube";
+					break;
+				case BuiltinType::OCLImageCubeArray:
+					tex_type_name = "texturecube_array";
+					break;
+				case BuiltinType::OCLImageCubeDepth:
+					tex_type_name = "depthcube";
+					break;
+				case BuiltinType::OCLImageCubeArrayDepth:
+					tex_type_name = "depthcube_array";
+					break;
+#endif
+				default:
+					CGM.Error(parm->getSourceRange().getBegin(), StringRef("invalid image type!"));
+					return;
+			}
+			
+			tex_type_name += "<";
+			std::string sample_type_str = "float";
+			if(data_type) {
+				const auto canon_data_type = data_type->getImageDataType().getCanonicalType();
+				if(canon_data_type->isIntegerType()) sample_type_str = "int";
+				if(canon_data_type->isUnsignedIntegerType()) sample_type_str = "uint";
+				// else: just assume float
+			}
+			tex_type_name += sample_type_str;
+			tex_type_name += ", ";
+			if(access_attr && access_attr->isReadOnly()) {
+				tex_type_name += "sample";
+			}
+			else tex_type_name += "write";
+			tex_type_name += ">";
+			
+			arg_info.push_back(llvm::MDString::get(Context, tex_type_name));
+			
+			// #8/#9: arg name
+			arg_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+			arg_info.push_back(llvm::MDString::get(Context, StringRef(name)));
+			arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+		};
+		
+		// pointer / buffer
+		if(clang_type->isPointerType() || clang_type->isReferenceType()) {
+			const auto pointee_type = llvm_type->getPointerElementType();
+			
+			SmallVector<llvm::Metadata*, 16> arg_info;
+			
+			// #0: param index
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(arg_idx)));
+			// #1: storage type
+			arg_info.push_back(llvm::MDString::get(Context, "air.buffer"));
+			
+			// references / single-object parameters also store/require the buffer_size
+			if(clang_type->isReferenceType()) {
+				arg_info.push_back(llvm::MDString::get(Context, "air.buffer_size"));
+				arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(CGM.getDataLayout().getTypeStoreSize(pointee_type))));
+			}
+			
+			// #2/#3: location_index (note: separate for buffers and textures)
+			arg_info.push_back(llvm::MDString::get(Context, "air.location_index"));
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(buffer_idx)));
+			++buffer_idx;
+			// #4: unknown? always 1
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(1)));
+			// #5: access (read/read_write, TODO: write?)
+			const auto clang_pointee_type = clang_type->getPointeeType();
+			if(clang_pointee_type.isConstQualified() ||
+			   (clang_pointee_type.getAddressSpace() == LangAS::opencl_constant)) {
+				arg_info.push_back(llvm::MDString::get(Context, "air.read"));
+			}
+			else {
+				arg_info.push_back(llvm::MDString::get(Context, "air.read_write"));
+			}
+			
+			// #6/#7: struct info
+			if(const auto pointee_rdecl = clang_pointee_type->getAsCXXRecordDecl()) {
+				SmallVector<llvm::Metadata*, 16> struct_info;
+				// TODO: this is not ideal and doesn't handle properly handle unions
+				const auto fields = get_aggregate_fields(pointee_rdecl);
+				bool ignore = false;
+				for(const auto& field : fields) {
+					if(field->isAnonymousStructOrUnion() ||
+					   field->isBitField()) {
+						ignore = true;
+						break;
+					}
+				}
+				
+				// TODO/NOTE: ignore anonymous structs/unions and bitfields for now
+				if(!ignore) {
+					SmallVector<llvm::Metadata*, 16> struct_info;
+					arg_info.push_back(llvm::MDString::get(Context, "air.struct_type_info"));
+					
+					uint32_t offset = 0;
+					for(const auto& field : fields) {
+						// #0: offset
+						struct_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(offset)));
+						// #1: sizeof
+						const auto llvm_mem_type = CGM.getTypes().ConvertTypeForMem(field->getType()); // TODO: should use this _everywhere_ instead of llvm type tracking/matching!
+						const auto size = (uint32_t)CGM.getDataLayout().getTypeStoreSize(llvm_mem_type);
+						offset += size;
+						struct_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(size)));
+						// #2: TODO? array or padding maybe?
+						struct_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(0)));
+						// #3: type name
+						struct_info.push_back(llvm::MDString::get(Context, make_type_name(field->getType())));
+						// #4: name/identifier
+						struct_info.push_back(llvm::MDString::get(Context, field->getName()));
+					}
+					arg_info.push_back(llvm::MDNode::get(Context, struct_info));
+				}
+			}
+			
+			// #8/#9: type size
+			arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_size"));
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(CGM.getDataLayout().getTypeStoreSize(pointee_type))));
+			// #10/#11: type alignment
+			arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_align_size"));
+			// max out at 16, anything higher is unreasonable
+			// TODO: make sure this is POT
+			const auto align_size = std::min(CGM.getDataLayout().getTypeAllocSize(pointee_type), uint64_t(16));
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(align_size)));
+			//getPrimitiveSizeInBits
+			// #12/#13: type name
+			arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+			// NOTE: air wants the pointed-to/pointee type here
+			arg_info.push_back(llvm::MDString::get(Context, make_type_name(clang_type->getPointeeType())));
+			// #14/#15: arg name
+			arg_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+			arg_info.push_back(llvm::MDString::get(Context, parm->getName()));
+			arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+		}
+		// image
+		else if(clang_type->isImageType()) {
+			add_image_arg(clang_type, parm->getAttr<ImageAccessAttr>(),
+						  parm->getAttr<FloorImageDataTypeAttr>(), parm->getName().str());
+		}
+		// aggregate image
+		else if(clang_type->isAggregateImageType()) {
+			const auto agg_images = get_aggregate_image_fields(cxx_rdecl);
+			
+			const std::string base_name = parm->getName().str() + ".";
+			unsigned int img_idx = 0;
+			for(const auto& img : agg_images) {
+				const auto img_type = img->getType();
+				
+				add_image_arg(img_type, img->getAttr<ImageAccessAttr>(),
+							  img->getAttr<FloorImageDataTypeAttr>(), base_name + std::to_string(img_idx));
+				++img_idx;
+				
+				// next llvm arg
+				++arg_idx;
+			}
+			// fix up llvm arg count (will inc again after this)
+			--arg_idx;
+		}
+		// stage input
+		else if(parm->hasAttr<GraphicsStageInputAttr>()) {
+			if(cxx_rdecl) {
+				// must handle each field individually
+				const auto fields = CGM.getTypes().get_aggregate_scalar_fields(cxx_rdecl, cxx_rdecl);
+				for(const auto& field : fields) {
+					SmallVector<llvm::Metadata*, 16> arg_info;
+					
+					// #0: param index
+					arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(arg_idx)));
+					
+					// #1: type
+					// TODO: handle perspective/center correctly
+					if(field.hasAttr<GraphicsVertexPositionAttr>()) {
+						arg_info.push_back(llvm::MDString::get(Context, "air.position"));
+						arg_info.push_back(llvm::MDString::get(Context, "air.center"));
+						arg_info.push_back(llvm::MDString::get(Context, "air.no_perspective"));
+					}
+					else {
+						arg_info.push_back(llvm::MDString::get(Context, "air.fragment_input"));
+						arg_info.push_back(llvm::MDString::get(Context, StringRef(field.mangled_name)));
+						arg_info.push_back(llvm::MDString::get(Context, "air.center"));
+						arg_info.push_back(llvm::MDString::get(Context, "air.perspective"));
+					}
+					
+					// type name
+					arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+					arg_info.push_back(llvm::MDString::get(Context, make_type_name(field.type)));
+					
+					// arg name
+					arg_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+					arg_info.push_back(llvm::MDString::get(Context, field.name));
+					arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+					
+					// next
+					++arg_idx;
+				}
+				--arg_idx; // fixup, b/c of inc later
+			}
+			else {
+				// TODO: add as-is
+			}
+		}
+		// unsupported simple kernel parameter
+		else {
+			CGM.Error(parm->getSourceRange().getBegin(),
+					  StringRef("metal kernel parameter must be a pointer or an image type!"));
+			return;
+		}
+		
+		// next llvm arg
+		++arg_idx;
+	}
+	
+	if(is_kernel) {
+		// add id handling arg metadata
+		// NOTE: the actual args are later added by MetalFinal + the order in here must match the order in MetalFinal
+		const auto add_id_arg = [&arg_idx, &arg_infos, &Builder, &Context](const char* name, const char* air_name) {
+			SmallVector<llvm::Metadata*, 6> arg_info;
+			arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(arg_idx)));
+			arg_info.push_back(llvm::MDString::get(Context, air_name));
+			arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+			arg_info.push_back(llvm::MDString::get(Context, "uint3"));
+			arg_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+			arg_info.push_back(llvm::MDString::get(Context, name));
+			arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+			
+			// next llvm arg
+			++arg_idx;
+		};
+		add_id_arg("__metal__global_id__", "air.thread_position_in_grid");
+		add_id_arg("__metal__global_size__", "air.threads_per_grid");
+		add_id_arg("__metal__local_id__", "air.thread_position_in_threadgroup");
+		add_id_arg("__metal__local_size__", "air.threads_per_threadgroup");
+		add_id_arg("__metal__group_id__", "air.threadgroup_position_in_grid");
+		add_id_arg("__metal__group_size__", "air.threadgroups_per_grid");
+	}
+	else if(is_vertex) {
+		// TODO: instance id
+		
+		SmallVector<llvm::Metadata*, 6> arg_info;
+		arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(arg_idx)));
+		arg_info.push_back(llvm::MDString::get(Context, "air.vertex_id"));
+		arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+		arg_info.push_back(llvm::MDString::get(Context, "uint"));
+		arg_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+		arg_info.push_back(llvm::MDString::get(Context, "__metal__vertex_id__"));
+		arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+		++arg_idx; // next llvm arg
+		
+		const auto add_vs_output = [&Context, &Builder, &ASTCtx, &CGM,
+									&stage_infos, &make_type_name](const CodeGenTypes::aggregate_scalar_entry& entry,
+																   const bool force_position = false) {
+			SmallVector<llvm::Metadata*, 6> ret_info;
+			
+			if(entry.hasAttr<GraphicsVertexPositionAttr>() || force_position) {
+				ret_info.push_back(llvm::MDString::get(Context, "air.position"));
+			}
+			else if(entry.hasAttr<GraphicsPointSizeAttr>()) {
+				ret_info.push_back(llvm::MDString::get(Context, "air.point_size"));
+			}
+			else {
+				ret_info.push_back(llvm::MDString::get(Context, "air.vertex_output"));
+				ret_info.push_back(llvm::MDString::get(Context, StringRef(entry.mangled_name)));
+			}
+			
+			ret_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+			ret_info.push_back(llvm::MDString::get(Context, make_type_name(entry.type)));
+			
+			ret_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+			ret_info.push_back(llvm::MDString::get(Context, entry.name));
+			
+			stage_infos.push_back(llvm::MDNode::get(Context, ret_info));
+		};
+		
+		// vertex output
+		const auto ret_type = FD->getReturnType();
+		const auto cxx_rdecl = ret_type->getAsCXXRecordDecl();
+		if(cxx_rdecl && !cxx_rdecl->hasAttr<VectorCompatAttr>()) {
+			const auto fields = CGM.getTypes().get_aggregate_scalar_fields(cxx_rdecl, cxx_rdecl);
+			for(const auto& field : fields) {
+				add_vs_output(field);
+			}
+		}
+		else if(!ret_type->isVoidType()) {
+			// direct output: always vertex position, no mangled name
+			add_vs_output(CodeGenTypes::aggregate_scalar_entry {
+				(cxx_rdecl && cxx_rdecl->hasAttr<VectorCompatAttr>() ?
+				 CGM.getTypes().get_compat_vector_type(cxx_rdecl) : ret_type),
+				FD->getName().str(), // func name if direct
+				"",
+				nullptr,
+				nullptr,
+				{},
+				(cxx_rdecl && cxx_rdecl->hasAttr<VectorCompatAttr>()),
+				false
+			}, true);
+		}
+	}
+	else if(is_fragment) {
+		// TODO: other stuff
+		
+		SmallVector<llvm::Metadata*, 6> arg_info;
+		arg_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(arg_idx)));
+		arg_info.push_back(llvm::MDString::get(Context, "air.point_coord"));
+		arg_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+		arg_info.push_back(llvm::MDString::get(Context, "float2"));
+		arg_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+		arg_info.push_back(llvm::MDString::get(Context, "__metal__point_coord__"));
+		arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+		++arg_idx; // next llvm arg
+		
+		const auto add_fs_output = [&Context, &Builder, &ASTCtx, &CGM,
+									&stage_infos, &make_type_name](const CodeGenTypes::aggregate_scalar_entry& entry,
+																   const unsigned int& location) {
+			SmallVector<llvm::Metadata*, 6> rtt_info;
+			
+			// #0/1: render target location index
+			rtt_info.push_back(llvm::MDString::get(Context, "air.render_target"));
+			rtt_info.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(location)));
+			
+			// #2/3: type name
+			rtt_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+			rtt_info.push_back(llvm::MDString::get(Context, make_type_name(entry.type)));
+			
+			// #4/#5: name/identifier
+			rtt_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+			rtt_info.push_back(llvm::MDString::get(Context, entry.name));
+			
+			stage_infos.push_back(llvm::MDNode::get(Context, rtt_info));
+		};
+		
+		// render targets / return types
+		const auto ret_type = FD->getReturnType();
+		const auto cxx_rdecl = ret_type->getAsCXXRecordDecl();
+		if(cxx_rdecl && !cxx_rdecl->hasAttr<VectorCompatAttr>()) {
+			const auto fields = CGM.getTypes().get_aggregate_scalar_fields(cxx_rdecl, cxx_rdecl);
+			
+			// fbo output location resolve/computation needs to happen in two passes:
+			// * gather all fixed/attr locations, make sure none conflict
+			// * used fixed locations + generate automatic location for non-fixed outputs
+			std::unordered_set<unsigned int> fbo_locations;
+			for(const auto& field : fields) {
+				if(field.hasAttr<GraphicsFBOColorLocationAttr>()) {
+					const auto loc_attr = field.getAttr<GraphicsFBOColorLocationAttr>();
+					if(!fbo_locations.insert(loc_attr->getEvalLocation()).second) {
+						// TODO: should have been detected earlier ...
+						CGM.Error(loc_attr->getLocation(), StringRef("location already in use"));
+						// TODO: add note of prev location?
+						return;
+					}
+				}
+			}
+			
+			unsigned int location = 0;
+			for(const auto& field : fields) {
+				if(field.hasAttr<GraphicsFBOColorLocationAttr>()) {
+					add_fs_output(field, field.getAttr<GraphicsFBOColorLocationAttr>()->getEvalLocation());
+				}
+				else if(field.hasAttr<GraphicsFBODepthTypeAttr>()) {
+					const auto depth_attr = field.getAttr<GraphicsFBODepthTypeAttr>();
+					if(!field.type->isFloatingType()) {
+						// TODO: should have been detected earlier ...
+						CGM.Error(depth_attr->getLocation(),
+								  StringRef("depth attribute can only be applied to floating point types"));
+						return;
+					}
+					
+					SmallVector<llvm::Metadata*, 7> depth_info;
+					
+					depth_info.push_back(llvm::MDString::get(Context, "air.depth"));
+					
+					// #1/2: depth qualifier
+					depth_info.push_back(llvm::MDString::get(Context, "air.depth_qualifier"));
+					std::string depth_qual = "air.";
+					switch(depth_attr->getDepthQualifier()) {
+						case clang::GraphicsFBODepthTypeAttr::FBODepthTypeAny: depth_qual += "any"; break;
+						case clang::GraphicsFBODepthTypeAttr::FBODepthTypeLess: depth_qual += "less"; break;
+						case clang::GraphicsFBODepthTypeAttr::FBODepthTypeGreater: depth_qual += "greater"; break;
+					}
+					depth_info.push_back(llvm::MDString::get(Context, depth_qual));
+					
+					// #3/4: type name
+					depth_info.push_back(llvm::MDString::get(Context, "air.arg_type_name"));
+					depth_info.push_back(llvm::MDString::get(Context, make_type_name(field.type)));
+					
+					// #5/#6: name/identifier
+					depth_info.push_back(llvm::MDString::get(Context, "air.arg_name"));
+					depth_info.push_back(llvm::MDString::get(Context, field.name));
+					
+					stage_infos.push_back(llvm::MDNode::get(Context, depth_info));
+				}
+				else {
+					for(;;) {
+						if(fbo_locations.count(location) > 0) {
+							++location;
+						}
+						else break;
+					}
+					add_fs_output(field, location);
+					++location;
+				}
+			}
+		}
+		else if(!ret_type->isVoidType()) {
+			add_fs_output(CodeGenTypes::aggregate_scalar_entry {
+				(cxx_rdecl && cxx_rdecl->hasAttr<VectorCompatAttr>() ?
+				 CGM.getTypes().get_compat_vector_type(cxx_rdecl) : ret_type),
+				FD->getName().str(), // func name if direct
+				"",
+				nullptr,
+				nullptr,
+				{},
+				(cxx_rdecl && cxx_rdecl->hasAttr<VectorCompatAttr>()),
+				false
+			}, 0);
+		}
+	}
+
+	// insert into kernel metadata
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, stage_infos));
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, arg_infos));
+}
 
-    // Get argument name.
-    argNames.push_back(llvm::MDString::get(Context, parm->getName()));
-  }
+static void GenAppleCLMetadata(const FunctionDecl *FD, llvm::Function *Fn,
+							   CodeGenModule &CGM,llvm::LLVMContext &Context,
+							   SmallVector <llvm::Metadata*, 5> &kernelMDArgs,
+							   CGBuilderTy& Builder, ASTContext &ASTCtx) {
+	//
+	SmallVector<llvm::Metadata*, 8> arg_infos;
+	
+	// always starts with apple.cl.arg_metadata
+	arg_infos.push_back(llvm::MDString::get(Context, "apple.cl.arg_metadata"));
+	
+	//
+	for(const auto& parm : FD->params()) {
+		const auto clang_type = parm->getType();
+		
+		const auto add_image_arg = [&arg_infos, &Context](const ImageAccessAttr* access_attr) {
+			SmallVector<llvm::Metadata*, 2> arg_info;
+			
+			arg_info.push_back(llvm::MDString::get(Context, "image"));
+			
+			// access qualifier
+			if(access_attr && access_attr->isWriteOnly()) {
+				arg_info.push_back(llvm::MDString::get(Context, "write"));
+			}
+			else if(access_attr && access_attr->isReadWrite()) {
+				arg_info.push_back(llvm::MDString::get(Context, "read/write"));
+			}
+			else {
+				arg_info.push_back(llvm::MDString::get(Context, "read"));
+			}
+			
+			arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+		};
+		
+		// #0: storage type (stream or image)
+		if(clang_type->isPointerType() || clang_type->isReferenceType()) {
+			SmallVector<llvm::Metadata*, 3> arg_info;
+			arg_info.push_back(llvm::MDString::get(Context, "stream"));
+			
+			// #1: access qualifier
+			const auto clang_pointee_type = clang_type->getPointeeType();
+			if(clang_pointee_type.isConstQualified() ||
+			   (clang_pointee_type.getAddressSpace() == LangAS::opencl_constant)) {
+				arg_info.push_back(llvm::MDString::get(Context, "read"));
+			}
+			else {
+				arg_info.push_back(llvm::MDString::get(Context, "write"));
+			}
+			
+			// #2: address space
+			switch(clang_pointee_type.getAddressSpace()) {
+				case LangAS::opencl_global:
+					arg_info.push_back(llvm::MDString::get(Context, "global"));
+					break;
+				case LangAS::opencl_local:
+					arg_info.push_back(llvm::MDString::get(Context, "local"));
+					break;
+				case LangAS::opencl_constant:
+					arg_info.push_back(llvm::MDString::get(Context, "constant"));
+					break;
+			}
+			
+			arg_infos.push_back(llvm::MDNode::get(Context, arg_info));
+		}
+		else if(clang_type->isImageType()) {
+			add_image_arg(parm->getAttr<ImageAccessAttr>());
+		}
+		else if(clang_type->isAggregateImageType()) {
+			const auto decl = clang_type->getAsCXXRecordDecl();
+			const auto agg_images = get_aggregate_image_fields(decl);
+			for(const auto& img : agg_images) {
+				add_image_arg(img->getAttr<ImageAccessAttr>());
+			}
+		}
+		else {
+			// simple kernel parameter (not a buffer) -> don't write anything
+			arg_infos.push_back(llvm::MDNode::get(Context, {}));
+		}
+	}
+	
+	// insert into kernel metadata
+	kernelMDArgs.push_back(llvm::MDNode::get(Context, arg_infos));
+}
 
-  kernelMDArgs.push_back(llvm::MDNode::get(Context, addressQuals));
-  kernelMDArgs.push_back(llvm::MDNode::get(Context, accessQuals));
-  kernelMDArgs.push_back(llvm::MDNode::get(Context, argTypeNames));
-  kernelMDArgs.push_back(llvm::MDNode::get(Context, argBaseTypeNames));
-  kernelMDArgs.push_back(llvm::MDNode::get(Context, argTypeQuals));
-  if (CGM.getCodeGenOpts().EmitOpenCLArgMetadata)
-    kernelMDArgs.push_back(llvm::MDNode::get(Context, argNames));
+void CodeGenFunction::EmitFloorKernelMetadata(const FunctionDecl *FD,
+											  llvm::Function *Fn,
+											  const FunctionArgList &Args,
+											  const CGFunctionInfo &FnInfo) {
+	const bool is_kernel = FD->hasAttr<ComputeKernelAttr>();
+	const bool is_vertex = FD->hasAttr<GraphicsVertexShaderAttr>();
+	const bool is_fragment = FD->hasAttr<GraphicsFragmentShaderAttr>();
+	if(!is_kernel && !is_vertex && !is_fragment) {
+		return;
+	}
+
+ 	if(getLangOpts().floor_function_info == nullptr) {
+ 		return;
+ 	}
+ 	std::fstream& file = *getLangOpts().floor_function_info;
+	
+	const PrintingPolicy &Policy = getContext().getPrintingPolicy();
+	
+	// #0: info version
+	file << "2,";
+	// #1: function name
+	file << Fn->getName().str() << ",";
+	// #2: function type
+	file << (is_kernel ? "1" : (is_vertex ? "2" : "3")) << ",";
+	
+	// iterate over clang function decl parameters
+	// NOTE: in case of struct expansion, this doesn't match the llvm parameters
+	// (which is why it iterates over the original clang list!)
+	unsigned int arg_idx = 0;
+	auto abi_arg_info_iter = FnInfo.arg_begin();
+	for(const auto& parm : FD->params()) {
+		const auto clang_type = parm->getType();
+		const auto llvm_type = next(Fn->getArgumentList().begin(), arg_idx)->getType();
+		const auto cxx_rdecl = clang_type->getAsCXXRecordDecl();
+		
+		enum class FLOOR_ARG_INFO : uint64_t {
+			// 0 == invalid!
+			NONE						= (0ull),
+			
+			// sets: -------- 000000-- -------- 00000xxx 00000000 00000000 00000000 00000000
+			__AS_SHIFT					= (32ull),
+			__AS_MASK					= (0x0000000700000000ull),
+			AS_NONE						= NONE,
+			AS_GLOBAL					= (1ull << __AS_SHIFT),
+			AS_LOCAL					= (2ull << __AS_SHIFT),
+			AS_CONSTANT					= (3ull << __AS_SHIFT),
+			AS_IMAGE					= (4ull << __AS_SHIFT),
+			
+			// sets: -------- 000000-- xxxxxxxx 00000--- 00000000 00000000 00000000 00000000
+			__IMG_TYPE_SHIFT			= (40ull),
+			__IMG_TYPE_MASK				= (0x0000FF0000000000ull),
+			IMG_1D						= (1ull << __IMG_TYPE_SHIFT),
+			IMG_1D_ARRAY				= (2ull << __IMG_TYPE_SHIFT),
+			IMG_1D_BUFFER				= (3ull << __IMG_TYPE_SHIFT),
+			IMG_2D						= (4ull << __IMG_TYPE_SHIFT),
+			IMG_2D_ARRAY				= (5ull << __IMG_TYPE_SHIFT),
+			IMG_2D_DEPTH				= (6ull << __IMG_TYPE_SHIFT),
+			IMG_2D_ARRAY_DEPTH			= (7ull << __IMG_TYPE_SHIFT),
+			IMG_2D_MSAA					= (8ull << __IMG_TYPE_SHIFT),
+			IMG_2D_ARRAY_MSAA			= (9ull << __IMG_TYPE_SHIFT),
+			IMG_2D_MSAA_DEPTH			= (10ull << __IMG_TYPE_SHIFT),
+			IMG_2D_ARRAY_MSAA_DEPTH		= (11ull << __IMG_TYPE_SHIFT),
+			IMG_3D						= (12ull << __IMG_TYPE_SHIFT),
+			IMG_CUBE					= (13ull << __IMG_TYPE_SHIFT),
+			IMG_CUBE_ARRAY				= (14ull << __IMG_TYPE_SHIFT),
+			IMG_CUBE_DEPTH				= (15ull << __IMG_TYPE_SHIFT),
+			IMG_CUBE_ARRAY_DEPTH		= (16ull << __IMG_TYPE_SHIFT),
+			
+			// sets: -------- 000000xx -------- 00000--- 00000000 00000000 00000000 00000000
+			__IMG_ACCESS_SHIFT			= (48ull),
+			__IMG_ACCESS_MASK			= (0x0003000000000000ull),
+			IMG_ACCESS_READ				= (1ull << __IMG_ACCESS_SHIFT),
+			IMG_ACCESS_WRITE			= (2ull << __IMG_ACCESS_SHIFT),
+			IMG_ACCESS_READ_WRITE		= (IMG_ACCESS_READ | IMG_ACCESS_WRITE),
+			
+			// sets: xxxxxxxx 000000-- -------- 00000--- 00000000 00000000 00000000 00000000
+			__SPECIAL_TYPE_SHIFT		= (56ull),
+			__SPECIAL_TYPE_MASK			= (0xFF00000000000000ull),
+			STAGE_INPUT					= (1ull << __SPECIAL_TYPE_SHIFT),
+		};
+		static const auto to_fas = [](const unsigned& addr_space) {
+			if(addr_space == LangAS::opencl_global) {
+				return FLOOR_ARG_INFO::AS_GLOBAL;
+			}
+			else if(addr_space == LangAS::opencl_local) {
+				return FLOOR_ARG_INFO::AS_LOCAL;
+			}
+			else if(addr_space == LangAS::opencl_constant) {
+				return FLOOR_ARG_INFO::AS_CONSTANT;
+			}
+			return FLOOR_ARG_INFO::AS_NONE;
+		};
+		
+		const auto compute_type_size = [this, &parm, &Fn](llvm::Type* type) {
+			if(!type->isSized()) {
+				auto err_diagID = CGM.getDiags().getCustomDiagID(DiagnosticsEngine::Fatal, "%0");
+				CGM.getDiags().Report(parm->getSourceRange().getBegin(), err_diagID) << "parameter uses a type with an unknown size (NOTE: this can happen when internal vector type conversion/replacement has failed)";
+				
+				auto note_diagID = CGM.getDiags().getCustomDiagID(DiagnosticsEngine::Note, "LLVM function type: %0");
+				std::string fun_type = "";
+				llvm::raw_string_ostream fun_type_stream(fun_type);
+				Fn->getFunctionType()->print(fun_type_stream);
+				CGM.getDiags().Report(parm->getSourceRange().getBegin(), note_diagID) << fun_type_stream.str();
+				
+				return uint64_t(0);
+			}
+			return CGM.getDataLayout().getTypeStoreSize(type);
+		};
+		
+		static const auto get_image_access = [](const ImageAccessAttr* access_attr) {
+			if(access_attr != nullptr) {
+				if(access_attr->isWriteOnly()) {
+					return FLOOR_ARG_INFO::IMG_ACCESS_WRITE;
+				}
+				else if(access_attr->isReadWrite()) {
+					return FLOOR_ARG_INFO::IMG_ACCESS_READ_WRITE;
+				}
+			}
+			return FLOOR_ARG_INFO::IMG_ACCESS_READ;
+		};
+		static const auto img_type_to_floor_type = [](const clang::Type* type) {
+			const auto builtin_type = type->getAs<BuiltinType>();
+			if(!builtin_type) {
+				return (FLOOR_ARG_INFO)~0ull;
+			}
+			switch(builtin_type->getKind()) {
+#if 0 // TODO: enable this again when using ro/wo/rw image types
+				case BuiltinType::OCLImage1dRO:
+				case BuiltinType::OCLImage1dWO:
+				case BuiltinType::OCLImage1dRW:
+					return FLOOR_ARG_INFO::IMG_1D;
+				case BuiltinType::OCLImage1dArrayRO:
+				case BuiltinType::OCLImage1dArrayWO:
+				case BuiltinType::OCLImage1dArrayRW:
+					return FLOOR_ARG_INFO::IMG_1D_ARRAY;
+				case BuiltinType::OCLImage1dBufferRO:
+				case BuiltinType::OCLImage1dBufferWO:
+				case BuiltinType::OCLImage1dBufferRW:
+					return FLOOR_ARG_INFO::IMG_1D_BUFFER;
+				case BuiltinType::OCLImage2dRO:
+				case BuiltinType::OCLImage2dWO:
+				case BuiltinType::OCLImage2dRW:
+					return FLOOR_ARG_INFO::IMG_2D;
+				case BuiltinType::OCLImage2dArrayRO:
+				case BuiltinType::OCLImage2dArrayWO:
+				case BuiltinType::OCLImage2dArrayRW:
+					return FLOOR_ARG_INFO::IMG_2D_ARRAY;
+				case BuiltinType::OCLImage2dDepthRO:
+				case BuiltinType::OCLImage2dDepthWO:
+				case BuiltinType::OCLImage2dDepthRW:
+					return FLOOR_ARG_INFO::IMG_2D_DEPTH;
+				case BuiltinType::OCLImage2dArrayDepthRO:
+				case BuiltinType::OCLImage2dArrayDepthWO:
+				case BuiltinType::OCLImage2dArrayDepthRW:
+					return FLOOR_ARG_INFO::IMG_2D_ARRAY_DEPTH;
+				case BuiltinType::OCLImage2dMSAARO:
+				case BuiltinType::OCLImage2dMSAAWO:
+				case BuiltinType::OCLImage2dMSAARW:
+					return FLOOR_ARG_INFO::IMG_2D_MSAA;
+				case BuiltinType::OCLImage2dArrayMSAARO:
+				case BuiltinType::OCLImage2dArrayMSAAWO:
+				case BuiltinType::OCLImage2dArrayMSAARW:
+					return FLOOR_ARG_INFO::IMG_2D_ARRAY_MSAA;
+				case BuiltinType::OCLImage2dMSAADepthRO:
+				case BuiltinType::OCLImage2dMSAADepthWO:
+				case BuiltinType::OCLImage2dMSAADepthRW:
+					return FLOOR_ARG_INFO::IMG_2D_MSAA_DEPTH;
+				case BuiltinType::OCLImage2dArrayMSAADepthRO:
+				case BuiltinType::OCLImage2dArrayMSAADepthWO:
+				case BuiltinType::OCLImage2dArrayMSAADepthRW:
+					return FLOOR_ARG_INFO::IMG_2D_ARRAY_MSAA_DEPTH;
+				case BuiltinType::OCLImage3dRO:
+				case BuiltinType::OCLImage3dWO:
+				case BuiltinType::OCLImage3dRW:
+					return FLOOR_ARG_INFO::IMG_3D;
+				case BuiltinType::OCLImageCubeRO:
+				case BuiltinType::OCLImageCubeWO:
+				case BuiltinType::OCLImageCubeRW:
+					return FLOOR_ARG_INFO::IMG_CUBE;
+				case BuiltinType::OCLImageCubeArrayRO:
+				case BuiltinType::OCLImageCubeArrayWO:
+				case BuiltinType::OCLImageCubeArrayRW:
+					return FLOOR_ARG_INFO::IMG_CUBE_ARRAY;
+				case BuiltinType::OCLImageCubeDepthRO:
+				case BuiltinType::OCLImageCubeDepthWO:
+				case BuiltinType::OCLImageCubeDepthRW:
+					return FLOOR_ARG_INFO::IMG_CUBE_DEPTH;
+				case BuiltinType::OCLImageCubeArrayDepthRO:
+				case BuiltinType::OCLImageCubeArrayDepthWO:
+				case BuiltinType::OCLImageCubeArrayDepthRW:
+					return FLOOR_ARG_INFO::IMG_CUBE_ARRAY_DEPTH;
+#else
+				case BuiltinType::OCLImage1d:
+					return FLOOR_ARG_INFO::IMG_1D;
+				case BuiltinType::OCLImage1dArray:
+					return FLOOR_ARG_INFO::IMG_1D_ARRAY;
+				case BuiltinType::OCLImage1dBuffer:
+					return FLOOR_ARG_INFO::IMG_1D_BUFFER;
+				case BuiltinType::OCLImage2d:
+					return FLOOR_ARG_INFO::IMG_2D;
+				case BuiltinType::OCLImage2dArray:
+					return FLOOR_ARG_INFO::IMG_2D_ARRAY;
+				case BuiltinType::OCLImage2dDepth:
+					return FLOOR_ARG_INFO::IMG_2D_DEPTH;
+				case BuiltinType::OCLImage2dArrayDepth:
+					return FLOOR_ARG_INFO::IMG_2D_ARRAY_DEPTH;
+				case BuiltinType::OCLImage2dMSAA:
+					return FLOOR_ARG_INFO::IMG_2D_MSAA;
+				case BuiltinType::OCLImage2dArrayMSAA:
+					return FLOOR_ARG_INFO::IMG_2D_ARRAY_MSAA;
+				case BuiltinType::OCLImage2dMSAADepth:
+					return FLOOR_ARG_INFO::IMG_2D_MSAA_DEPTH;
+				case BuiltinType::OCLImage2dArrayMSAADepth:
+					return FLOOR_ARG_INFO::IMG_2D_ARRAY_MSAA_DEPTH;
+				case BuiltinType::OCLImage3d:
+					return FLOOR_ARG_INFO::IMG_3D;
+				case BuiltinType::OCLImageCube:
+					return FLOOR_ARG_INFO::IMG_CUBE;
+				case BuiltinType::OCLImageCubeArray:
+					return FLOOR_ARG_INFO::IMG_CUBE_ARRAY;
+				case BuiltinType::OCLImageCubeDepth:
+					return FLOOR_ARG_INFO::IMG_CUBE_DEPTH;
+				case BuiltinType::OCLImageCubeArrayDepth:
+					return FLOOR_ARG_INFO::IMG_CUBE_ARRAY_DEPTH;
+#endif
+				default: break;
+			}
+			return (FLOOR_ARG_INFO)~0ull;
+		};
+ 		const auto add_image_arg = [this, &file](const FLOOR_ARG_INFO& floor_img_type,
+ 												 const FLOOR_ARG_INFO& access) {
+			uint64_t arg_info = uint64_t(FLOOR_ARG_INFO::AS_IMAGE);
+			arg_info |= uint64_t(floor_img_type);
+			arg_info |= uint64_t(access);
+			file << arg_info << ",";
+		};
+		// anything that isn't a pointer or special type
+		const auto add_normal_arg = [this, &file,
+									 &compute_type_size](llvm::Type* llvm_type,
+														 const clang::QualType& clang_type,
+														 const FLOOR_ARG_INFO init_info = FLOOR_ARG_INFO::NONE) {
+			// for now: just use the direct type size + no address space
+			uint64_t arg_info = (uint64_t)init_info;
+			// handle some llvm weirdness? why can this be a pointer still?
+			if(llvm_type->isPointerTy()) {
+				arg_info |= compute_type_size(llvm_type->getPointerElementType());
+			}
+			else {
+				arg_info |= compute_type_size(llvm_type);
+			}
+			arg_info |= (uint64_t)to_fas(clang_type.getAddressSpace());
+			file << arg_info << ",";
+		};
+		
+		// #2+: argument sizes + types
+		if(clang_type->isPointerType() || clang_type->isReferenceType()) {
+			const auto clang_pointee_type = clang_type->getPointeeType();
+			const auto pointee_type = llvm_type->getPointerElementType();
+			
+			uint64_t arg_info = compute_type_size(pointee_type);
+			if(getLangOpts().OpenCL) {
+				// else: should be an error
+				arg_info |= (uint64_t)to_fas(clang_pointee_type.getAddressSpace());
+			}
+			else if(getLangOpts().CUDA) {
+				// always pretend this is global
+				arg_info |= (uint64_t)FLOOR_ARG_INFO::AS_GLOBAL;
+			}
+			file << arg_info << ",";
+		}
+		// handle image types
+		else if(clang_type->isImageType()) {
+			add_image_arg(img_type_to_floor_type(clang_type.getTypePtr()),
+						  get_image_access(parm->getAttr<ImageAccessAttr>()));
+		}
+		// aggregate of image types (used with opencl and metal)
+		else if(clang_type->isAggregateImageType()) {
+			const auto agg_images = get_aggregate_image_fields(cxx_rdecl);
+			
+			// image count must either be 1 (for single read or write images) or 2 (one read, one write image)
+			const auto field_count = agg_images.size();
+			if(field_count == 0) {
+				CGM.Error(cxx_rdecl->getSourceRange().getBegin(),
+						  StringRef("no images in aggregate-image (min: 1)"));
+				return;
+			}
+			else if(field_count > 2) {
+				CGM.Error(cxx_rdecl->getSourceRange().getBegin(),
+						  StringRef("too many images in aggregate-image (max: 2)"));
+				return;
+			}
+			
+			// sanity check that all field types are actually images, have proper access attributes and image types match
+			// (should probably put this somewhere else, since it is sema-checking, but then I'd need to duplicate code)
+			FLOOR_ARG_INFO floor_img_type = FLOOR_ARG_INFO::NONE;
+			uint64_t floor_img_access = 0;
+			for(const auto& img : agg_images) {
+				const auto access_attr = img->getAttr<ImageAccessAttr>();
+				if(access_attr == nullptr) {
+					CGM.Error(img->getSourceRange().getBegin(),
+							  StringRef("image type in an aggregate-image must have an access qualifier"));
+					return;
+				}
+				floor_img_access |= uint64_t(get_image_access(access_attr));
+				
+				// first field initializes this
+				const auto img_type = img->getType();
+				if(floor_img_type == FLOOR_ARG_INFO::NONE) {
+					floor_img_type = img_type_to_floor_type(img_type.getTypePtr());
+				}
+				else {
+					// second field must have the same type!
+					if(floor_img_type != img_type_to_floor_type(img_type.getTypePtr())) {
+						CGM.Error(img->getSourceRange().getBegin(),
+								  StringRef("second image in aggregate-image does not have the same type as the first"));
+						return;
+					}
+				}
+			}
+			
+			// if the aggregate has two image objects, one must be read, one must be write -> read/write
+			if(field_count == 2 && floor_img_access != uint64_t(FLOOR_ARG_INFO::IMG_ACCESS_READ_WRITE)) {
+				CGM.Error(cxx_rdecl->getSourceRange().getBegin(),
+						  StringRef("aggregate-image has 2 image fields, but joint access is not read-write"));
+				return;
+			}
+			
+			// everything works out, add this as a single kernel argument (floor backends will handle r/w images as necessary)
+			add_image_arg(floor_img_type, (FLOOR_ARG_INFO)floor_img_access);
+			
+			// 1 clang aggregate-image == 2 llvm image types -> inc index once more
+			if(field_count == 2) ++arg_idx;
+		}
+		// handle non-pointer parameters
+		else if(getLangOpts().CUDA) {
+			// is this an aggregate that is expanded into multiple llvm arguments?
+			if(cxx_rdecl &&
+			   abi_arg_info_iter->info.isDirect() &&
+			   TargetCodeGenInfo::isAggregateTypeForABI(abi_arg_info_iter->type)) {
+				// check if this is an aggregate image (must have image access qualifiers)
+				const ImageAccessAttr* access_attr = get_aggregate_access_attr(cxx_rdecl);
+				if(access_attr != nullptr) {
+					uint64_t arg_info = compute_type_size(llvm_type);
+					arg_info |= uint64_t(get_image_access(access_attr));
+					arg_info |= (uint64_t)FLOOR_ARG_INFO::AS_IMAGE;
+					file << arg_info << ",";
+				}
+				else {
+					// simple aggregate, all constant -> must handle each field individually
+					// note that we're only interested in the first expanded layer, not multiple expansion
+					// (i.e. fully scalarized), as this is identical to what cuda / nvptx / the abi do
+					uint64_t arg_info = 0; // sizes will be accumulated
+					const auto fields = get_aggregate_fields(cxx_rdecl);
+					for(size_t i = 0; i < fields.size(); ++i) {
+						const auto field_llvm_type = next(Fn->getArgumentList().begin(), arg_idx)->getType();
+						arg_info += compute_type_size(field_llvm_type);
+						++arg_idx;
+					}
+					arg_info |= (uint64_t)FLOOR_ARG_INFO::AS_CONSTANT;
+					file << arg_info << ",";
+					--arg_idx; // fixup, b/c of inc later
+				}
+			}
+			else {
+				// -> this is a simple constant (scalar or aggregate with scalar eval)
+				// store the parameter size
+				uint64_t arg_info = compute_type_size(llvm_type);
+				arg_info |= (uint64_t)FLOOR_ARG_INFO::AS_CONSTANT;
+				file << arg_info << ",";
+			}
+		}
+		// stage input
+		else if(parm->hasAttr<GraphicsStageInputAttr>()) {
+			if(!is_vertex && !is_fragment) {
+				// TODO: should check this in sema
+				// TODO: should also make sure that only 1 exists
+				CGM.Error(FD->getSourceRange().getBegin(), "[[stage_input]] only allowed on vertex and fragment functions");
+			}
+			
+			if(cxx_rdecl) {
+				// must handle each field individually
+				const auto fields = CGM.getTypes().get_aggregate_scalar_fields(cxx_rdecl, cxx_rdecl);
+				for(const auto& field : fields) {
+					// TODO: check if field type is int or float!
+					const auto field_llvm_type = next(Fn->getArgumentList().begin(), arg_idx)->getType();
+					add_normal_arg(field_llvm_type, field.type, FLOOR_ARG_INFO::STAGE_INPUT);
+					++arg_idx;
+				}
+				--arg_idx; // fixup, b/c of inc later
+			}
+			else {
+				// add as-is
+				// TODO: check if type is int or float!
+				add_normal_arg(llvm_type, clang_type, FLOOR_ARG_INFO::STAGE_INPUT);
+			}
+		}
+		else {
+			add_normal_arg(llvm_type, clang_type);
+		}
+		
+		// next arg
+		++arg_idx;
+		++abi_arg_info_iter;
+	}
+	
+	file << "\n";
+	
+	// if this is wrong, the kernel will almost certainly not be usable
+	if(arg_idx != Fn->arg_size()) {
+		// signal that this is _very_ bad
+		auto err_diagID = CGM.getDiags().getCustomDiagID(DiagnosticsEngine::Fatal, "kernel function parameter count mismatch: %0 (clang), %1 (llvm)");
+		CGM.getDiags().Report(FD->getSourceRange().getBegin(), err_diagID) << std::to_string(arg_idx) << std::to_string(Fn->arg_size());
+		
+		auto llvm_note_diagID = CGM.getDiags().getCustomDiagID(DiagnosticsEngine::Note, "LLVM function type: %0");
+		std::string llvm_fun_type = "";
+		llvm::raw_string_ostream llvm_fun_type_stream(llvm_fun_type);
+		Fn->getFunctionType()->print(llvm_fun_type_stream);
+		CGM.getDiags().Report(FD->getSourceRange().getBegin(), llvm_note_diagID) << llvm_fun_type_stream.str();
+		
+		auto clang_note_diagID = CGM.getDiags().getCustomDiagID(DiagnosticsEngine::Note, "clang function type: %0");
+		std::string clang_fun_type = "";
+		llvm::raw_string_ostream clang_fun_type_stream(clang_fun_type);
+		FD->getType().print(clang_fun_type_stream, Policy);
+		CGM.getDiags().Report(FD->getSourceRange().getBegin(), clang_note_diagID) << clang_fun_type_stream.str();
+		return;
+	}
 }
 
 void CodeGenFunction::EmitOpenCLKernelMetadata(const FunctionDecl *FD,
                                                llvm::Function *Fn)
 {
-  if (!FD->hasAttr<OpenCLKernelAttr>())
+  if (!FD->hasAttr<ComputeKernelAttr>() &&
+	  !FD->hasAttr<GraphicsVertexShaderAttr>() &&
+	  !FD->hasAttr<GraphicsFragmentShaderAttr>())
     return;
 
   llvm::LLVMContext &Context = getLLVMContext();
 
   SmallVector<llvm::Metadata *, 5> kernelMDArgs;
-  kernelMDArgs.push_back(llvm::ConstantAsMetadata::get(Fn));
+  if (!CGM.getLangOpts().Metal) {
+    kernelMDArgs.push_back(llvm::ConstantAsMetadata::get(Fn));
+  }
+  else { // -> need to id/size handling args to the kernel function type
+	  // add original arg types
+	  SmallVector<llvm::Type*, 16> arg_types;
+	  for(const auto& arg : Fn->args()) {
+		  arg_types.push_back(arg.getType());
+	  }
+	  
+	  if(FD->hasAttr<ComputeKernelAttr>()) {
+		  // add id types
+		  const auto id_vec_type = llvm::VectorType::get(llvm::Type::getInt32Ty(Context), 3);
+		  for(int i = 0; i < 6; ++i) arg_types.push_back(id_vec_type);
+	  }
+	  else if(FD->hasAttr<GraphicsVertexShaderAttr>()) {
+		  // only vertex id for now
+		  arg_types.push_back(llvm::Type::getInt32Ty(Context));
+	  }
+	  else if(FD->hasAttr<GraphicsFragmentShaderAttr>()) {
+		  // only point coord for now
+		  const auto pc_vec_type = llvm::VectorType::get(llvm::Type::getFloatTy(Context), 2);
+		  arg_types.push_back(pc_vec_type);
+	  }
+	  
+	  // create + add new function type
+	  const auto func_type_with_ids = llvm::FunctionType::get(Fn->getReturnType(), arg_types, false);
+	  Fn->mutateType(llvm::PointerType::get(func_type_with_ids, 0));
+	  Fn->mutateFunctionType(func_type_with_ids);
+	  kernelMDArgs.push_back(llvm::ConstantAsMetadata::get(Fn));
+  }
+
+  if (CGM.getCodeGenOpts().EmitOpenCLArgMetadata && !CGM.getCodeGenOpts().EmitAppleCLMetadata)
+    GenOpenCLArgMetadata(FD, Fn, CGM, Context, kernelMDArgs, Builder,
+                         getContext());
 
-  GenOpenCLArgMetadata(FD, Fn, CGM, Context, kernelMDArgs, Builder,
-                       getContext());
+  if (CGM.getLangOpts().Metal)
+    GenAIRMetadata(FD, Fn, CGM, Context, kernelMDArgs, Builder, getContext());
+
+  if (CGM.getCodeGenOpts().EmitAppleCLMetadata)
+    GenAppleCLMetadata(FD, Fn, CGM, Context, kernelMDArgs, Builder, getContext());
 
   if (const VecTypeHintAttr *A = FD->getAttr<VecTypeHintAttr>()) {
     QualType hintQTy = A->getTypeHint();
     const ExtVectorType *hintEltQTy = hintQTy->getAs<ExtVectorType>();
-    bool isSignedInteger =
+    bool isSignedType =
         hintQTy->isSignedIntegerType() ||
-        (hintEltQTy && hintEltQTy->getElementType()->isSignedIntegerType());
+        (hintEltQTy && hintEltQTy->getElementType()->isSignedIntegerType()) ||
+        hintQTy->isFloatingType() ||
+        (hintEltQTy && hintEltQTy->getElementType()->isFloatingType());
     llvm::Metadata *attrMDArgs[] = {
         llvm::MDString::get(Context, "vec_type_hint"),
         llvm::ConstantAsMetadata::get(llvm::UndefValue::get(
             CGM.getTypes().ConvertType(A->getTypeHint()))),
         llvm::ConstantAsMetadata::get(llvm::ConstantInt::get(
             llvm::IntegerType::get(Context, 32),
-            llvm::APInt(32, (uint64_t)(isSignedInteger ? 1 : 0))))};
+            llvm::APInt(32, (uint64_t)(isSignedType ? 1 : 0))))};
     kernelMDArgs.push_back(llvm::MDNode::get(Context, attrMDArgs));
   }
 
@@ -635,9 +2054,52 @@ void CodeGenFunction::EmitOpenCLKernelMetadata(const FunctionDecl *FD,
   }
 
   llvm::MDNode *kernelMDNode = llvm::MDNode::get(Context, kernelMDArgs);
-  llvm::NamedMDNode *OpenCLKernelMetadata =
-    CGM.getModule().getOrInsertNamedMetadata("opencl.kernels");
-  OpenCLKernelMetadata->addOperand(kernelMDNode);
+  llvm::NamedMDNode *MainMetadataNode;
+  if(!CGM.getLangOpts().Metal) {
+	  MainMetadataNode = CGM.getModule().getOrInsertNamedMetadata("opencl.kernels");
+  }
+  else {
+    MainMetadataNode = CGM.getModule().getOrInsertNamedMetadata(
+      (FD->hasAttr<GraphicsVertexShaderAttr>() ? "air.vertex" :
+       (FD->hasAttr<GraphicsFragmentShaderAttr>() ? "air.fragment" : "air.kernel")));
+  }
+  MainMetadataNode->addOperand(kernelMDNode);
+
+  // additional air info
+  if(CGM.getLangOpts().Metal) {
+	  // only do this once
+	  llvm::NamedMDNode *AIRVersion = CGM.getModule().getOrInsertNamedMetadata("air.version");
+	  if(AIRVersion->getNumOperands() > 0) return;
+	  
+	  // NOTE: this is fixed for now as only compiling in metal1.1 mode is possible
+	  const uint32_t metal_version[] = { 1, 8, 0 };
+	  const uint32_t metal_language_version[] = { 1, 1, 0 };
+	  
+	  SmallVector <llvm::Metadata*, 3> air_version;
+	  air_version.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(metal_version[0])));
+	  air_version.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(metal_version[1])));
+	  air_version.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(metal_version[2])));
+	  AIRVersion->addOperand(llvm::MDNode::get(Context, air_version));
+	  
+	  llvm::NamedMDNode *AIRLangVersion = CGM.getModule().getOrInsertNamedMetadata("air.language_version");
+	  SmallVector <llvm::Metadata*, 4> air_lang_version;
+	  air_lang_version.push_back(llvm::MDString::get(Context, "METAL"));
+	  air_lang_version.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(metal_language_version[0])));
+	  air_lang_version.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(metal_language_version[1])));
+	  air_lang_version.push_back(llvm::ConstantAsMetadata::get(Builder.getInt32(metal_language_version[2])));
+	  AIRLangVersion->addOperand(llvm::MDNode::get(Context, air_lang_version));
+	  
+	  llvm::NamedMDNode *AIRCompOpts = CGM.getModule().getOrInsertNamedMetadata("air.compile_options");
+	  AIRCompOpts->addOperand(llvm::MDNode::get(Context,
+												llvm::MDString::get(Context, "air.compile.denorms_disable")));
+	  AIRCompOpts->addOperand(llvm::MDNode::get(Context,
+												llvm::MDString::get(Context, "air.compile.fast_math_enable")));
+	  AIRCompOpts->addOperand(llvm::MDNode::get(Context,
+												llvm::MDString::get(Context, "air.compile.framebuffer_fetch_disable")));
+	  AIRCompOpts->addOperand(llvm::MDNode::get(Context,
+												llvm::MDString::get(Context, "air.compile.native_double_disable")));
+  }
+  // NOTE: additional/global opencl metadata is handled in CGSPIRMetadataAdder
 }
 
 /// Determine whether the function F ends with a return stmt.
@@ -667,6 +2129,7 @@ void CodeGenFunction::StartFunction(GlobalDecl GD,
          "Do not use a CodeGenFunction object for more than one function");
 
   const Decl *D = GD.getDecl();
+  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);
 
   DidCallStackSave = false;
   CurCodeDecl = D;
@@ -698,7 +2161,7 @@ void CodeGenFunction::StartFunction(GlobalDecl GD,
   // Pass inline keyword to optimizer if it appears explicitly on any
   // declaration. Also, in the case of -fno-inline attach NoInline
   // attribute to all function that are not marked AlwaysInline.
-  if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D)) {
+  if (FD) {
     if (!CGM.getCodeGenOpts().NoInline) {
       for (auto RI : FD->redecls())
         if (RI->isInlineSpecified()) {
@@ -709,16 +2172,37 @@ void CodeGenFunction::StartFunction(GlobalDecl GD,
       Fn->addFnAttr(llvm::Attribute::NoInline);
   }
 
-  if (getLangOpts().OpenCL) {
-    // Add metadata for a kernel function.
-    if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D))
+  // emit compute metadata
+  if (getLangOpts().OpenCL || getLangOpts().CUDA) {
+    if(FD) {
+      // add floor specific metadata for kernel functions
+      EmitFloorKernelMetadata(FD, Fn, Args, FnInfo);
+
+      // add "compute_kernel" llvm function attribute if this is a kernel function
+      if (FD->hasAttr<ComputeKernelAttr>()) {
+        Fn->addFnAttr("compute_kernel");
+      }
+      // add "vertex_shader" llvm function attribute if this is a vertex shader
+      if (FD->hasAttr<GraphicsVertexShaderAttr>()) {
+        Fn->addFnAttr("vertex_shader");
+      }
+      // add "fragment_shader" llvm function attribute if this is a fragment shader
+      if (FD->hasAttr<GraphicsFragmentShaderAttr>()) {
+        Fn->addFnAttr("fragment_shader");
+      }
+    }
+    
+    // opencl/spir and metal specific metadata
+    if (getLangOpts().OpenCL) {
+      // Add metadata for a kernel function.
       EmitOpenCLKernelMetadata(FD, Fn);
+    }
   }
 
   // If we are checking function types, emit a function type signature as
   // prologue data.
   if (getLangOpts().CPlusPlus && SanOpts.has(SanitizerKind::Function)) {
-    if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D)) {
+    if (FD) {
       if (llvm::Constant *PrologueSig =
               CGM.getTargetCodeGenInfo().getUBSanFunctionSignature(CGM)) {
         llvm::Constant *FTRTTIConst =
@@ -735,7 +2219,7 @@ void CodeGenFunction::StartFunction(GlobalDecl GD,
   // to be norecurse by the standard (3.6.1.3 "The function main shall not be
   // used within a program").
   if (getLangOpts().CPlusPlus)
-    if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D))
+    if (FD)
       if (FD->isMain())
         Fn->addFnAttr(llvm::Attribute::NoRecurse);
   
@@ -798,7 +2282,16 @@ void CodeGenFunction::StartFunction(GlobalDecl GD,
     Addr = Builder.CreateAlignedLoad(Addr, getPointerAlign(), "agg.result");
     ReturnValue = Address(Addr, getNaturalTypeAlignment(RetTy));
   } else {
-    ReturnValue = CreateIRTemp(RetTy, "retval");
+    // fix retval allocation for vertex/fragment shader return values (use the computed coerce type)
+    if(FD &&
+       (FD->hasAttr<GraphicsVertexShaderAttr>() ||
+        FD->hasAttr<GraphicsFragmentShaderAttr>())) {
+      auto RetAlloc = CreateTempAlloca(FnInfo.getReturnInfo().getCoerceToType(), "retval");
+      CharUnits Align = getContext().getTypeAlignInChars(RetTy);
+      RetAlloc->setAlignment(Align.getQuantity());
+      ReturnValue = Address(RetAlloc, Align);
+    }
+    else ReturnValue = CreateIRTemp(RetTy, "retval");
 
     // Tell the epilog emitter to autorelease the result.  We do this
     // now so that various specialized functions can suppress it
@@ -828,11 +2321,11 @@ void CodeGenFunction::StartFunction(GlobalDecl GD,
         CXXThisValue = EmitLoadOfLValue(ThisLValue,
                                         SourceLocation()).getScalarVal();
       }
-      for (auto *FD : MD->getParent()->fields()) {
-        if (FD->hasCapturedVLAType()) {
-          auto *ExprArg = EmitLoadOfLValue(EmitLValueForLambdaField(FD),
+      for (auto *field : MD->getParent()->fields()) {
+        if (field->hasCapturedVLAType()) {
+          auto *ExprArg = EmitLoadOfLValue(EmitLValueForLambdaField(field),
                                            SourceLocation()).getScalarVal();
-          auto VAT = FD->getCapturedVLAType();
+          auto VAT = field->getCapturedVLAType();
           VLASizeMap[VAT->getSizeExpr()] = ExprArg;
         }
       }
@@ -914,6 +2407,91 @@ static void TryMarkNoThrow(llvm::Function *F) {
   F->setDoesNotThrow();
 }
 
+void CodeGenFunction::EmitAppleCLKernelAnnotation(GlobalDecl& GD, llvm::Function* Fn) {
+	if(!getLangOpts().OpenCL) return;
+	
+	if(const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(GD.getDecl())) {
+		// Add global applecl kernel annotations.
+		if(CGM.getCodeGenOpts().EmitAppleCLMetadata && FD->hasAttr<ComputeKernelAttr>()) {
+			// go through all local decls and find the local memory decls
+			std::vector<llvm::Constant*> lmem_refs;
+			for(const auto& I : LocalDeclMap) {
+				const Decl* local_decl = I.first;
+				Address Addr = I.second;
+				if(dyn_cast<llvm::GlobalValue>(Addr.getPointer())) {
+					const VarDecl* lmem_VD = cast<VarDecl>(local_decl);
+					if(lmem_VD->getType().getAddressSpace() == LangAS::opencl_local) {
+						lmem_refs.push_back(CGM.getStaticLocalDeclAddress(lmem_VD));
+					}
+				}
+			}
+			
+			// go through kernel arguments and set info
+			// "global float* a, global const float* b, constant float* c, constant const float* d, local float* e,
+			//  float f, const float g, read_only image2d_t h, write_only image2d_t i, read_write image2d_t j"
+			// -> "218890056a"
+			// TODO: sampler is "4" (NOTE: all other "numbers/chars" are unused)
+			std::string arg_info = "";
+			for(const auto& parm : FD->params()) {
+				const auto clang_type = parm->getType();
+				
+				const auto add_image_arg = [&arg_info](const ImageAccessAttr* access_attr) {
+					// access qualifier
+					if(access_attr && access_attr->isWriteOnly()) {
+						arg_info += "6";
+					}
+					else if(access_attr && access_attr->isReadWrite()) {
+						arg_info += "a";
+					}
+					else {
+						arg_info += "5";
+					}
+				};
+				
+				// storage type (stream or image)
+				if(clang_type->isPointerType() || clang_type->isReferenceType()) {
+					// access qualifier
+					const auto clang_pointee_type = clang_type->getPointeeType();
+					bool read_only = false;
+					if(clang_pointee_type.isConstQualified() ||
+					   (clang_pointee_type.getAddressSpace() == LangAS::opencl_constant)) {
+						read_only = true;
+					}
+					
+					// address space
+					switch(clang_pointee_type.getAddressSpace()) {
+						case LangAS::opencl_global:
+							arg_info += (read_only ? "1" : "2");
+							break;
+						case LangAS::opencl_local:
+							arg_info += "9";
+							break;
+						case LangAS::opencl_constant:
+							arg_info += "8";
+							break;
+					}
+				}
+				else if(clang_type->isImageType()) {
+					add_image_arg(parm->getAttr<ImageAccessAttr>());
+				}
+				else if(clang_type->isAggregateImageType()) {
+					const auto decl = clang_type->getAsCXXRecordDecl();
+					const auto agg_images = get_aggregate_image_fields(decl);
+					for(const auto& img : agg_images) {
+						add_image_arg(img->getAttr<ImageAccessAttr>());
+					}
+				}
+				else {
+					// simple kernel parameter (not a buffer)
+					arg_info += "0";
+				}
+			}
+			
+			CGM.AddAppleCLKernelAnnotation(Fn, arg_info, lmem_refs);
+		}
+	}
+}
+
 void CodeGenFunction::GenerateCode(GlobalDecl GD, llvm::Function *Fn,
                                    const CGFunctionInfo &FnInfo) {
   const FunctionDecl *FD = cast<FunctionDecl>(GD.getDecl());
@@ -979,7 +2557,7 @@ void CodeGenFunction::GenerateCode(GlobalDecl GD, llvm::Function *Fn,
     EmitConstructorBody(Args);
   else if (getLangOpts().CUDA &&
            !getLangOpts().CUDAIsDevice &&
-           FD->hasAttr<CUDAGlobalAttr>())
+           FD->hasAttr<ComputeKernelAttr>())
     CGM.getCUDARuntime().emitDeviceStub(*this, Args);
   else if (isa<CXXConversionDecl>(FD) &&
            cast<CXXConversionDecl>(FD)->isLambdaToBlockPointerConversion()) {
@@ -1026,6 +2604,10 @@ void CodeGenFunction::GenerateCode(GlobalDecl GD, llvm::Function *Fn,
   // Emit the standard function epilogue.
   FinishFunction(BodyRange.getEnd());
 
+  // emit applecl metadata and global annotations
+  // note that this must be done at the end, because we need access to local memory declarations
+  EmitAppleCLKernelAnnotation(GD, Fn);
+
   // If we haven't marked the function nothrow through other means, do
   // a quick pass now to see if we can.
   if (!CurFn->doesNotThrow())
diff --git a/lib/CodeGen/CodeGenFunction.h b/lib/CodeGen/CodeGenFunction.h
index 4803b13..0e2c0f2 100644
--- a/lib/CodeGen/CodeGenFunction.h
+++ b/lib/CodeGen/CodeGenFunction.h
@@ -1104,6 +1104,13 @@ private:
   void EmitOpenCLKernelMetadata(const FunctionDecl *FD, 
                                 llvm::Function *Fn);
 
+  void EmitFloorKernelMetadata(const FunctionDecl *FD,
+                               llvm::Function *Fn,
+                               const FunctionArgList &Args,
+                               const CGFunctionInfo &FnInfo);
+
+  void EmitAppleCLKernelAnnotation(GlobalDecl& GD, llvm::Function* Fn);
+	
 public:
   CodeGenFunction(CodeGenModule &cgm, bool suppressNewContext=false);
   ~CodeGenFunction();
@@ -1260,6 +1267,11 @@ public:
                                         const DeclMapTy &ldm,
                                         bool IsLambdaConversionToBlock);
 
+  llvm::Value *GenerateOCLBlockBind(llvm::Constant *blockFunc,
+                                    int ctxSize,
+                                    int ctxAlign,
+                                    llvm::Value *ctx);
+
   llvm::Constant *GenerateCopyHelperFunction(const CGBlockInfo &blockInfo);
   llvm::Constant *GenerateDestroyHelperFunction(const CGBlockInfo &blockInfo);
   llvm::Constant *GenerateObjCAtomicSetterCopyHelperFunction(
diff --git a/lib/CodeGen/CodeGenModule.cpp b/lib/CodeGen/CodeGenModule.cpp
index 97b1662..e715540 100644
--- a/lib/CodeGen/CodeGenModule.cpp
+++ b/lib/CodeGen/CodeGenModule.cpp
@@ -19,6 +19,7 @@
 #include "CGDebugInfo.h"
 #include "CGObjCRuntime.h"
 #include "CGOpenCLRuntime.h"
+#include "CGSPIRMetadataAdder.h"
 #include "CGOpenMPRuntime.h"
 #include "CodeGenFunction.h"
 #include "CodeGenPGO.h"
@@ -428,7 +429,10 @@ void CodeGenModule::Release() {
     // parser will drop debug info with a different version number
     // (and warn about it, too).
     getModule().addModuleFlag(llvm::Module::Warning, "Debug Info Version",
-                              llvm::DEBUG_METADATA_VERSION);
+                              Context.getTargetInfo().getTriple().getOS() != llvm::Triple::IOS ?
+                              llvm::DEBUG_METADATA_VERSION :
+                              // metal/ios uses/requires a very specific metadata version number
+                              llvm::IOS_METAL_DEBUG_METADATA_VERSION);
 
   // We need to record the widths of enums and wchar_t, so that we can generate
   // the correct build attributes in the ARM backend.
@@ -466,6 +470,9 @@ void CodeGenModule::Release() {
 
   SimplifyPersonality();
 
+  if (getLangOpts().OpenCL && !getLangOpts().Metal)
+    EmitOCLAnnotations();
+
   if (getCodeGenOpts().EmitDeclMetadata)
     EmitDeclMetadata();
 
@@ -475,6 +482,32 @@ void CodeGenModule::Release() {
   if (DebugInfo)
     DebugInfo->finalize();
 
+  if (TheModule.getTargetTriple() == "spir-unknown-unknown" ||
+      TheModule.getTargetTriple() == "spir64-unknown-unknown") {
+    std::list<std::string> sBuildOptions;
+    std::string tmp = getCodeGenOpts().SPIRCompileOptions;
+    while (!tmp.empty()) {
+      auto first = tmp.find_first_not_of(' ');
+      auto last = tmp.find_first_of(' ', first);
+
+      std::string s;
+      if (last != std::string::npos)
+        s = tmp.substr(first, last-first);
+      else if (first != std::string::npos)
+        s = tmp.substr(first);
+      else
+        s = "";
+
+      if (!s.empty())
+        sBuildOptions.push_back(s);
+
+      if (last != std::string::npos)
+        tmp = tmp.substr(last);
+      else
+        tmp = "";
+    }
+    AddSPIRMetadata(TheModule, getLangOpts().OpenCLVersion, sBuildOptions, getContext().OpenCLFeatures);
+  }
   EmitVersionIdentMetadata();
 
   EmitTargetMetadata();
@@ -1293,6 +1326,108 @@ void CodeGenModule::EmitGlobalAnnotations() {
   gv->setSection(AnnotationSection);
 }
 
+void CodeGenModule::EmitOCLAnnotations() {
+  // For SPIR, we generate this metadata in a seperate pass
+  if (getTarget().getTriple().getArch() != llvm::Triple::spir &&
+    getTarget().getTriple().getArch() != llvm::Triple::spir64)
+    EmitOCLBuildOptions();
+
+  if (!Context.isFPContractDisabled() && (0 != getLangOpts().DefaultFPContract))
+  {
+    TheModule.getOrInsertNamedMetadata("opencl.enable.FP_CONTRACT");
+  }
+}
+
+llvm::SmallVector<llvm::Metadata *, 5> CodeGenModule::getBuildOptions() {
+  llvm::SmallVector<llvm::Metadata *, 5> BuildOption;
+
+  if(!getLangOpts().OpenCL)
+    return BuildOption;
+
+  // Math Intrinsics Options
+  if(getLangOpts().SinglePrecisionConstants)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-single-precision-constant")));
+
+  if(getCodeGenOpts().DenormsAreZero)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-denorms-are-zero")));
+
+  if(getCodeGenOpts().CorrectFPDivideSqrt)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-fp32-correctly-rounded-divide-sqrt")));
+
+  //Optimization Options
+  if(getCodeGenOpts().OptDisable)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-opt-disable")));
+
+  if(getCodeGenOpts().LessPreciseFPMAD)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-mad-enable")));
+
+  if(getCodeGenOpts().NoSignedZeros)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-no-signed-zeros")));
+
+  if(getCodeGenOpts().UnsafeFPMath)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-unsafe-math-optimizations")));
+
+  if(getCodeGenOpts().NoInfsFPMath)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-finite-math-only")));
+
+  if(getLangOpts().FastRelaxedMath)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-fast-relaxed-math")));
+
+  if(getCodeGenOpts().getDebugInfo() != CodeGenOptions::NoDebugInfo)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-g")));
+
+  //Options Controlling the OpenCL C version
+  if(110 == getLangOpts().OpenCLVersion)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-std=CL1.1")));
+
+  if(120 == getLangOpts().OpenCLVersion)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-std=CL1.2")));
+
+  if(200 == getLangOpts().OpenCLVersion)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-std=CL2.0")));
+
+  if(210 == getLangOpts().OpenCLVersion)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-std=CL2.1")));
+
+  if(220 == getLangOpts().OpenCLVersion)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-std=CL2.2")));
+
+  // Options for Querying Kernel Argument Information
+  if(getCodeGenOpts().EmitOpenCLArgMetadata)
+    BuildOption.push_back(llvm::MDString::get(
+    VMContext, llvm::StringRef("-cl-kernel-arg-info")));
+
+  return BuildOption;
+}
+
+void CodeGenModule::EmitOCLBuildOptions()
+{
+  llvm::SmallVector<llvm::Metadata *, 5> BuildOptions = getBuildOptions();
+
+  if (BuildOptions.empty())
+    return;
+
+  llvm::NamedMDNode *OpenCLMetadata =
+    TheModule.getOrInsertNamedMetadata("opencl.compiler.options");
+
+  OpenCLMetadata->addOperand(llvm::MDNode::get(VMContext, BuildOptions));
+}
+
 llvm::Constant *CodeGenModule::EmitAnnotationString(StringRef Str) {
   llvm::Constant *&AStr = AnnotationStrings[Str];
   if (AStr)
@@ -1351,6 +1486,39 @@ void CodeGenModule::AddGlobalAnnotations(const ValueDecl *D,
     Annotations.push_back(EmitAnnotateAttr(GV, I, D->getLocation()));
 }
 
+void CodeGenModule::AddAppleCLKernelAnnotation(llvm::Function* Fn, const std::string& sgv_str,
+											   std::vector<llvm::Constant*> lmem_refs) {
+	// sgv contains the argument type information
+	llvm::Constant* sgv_data = llvm::ConstantDataArray::getString(getLLVMContext(), sgv_str);
+	llvm::Constant* sgv = new llvm::GlobalVariable(getModule(), sgv_data->getType(), true,
+												   llvm::GlobalValue::InternalLinkage, sgv_data, "sgv");
+	
+	// fgv is always empty (would usually contain the file name)
+	llvm::Constant* fgv_data = llvm::ConstantDataArray::getString(getLLVMContext(), "", false);
+	llvm::Constant* fgv = new llvm::GlobalVariable(getModule(), fgv_data->getType(), true,
+												   llvm::GlobalValue::InternalLinkage, fgv_data, "fgv");
+	
+	// lvgv contains the pointers to local memory decls
+	std::vector<llvm::Constant*> lvgv_data;
+	for(const auto& lmem : lmem_refs) {
+		lvgv_data.push_back(llvm::ConstantExpr::getBitCast(lmem, Int8PtrTy));
+	}
+	llvm::Constant* lvgv_container = llvm::ConstantArray::get(llvm::ArrayType::get(Int8PtrTy, lmem_refs.size()), lvgv_data);
+	llvm::Constant* lvgv = new llvm::GlobalVariable(getModule(), lvgv_container->getType(), true,
+													llvm::GlobalValue::InternalLinkage, lvgv_container, "lvgv");
+	
+	// Create the ConstantStruct for the global annotation.
+	llvm::Constant *Fields[5] = {
+		llvm::ConstantExpr::getBitCast(Fn, Int8PtrTy),
+		llvm::ConstantExpr::getBitCast(sgv, Int8PtrTy),
+		llvm::ConstantExpr::getBitCast(fgv, Int8PtrTy),
+		llvm::ConstantExpr::getBitCast(lvgv, Int8PtrTy),
+		// always 0?
+		llvm::ConstantInt::get(Int32Ty, 0)
+	};
+	Annotations.push_back(llvm::ConstantStruct::getAnon(Fields));
+}
+
 bool CodeGenModule::isInSanitizerBlacklist(llvm::Function *Fn,
                                            SourceLocation Loc) const {
   const auto &SanitizerBL = getContext().getSanitizerBlacklist();
@@ -1491,23 +1659,6 @@ void CodeGenModule::EmitGlobal(GlobalDecl GD) {
   if (Global->hasAttr<AliasAttr>())
     return EmitAliasDefinition(GD);
 
-  // If this is CUDA, be selective about which declarations we emit.
-  if (LangOpts.CUDA) {
-    if (LangOpts.CUDAIsDevice) {
-      if (!Global->hasAttr<CUDADeviceAttr>() &&
-          !Global->hasAttr<CUDAGlobalAttr>() &&
-          !Global->hasAttr<CUDAConstantAttr>() &&
-          !Global->hasAttr<CUDASharedAttr>())
-        return;
-    } else {
-      if (!Global->hasAttr<CUDAHostAttr>() && (
-            Global->hasAttr<CUDADeviceAttr>() ||
-            Global->hasAttr<CUDAConstantAttr>() ||
-            Global->hasAttr<CUDASharedAttr>()))
-        return;
-    }
-  }
-
   // If this is OpenMP device, check if it is legal to emit this global
   // normally.
   if (OpenMPRuntime && OpenMPRuntime->emitTargetGlobal(GD))
@@ -2377,7 +2528,12 @@ void CodeGenModule::EmitGlobalVarDefinition(const VarDecl *D) {
       (D->hasAttr<CUDAConstantAttr>() || D->hasAttr<CUDADeviceAttr>())) {
     GV->setExternallyInitialized(true);
   }
-  GV->setInitializer(Init);
+  if (LangOpts.OpenCL && D->getType()->isBlockPointerType()) {
+    GV->eraseFromParent();
+    OCLGlobalBlockFunctions[D] = Init;
+    return;
+  } else
+    GV->setInitializer(Init);
 
   // If it is safe to mark the global 'constant', do so now.
   GV->setConstant(!NeedsGlobalCtor && !NeedsGlobalDtor &&
@@ -2703,12 +2859,49 @@ void CodeGenModule::HandleCXXStaticMemberVarInstantiation(VarDecl *VD) {
   EmitTopLevelDecl(VD);
 }
 
+static llvm::Type* MetalExpandReturnType(const CanQualType& type,
+										 llvm::Type* llvm_type,
+										 CodeGenTypes& CGT) {
+	const llvm::StructType* ST = dyn_cast<llvm::StructType>(llvm_type);
+	if(!ST) return llvm_type;
+	
+	const auto cxx_rdecl = type->getAsCXXRecordDecl();
+	
+	// if the top decl already is a compat vector, return it directly
+	if(cxx_rdecl->hasAttr<VectorCompatAttr>()) {
+		return CGT.ConvertType(CGT.get_compat_vector_type(cxx_rdecl));
+	}
+	
+	// else: extract all fields and create a flat llvm struct from them
+	const auto fields = CGT.get_aggregate_scalar_fields(cxx_rdecl, cxx_rdecl);
+	std::vector<llvm::Type*> llvm_fields;
+	for(const auto& field : fields) {
+		llvm_fields.push_back(CGT.ConvertType(field.type));
+	}
+	
+	// TODO: only create once?
+	const std::string name = "__floor.flat." + cxx_rdecl->getName().str();
+	auto ret = llvm::StructType::create(llvm_fields, name, true); // always make this packed
+	ret->setMetalReturnType(); // fix up alignment/sizes/offsets
+	CGT.create_flattened_cg_layout(cxx_rdecl, ret, fields); // create corresponding flattend CGRecordLayout
+	return ret;
+}
+
 void CodeGenModule::EmitGlobalFunctionDefinition(GlobalDecl GD,
                                                  llvm::GlobalValue *GV) {
   const auto *D = cast<FunctionDecl>(GD.getDecl());
 
   // Compute the function info and LLVM type.
   const CGFunctionInfo &FI = getTypes().arrangeGlobalDeclaration(GD);
+  if(getLangOpts().Metal && D &&
+     FI.getReturnType()->isStructureOrClassType() &&
+     (D->hasAttr<GraphicsVertexShaderAttr>() ||
+      D->hasAttr<GraphicsFragmentShaderAttr>())) {
+    // if this is a vertex/fragment shader function and the return type is a struct/aggregate,
+    // fully expand/flatten all types within (i.e. structs and arrays to scalars, keep existing scalars)
+    auto& retInfo = (ABIArgInfo&)FI.getReturnInfo();
+    retInfo.setCoerceToType(MetalExpandReturnType(FI.getReturnType(), retInfo.getCoerceToType(), getTypes()));
+  }
   llvm::FunctionType *Ty = getTypes().GetFunctionType(FI);
 
   // Get or create the prototype for the function.
@@ -2803,7 +2996,7 @@ void CodeGenModule::EmitAliasDefinition(GlobalDecl GD) {
     // Remove it and replace uses of it with the alias.
     GA->takeName(Entry);
 
-    Entry->replaceAllUsesWith(llvm::ConstantExpr::getBitCast(GA,
+    Entry->replaceAllUsesWith(llvm::ConstantExpr::getPointerBitCastOrAddrSpaceCast(GA,
                                                           Entry->getType()));
     Entry->eraseFromParent();
   } else {
@@ -3936,6 +4129,72 @@ void CodeGenModule::EmitOMPThreadPrivateDecl(const OMPThreadPrivateDecl *D) {
   }
 }
 
+llvm::Constant*
+CodeGenModule::createIntToSamplerConversion(const Expr *E,
+                                            CodeGenFunction *CGF,
+                                            llvm::GlobalVariable *InsertBefore,
+                                            StringRef Name) {
+  llvm::Constant *C = EmitConstantExpr(E, E->getType(), CGF);
+  assert(C && "Sampler must be initialized by constant");
+  assert(isa<llvm::ConstantInt>(C) && "Sampler must be initialized by integer");
+  if (!getLangOpts().CLSamplerOpaque)
+    return C;
+
+  llvm::StructType*
+    ConstSamplerTy = TheModule.getTypeByName("spirv.ConstantSampler");
+  if (!ConstSamplerTy ) {
+    llvm::Type* Elements[] = {Int32Ty, Int32Ty, Int32Ty};
+    ConstSamplerTy = llvm::StructType::create(VMContext, Elements,
+                                              "spirv.ConstantSampler");
+  }
+  const llvm::ConstantInt *CI = static_cast<llvm::ConstantInt*>(C);
+  const uint64_t SamplerValue = CI->getValue().getZExtValue();
+  // 32-bit value of sampler's initializer is interpreted as
+  // bit-field with the following structure:
+  // |unspecified|Filter|Addressing Mode| Normalized Coords|
+  // |31        6|5    4|3             1|                 0|
+  // This structure corresponds to values of sampler properties from opencl.h
+  // Mapping these bits to values defined by SPIR-V specification.
+  unsigned NormalizedCoords = 0x01 & SamplerValue;
+  unsigned AddressingMode  = (0x0E & SamplerValue) >> 1;
+  unsigned FilterMode      = (0x30 & SamplerValue) >> 4;
+  // In SPIR sampler's filter bits are defined as the following
+  // #define CLK_FILTER_NEAREST 0x10
+  // #define CLK_FILTER_LINEAR 0x20
+  // corresponding to 1 and 2 in bits 4-5.
+  // SPIR-V defines sampler filter mode enum as: nearest=0, linear=1,
+  // Therefore, to convert FilterMode from SPIR to SPIR-V,
+  // FilterMode value must be decremented
+  if (FilterMode == 1 || FilterMode == 2)
+    --FilterMode;
+   else
+    getDiags().Report(Context.getFullLoc(E->getLocStart()),
+      diag::warn_sampler_initializer_invalid_bits) << "Filter Mode";
+  if (AddressingMode > 4)
+    getDiags().Report(Context.getFullLoc(E->getLocStart()),
+      diag::warn_sampler_initializer_invalid_bits) << "Addressing Mode";
+
+  llvm::Constant *Initializer = llvm::ConstantStruct::get(ConstSamplerTy,
+    llvm::ConstantInt::get(Int32Ty, AddressingMode),
+    llvm::ConstantInt::get(Int32Ty, NormalizedCoords),
+    llvm::ConstantInt::get(Int32Ty, FilterMode),
+    nullptr);
+  llvm::StructType*
+    SamplerTy = TheModule.getTypeByName("spirv.Sampler");
+  if(!SamplerTy)
+    SamplerTy = llvm::StructType::create(VMContext, "spirv.Sampler");
+
+  unsigned AS = Context.getTargetAddressSpace(LangAS::opencl_constant);
+  llvm::GlobalVariable *GV =
+    new llvm::GlobalVariable(TheModule, ConstSamplerTy, true,
+                             llvm::GlobalVariable::InternalLinkage,
+                             Initializer, Name + ".sampler.init", InsertBefore,
+                             llvm::GlobalVariable::NotThreadLocal, AS);
+
+  return llvm::ConstantExpr::getBitCast(GV,
+                                        llvm::PointerType::get(SamplerTy, AS));
+}
+
 llvm::Metadata *CodeGenModule::CreateMetadataIdentifierForType(QualType T) {
   llvm::Metadata *&InternalId = MetadataIdMap[T.getCanonicalType()];
   if (InternalId)
diff --git a/lib/CodeGen/CodeGenModule.h b/lib/CodeGen/CodeGenModule.h
index fdb4d78..87856dc 100644
--- a/lib/CodeGen/CodeGenModule.h
+++ b/lib/CodeGen/CodeGenModule.h
@@ -459,6 +459,8 @@ private:
   llvm::Type *BlockDescriptorType;
   llvm::Type *GenericBlockLiteralType;
 
+  llvm::DenseMap<const VarDecl*, llvm::Constant *> OCLGlobalBlockFunctions;
+
   struct {
     int GlobalUniqueCount;
   } Block;
@@ -761,7 +763,11 @@ public:
 
   /// Gets the address of a block which requires no captures.
   llvm::Constant *GetAddrOfGlobalBlock(const BlockExpr *BE, const char *);
-  
+  /// 
+  llvm::Constant *GetOCLGlobalBlockFunction(const VarDecl *D) {
+    return OCLGlobalBlockFunctions[D];
+  }
+
   /// Return a pointer to a constant CFString object for the given string.
   ConstantAddress GetAddrOfConstantCFString(const StringLiteral *Literal);
 
@@ -1026,6 +1032,12 @@ public:
   /// Emit all the global annotations.
   void EmitGlobalAnnotations();
 
+  /// Emit OpenCL related annotations.
+  void EmitOCLAnnotations();
+
+  /// Emit OCL compiler options
+  void EmitOCLBuildOptions();
+
   /// Emit an annotation string.
   llvm::Constant *EmitAnnotationString(StringRef Str);
 
@@ -1050,6 +1062,9 @@ public:
   /// annotations are emitted during finalization of the LLVM code.
   void AddGlobalAnnotations(const ValueDecl *D, llvm::GlobalValue *GV);
 
+  void AddAppleCLKernelAnnotation(llvm::Function* Fn, const std::string& arg_info,
+                                  std::vector<llvm::Constant*> lmem_refs);
+
   bool isInSanitizerBlacklist(llvm::Function *Fn, SourceLocation Loc) const;
 
   bool isInSanitizerBlacklist(llvm::GlobalVariable *GV, SourceLocation Loc,
@@ -1126,6 +1141,12 @@ public:
   /// \breif Get the declaration of std::terminate for the platform.
   llvm::Constant *getTerminateFn();
 
+  llvm::Constant*
+  createIntToSamplerConversion(const Expr *E,
+                               CodeGenFunction *CGF,
+                               llvm::GlobalVariable *InsertBefore = nullptr,
+                               StringRef Name = "");
+
 private:
   llvm::Constant *
   GetOrCreateLLVMFunction(StringRef MangledName, llvm::Type *Ty, GlobalDecl D,
@@ -1238,6 +1259,9 @@ private:
   /// Check whether we can use a "simpler", more core exceptions personality
   /// function.
   void SimplifyPersonality();
+
+  // Get a metadata vector containing the build options
+  llvm::SmallVector<llvm::Metadata *, 5> getBuildOptions();
 };
 }  // end namespace CodeGen
 }  // end namespace clang
diff --git a/lib/CodeGen/CodeGenTypes.cpp b/lib/CodeGen/CodeGenTypes.cpp
index 09d9bf1..37a1ba7 100644
--- a/lib/CodeGen/CodeGenTypes.cpp
+++ b/lib/CodeGen/CodeGenTypes.cpp
@@ -453,18 +453,9 @@ llvm::Type *CodeGenTypes::ConvertType(QualType T) {
       ResultType = llvm::IntegerType::get(getLLVMContext(), 128);
       break;
 
-    case BuiltinType::OCLImage1d:
-    case BuiltinType::OCLImage1dArray:
-    case BuiltinType::OCLImage1dBuffer:
-    case BuiltinType::OCLImage2d:
-    case BuiltinType::OCLImage2dArray:
-    case BuiltinType::OCLImage2dDepth:
-    case BuiltinType::OCLImage2dArrayDepth:
-    case BuiltinType::OCLImage2dMSAA:
-    case BuiltinType::OCLImage2dArrayMSAA:
-    case BuiltinType::OCLImage2dMSAADepth:
-    case BuiltinType::OCLImage2dArrayMSAADepth:
-    case BuiltinType::OCLImage3d:
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
     case BuiltinType::OCLSampler:
     case BuiltinType::OCLEvent:
     case BuiltinType::OCLClkEvent:
@@ -595,6 +586,10 @@ llvm::Type *CodeGenTypes::ConvertType(QualType T) {
   }
 
   case Type::BlockPointer: {
+    if (Context.getLangOpts().OpenCL) {
+      ResultType = CGM.getOpenCLRuntime().getBlockType();
+      break;
+    }
     const QualType FTy = cast<BlockPointerType>(Ty)->getPointeeType();
     llvm::Type *PointeeType = ConvertTypeForMem(FTy);
     unsigned AS = Context.getTargetAddressSpace(FTy);
@@ -714,7 +709,14 @@ llvm::StructType *CodeGenTypes::ConvertRecordDeclType(const RecordDecl *RD) {
 
 /// getCGRecordLayout - Return record layout info for the given record decl.
 const CGRecordLayout &
-CodeGenTypes::getCGRecordLayout(const RecordDecl *RD) {
+CodeGenTypes::getCGRecordLayout(const RecordDecl *RD, llvm::Type* struct_type) {
+  // check if there is a flattened layout for this llvm struct type,
+  // return it if so, otherwise continue as usual
+  if (struct_type != nullptr) {
+    const auto flat_layout = FlattenedCGRecordLayouts.lookup(struct_type);
+    if(flat_layout) return *flat_layout;
+  }
+
   const Type *Key = Context.getTagDeclType(RD).getTypePtr();
 
   const CGRecordLayout *Layout = CGRecordLayouts.lookup(Key);
@@ -762,3 +764,207 @@ bool CodeGenTypes::isZeroInitializable(QualType T) {
 bool CodeGenTypes::isZeroInitializable(const RecordDecl *RD) {
   return getCGRecordLayout(RD).isZeroInitializable();
 }
+
+//
+static std::string aggregate_scalar_fields_mangle(const CXXRecordDecl* root_decl,
+												  MangleContext& MC,
+												  RecordDecl::field_iterator field_iter) {
+	std::string gen_type_name = "";
+	llvm::raw_string_ostream gen_type_name_stream(gen_type_name);
+	MC.mangleMetalFieldName(*field_iter, root_decl, gen_type_name_stream);
+	return "generated(" + gen_type_name_stream.str() + ")";
+}
+static std::string aggregate_scalar_fields_mangle(const CXXRecordDecl* root_decl,
+												  MangleContext& MC,
+												  const std::string& name,
+												  const clang::QualType& type) {
+	std::string gen_type_name = "";
+	llvm::raw_string_ostream gen_type_name_stream(gen_type_name);
+	MC.mangleMetalGeneric(name, type, root_decl, gen_type_name_stream);
+	return "generated(" + gen_type_name_stream.str() + ")";
+}
+
+clang::QualType CodeGenTypes::get_compat_vector_type(const CXXRecordDecl* decl) const {
+	const auto fields = get_aggregate_scalar_fields(decl, decl, true, false);
+	
+	const auto vec_size = fields.size();
+	if(vec_size < 1 || vec_size > 4) {
+		assert("invalid vector size (must be >= 1 && <= 4)");
+		return Context.VoidTy;
+	}
+	
+	const auto elem_type = fields[0].type.getUnqualifiedType();
+	for(size_t i = 1; i < vec_size; ++i) {
+		if(fields[i].type.getUnqualifiedType() != elem_type) {
+			assert("all vector-compat element types must be equal");
+			return Context.VoidTy;
+		}
+	}
+	
+	return Context.getExtVectorType(elem_type, vec_size);
+}
+
+void CodeGenTypes::aggregate_scalar_fields_add_array(const CXXRecordDecl* root_decl,
+													 const CXXRecordDecl* parent_decl,
+													 const ConstantArrayType* CAT,
+													 const AttrVec* attrs,
+													 const std::string& name,
+													 std::vector<CodeGenTypes::aggregate_scalar_entry>& ret) const {
+	const auto count = CAT->getSize().getZExtValue();
+	const auto ET = CAT->getElementType();
+	if(const auto arr_rdecl = ET->getAsCXXRecordDecl()) {
+		auto contained_ret = get_aggregate_scalar_fields(root_decl, arr_rdecl);
+		for(auto& entry : contained_ret) {
+			entry.parents.push_back(parent_decl);
+		}
+		for(uint64_t i = 0; i < count; ++i) {
+			ret.insert(ret.end(), contained_ret.begin(), contained_ret.end());
+		}
+	}
+	else if(ET->isArrayType()) {
+		const auto aoa_decl = dyn_cast<ConstantArrayType>(ET->getAsArrayTypeUnsafe());
+		if(aoa_decl) {
+			for(uint64_t i = 0; i < count; ++i) {
+				const auto idx_str = "_" + std::to_string(i);
+				aggregate_scalar_fields_add_array(root_decl, parent_decl, aoa_decl, attrs, name + idx_str, ret);
+			}
+		}
+		else {
+			// TODO: error
+		}
+	}
+	else {
+		for(uint64_t i = 0; i < count; ++i) {
+			const auto idx_str = "_" + std::to_string(i);
+			ret.push_back(aggregate_scalar_entry {
+				ET,
+				name + idx_str,
+				aggregate_scalar_fields_mangle(root_decl, TheCXXABI.getMangleContext(), name + idx_str, ET),
+				attrs,
+				nullptr,
+				{ parent_decl },
+				false,
+				false
+			});
+		}
+	}
+}
+
+std::vector<CodeGenTypes::aggregate_scalar_entry>
+CodeGenTypes::get_aggregate_scalar_fields(const CXXRecordDecl* root_decl,
+										  const CXXRecordDecl* decl,
+										  const bool ignore_root_vec_compat,
+										  const bool ignore_bases) const {
+	if(decl == nullptr) return {};
+	
+	// must have definition
+	if(!decl->hasDefinition()) return {};
+	
+	// if the root decl is a direct compat vector, return it directly
+	if(!ignore_root_vec_compat &&
+	   decl->hasAttr<VectorCompatAttr>()) {
+		return {
+			aggregate_scalar_entry {
+				get_compat_vector_type(decl),
+				"",
+				"",
+				&decl->getAttrs(),
+				nullptr,
+				{},
+				true,
+				false
+			}
+		};
+	}
+	
+	//
+	std::vector<aggregate_scalar_entry> ret;
+	
+	// iterate over / recurse into all bases
+	if(!ignore_bases) {
+		for(const auto& base : decl->bases()) {
+			auto base_ret = get_aggregate_scalar_fields(root_decl, base.getType()->getAsCXXRecordDecl());
+			for(auto& elem : base_ret) {
+				elem.is_in_base = true;
+			}
+			if(!base_ret.empty()) {
+				ret.insert(ret.end(), base_ret.begin(), base_ret.end());
+			}
+		}
+	}
+	
+	// TODO/NOTE: make sure attrs are correctly forwarded/inherited/passed-through
+	const auto add_field = [this, &root_decl, &decl, &ret](RecordDecl::field_iterator field_iter) {
+		if(const auto rdecl = field_iter->getType()->getAsCXXRecordDecl()) {
+			if(rdecl->hasAttr<VectorCompatAttr>() ||
+			   field_iter->hasAttr<GraphicsVertexPositionAttr>()) {
+				const auto vec_type = get_compat_vector_type(rdecl);
+				
+				if(field_iter->hasAttr<GraphicsVertexPositionAttr>()) {
+					const auto as_vec_type = vec_type->getAs<ExtVectorType>();
+					if(as_vec_type->getNumElements() != 4 ||
+					   !as_vec_type->getElementType()->isFloatingType()) {
+						// TODO: error!
+					}
+				}
+				
+				ret.push_back(aggregate_scalar_entry {
+					vec_type,
+					field_iter->getName().str(),
+					aggregate_scalar_fields_mangle(root_decl, TheCXXABI.getMangleContext(),
+												   field_iter->getName().str(), vec_type),
+					field_iter->hasAttrs() ? &field_iter->getAttrs() : nullptr,
+					*field_iter,
+					{ decl },
+					true,
+					false
+				});
+			}
+			else {
+				auto contained_ret = get_aggregate_scalar_fields(root_decl, rdecl);
+				for(auto& entry : contained_ret) {
+					entry.parents.push_back(decl);
+				}
+				if(!contained_ret.empty()) {
+					ret.insert(ret.end(), contained_ret.begin(), contained_ret.end());
+				}
+			}
+		}
+		else if(field_iter->getType()->isArrayType()) {
+			const auto arr_decl = dyn_cast<ConstantArrayType>(field_iter->getType()->getAsArrayTypeUnsafe());
+			if(arr_decl) {
+				aggregate_scalar_fields_add_array(root_decl, decl, arr_decl,
+												  field_iter->hasAttrs() ? &field_iter->getAttrs() : nullptr,
+												  field_iter->getName().str(), ret);
+			}
+			else {
+				// TODO: error
+			}
+		}
+		else {
+			ret.push_back(aggregate_scalar_entry {
+				field_iter->getType(),
+				field_iter->getName().str(),
+				aggregate_scalar_fields_mangle(root_decl, TheCXXABI.getMangleContext(), field_iter),
+				field_iter->hasAttrs() ? &field_iter->getAttrs() : nullptr,
+				*field_iter,
+				{ decl },
+				false,
+				false
+			});
+		}
+	};
+	
+	if(!decl->isUnion()) {
+		// iterate over all fields/members
+		for(auto iter = decl->field_begin(); iter != decl->field_end(); ++iter) {
+			add_field(iter);
+		}
+	}
+	else {
+		// for unions: only use the first field
+		add_field(decl->field_begin());
+	}
+	
+	return ret;
+}
diff --git a/lib/CodeGen/CodeGenTypes.h b/lib/CodeGen/CodeGenTypes.h
index a96f23c..7a451dc 100644
--- a/lib/CodeGen/CodeGenTypes.h
+++ b/lib/CodeGen/CodeGenTypes.h
@@ -138,6 +138,10 @@ class CodeGenTypes {
   /// Maps clang struct type with corresponding record layout info.
   llvm::DenseMap<const Type*, CGRecordLayout *> CGRecordLayouts;
 
+  /// This maps special flattened llvm struct types
+  /// with the corresponding record layout info.
+  llvm::DenseMap<const llvm::Type*, CGRecordLayout *> FlattenedCGRecordLayouts;
+
   /// Contains the LLVM IR type for any converted RecordDecl.
   llvm::DenseMap<const Type*, llvm::StructType *> RecordDeclTypes;
   
@@ -208,7 +212,8 @@ public:
   /// and/or incomplete argument types, this will return the opaque type.
   llvm::Type *GetFunctionTypeForVTable(GlobalDecl GD);
 
-  const CGRecordLayout &getCGRecordLayout(const RecordDecl*);
+  const CGRecordLayout &getCGRecordLayout(const RecordDecl*,
+										  llvm::Type* struct_type = nullptr);
 
   /// UpdateCompletedType - When we find the full definition for a TagDecl,
   /// replace the 'opaque' type we previously made for it if applicable.
@@ -300,7 +305,57 @@ public:
   /// optional suffix and name the given LLVM type using it.
   void addRecordTypeName(const RecordDecl *RD, llvm::StructType *Ty,
                          StringRef suffix);
-  
+
+  //
+  struct aggregate_scalar_entry {
+	clang::QualType type;
+	std::string name;
+	std::string mangled_name;
+    const AttrVec* attrs;
+	// NOTE: this is nullptr for non-fields!
+    const FieldDecl* field_decl;
+    std::vector<const CXXRecordDecl*> parents;
+    bool compat_vector;
+    bool is_in_base;
+	
+	template <typename SpecificAttr>
+	bool hasAttr() const {
+		if(attrs == nullptr) return false;
+		return hasSpecificAttr<SpecificAttr>(*attrs);
+	}
+	
+	template <typename SpecificAttr>
+	SpecificAttr* getAttr() const {
+		if(attrs == nullptr) return nullptr;
+		return getSpecificAttr<SpecificAttr>(*attrs);
+	}
+  };
+
+  // will recurse through the specified class/struct decl, its base classes,
+  // all its contained class/struct/union decls, all its contained arrays,
+  // returning a vector of all contained/scalarized fields + info
+  // NOTE: for unions, only the first field will be considered
+  // NOTE: this also transform/converts [[vector_compat]] types to clang vector types
+  std::vector<aggregate_scalar_entry> get_aggregate_scalar_fields(const CXXRecordDecl* root_decl,
+                                                                  const CXXRecordDecl* decl,
+																  const bool ignore_root_vec_compat = false,
+																  const bool ignore_bases = false) const;
+
+  // returns the corresponding clang vector type for a [[vector_compat]] aggregate
+  clang::QualType get_compat_vector_type(const CXXRecordDecl* decl) const;
+
+  //
+  void create_flattened_cg_layout(const CXXRecordDecl* decl, llvm::StructType* type,
+								  const std::vector<aggregate_scalar_entry>& fields);
+
+private:
+  // helper function for get_aggregate_scalar_fields
+  void aggregate_scalar_fields_add_array(const CXXRecordDecl* root_decl,
+										 const CXXRecordDecl* parent_decl,
+                                         const ConstantArrayType* CAT,
+                                         const AttrVec* attrs,
+                                         const std::string& name,
+                                         std::vector<CodeGenTypes::aggregate_scalar_entry>& ret) const;
 
 public:  // These are internal details of CGT that shouldn't be used externally.
   /// ConvertRecordDeclType - Lay out a tagged decl type like struct or union.
diff --git a/lib/CodeGen/ItaniumCXXABI.cpp b/lib/CodeGen/ItaniumCXXABI.cpp
index e02c8dc..fffa956 100644
--- a/lib/CodeGen/ItaniumCXXABI.cpp
+++ b/lib/CodeGen/ItaniumCXXABI.cpp
@@ -2517,18 +2517,11 @@ static bool TypeInfoIsInStandardLibrary(const BuiltinType *Ty) {
     case BuiltinType::Char32:
     case BuiltinType::Int128:
     case BuiltinType::UInt128:
-    case BuiltinType::OCLImage1d:
-    case BuiltinType::OCLImage1dArray:
-    case BuiltinType::OCLImage1dBuffer:
-    case BuiltinType::OCLImage2d:
-    case BuiltinType::OCLImage2dArray:
-    case BuiltinType::OCLImage2dDepth:
-    case BuiltinType::OCLImage2dArrayDepth:
-    case BuiltinType::OCLImage2dMSAA:
-    case BuiltinType::OCLImage2dArrayMSAA:
-    case BuiltinType::OCLImage2dMSAADepth:
-    case BuiltinType::OCLImage2dArrayMSAADepth:
-    case BuiltinType::OCLImage3d:
+      return true;
+
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
     case BuiltinType::OCLSampler:
     case BuiltinType::OCLEvent:
     case BuiltinType::OCLClkEvent:
diff --git a/lib/CodeGen/Makefile b/lib/CodeGen/Makefile
index 6032dff..054094d 100644
--- a/lib/CodeGen/Makefile
+++ b/lib/CodeGen/Makefile
@@ -16,4 +16,3 @@ CLANG_LEVEL := ../..
 LIBRARYNAME := clangCodeGen
 
 include $(CLANG_LEVEL)/Makefile
-
diff --git a/lib/CodeGen/TargetInfo.cpp b/lib/CodeGen/TargetInfo.cpp
index 3d1ddef..c481312 100644
--- a/lib/CodeGen/TargetInfo.cpp
+++ b/lib/CodeGen/TargetInfo.cpp
@@ -43,11 +43,15 @@ static void AssignToArrayRange(CodeGen::CGBuilderTy &Builder,
   }
 }
 
-static bool isAggregateTypeForABI(QualType T) {
+bool TargetCodeGenInfo::isAggregateTypeForABI(QualType T) {
   return !CodeGenFunction::hasScalarEvaluationKind(T) ||
          T->isMemberFunctionPointerType();
 }
 
+static bool isAggregateImageType(QualType T) {
+  return CodeGenFunction::hasAggregateEvaluationKind(T) && T->isAggregateImageType();
+}
+
 ABIArgInfo
 ABIInfo::getNaturalAlignIndirect(QualType Ty, bool ByRef, bool Realign,
                                  llvm::Type *Padding) const {
@@ -66,6 +70,23 @@ Address ABIInfo::EmitMSVAArg(CodeGenFunction &CGF, Address VAListAddr,
   return Address::invalid();
 }
 
+static ABIArgInfo classifyOpenCL(QualType Ty) {
+
+  if (Ty->isVoidType())
+    return ABIArgInfo::getIgnore();
+
+  if (const EnumType *EnumTy = Ty->getAs<EnumType>())
+    Ty = EnumTy->getDecl()->getIntegerType();
+
+  if (Ty->isRecordType())
+	  return ABIArgInfo::getIndirect(CharUnits::Zero(), /*ByVal=*/false);
+
+  if (Ty->isPromotableIntegerType())
+    return ABIArgInfo::getExtend();
+
+  return ABIArgInfo::getDirect();
+}
+
 ABIInfo::~ABIInfo() {}
 
 static CGCXXABI::RecordArgABI getRecordArgABI(const RecordType *RT,
@@ -439,7 +460,7 @@ static const Type *isSingleElementStruct(QualType T, ASTContext &Context) {
       FT = AT->getElementType();
     }
 
-    if (!isAggregateTypeForABI(FT)) {
+    if (!TargetCodeGenInfo::isAggregateTypeForABI(FT)) {
       Found = FT.getTypePtr();
     } else {
       Found = isSingleElementStruct(FT, Context);
@@ -557,9 +578,12 @@ Address DefaultABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
 }
 
 ABIArgInfo DefaultABIInfo::classifyArgumentType(QualType Ty) const {
+  if (isAggregateImageType(Ty))
+    return ABIArgInfo::getExpand();
+
   Ty = useFirstFieldIfTransparentUnion(Ty);
 
-  if (isAggregateTypeForABI(Ty)) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     // Records with non-trivial destructors/copy-constructors should not be
     // passed by value.
     if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))
@@ -580,7 +604,7 @@ ABIArgInfo DefaultABIInfo::classifyReturnType(QualType RetTy) const {
   if (RetTy->isVoidType())
     return ABIArgInfo::getIgnore();
 
-  if (isAggregateTypeForABI(RetTy))
+  if (TargetCodeGenInfo::isAggregateTypeForABI(RetTy))
     return getNaturalAlignIndirect(RetTy);
 
   // Treat an enum type as its underlying type.
@@ -626,7 +650,7 @@ public:
 ABIArgInfo WebAssemblyABIInfo::classifyArgumentType(QualType Ty) const {
   Ty = useFirstFieldIfTransparentUnion(Ty);
 
-  if (isAggregateTypeForABI(Ty)) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     // Records with non-trivial destructors/copy-constructors should not be
     // passed by value.
     if (auto RAA = getRecordArgABI(Ty, getCXXABI()))
@@ -646,7 +670,7 @@ ABIArgInfo WebAssemblyABIInfo::classifyArgumentType(QualType Ty) const {
 }
 
 ABIArgInfo WebAssemblyABIInfo::classifyReturnType(QualType RetTy) const {
-  if (isAggregateTypeForABI(RetTy)) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(RetTy)) {
     // Records with non-trivial destructors/copy-constructors should not be
     // returned by value.
     if (!getRecordArgABI(RetTy, getCXXABI())) {
@@ -705,7 +729,7 @@ Address PNaClABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
 
 /// \brief Classify argument of given type \p Ty.
 ABIArgInfo PNaClABIInfo::classifyArgumentType(QualType Ty) const {
-  if (isAggregateTypeForABI(Ty)) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))
       return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);
     return getNaturalAlignIndirect(Ty);
@@ -726,7 +750,7 @@ ABIArgInfo PNaClABIInfo::classifyReturnType(QualType RetTy) const {
     return ABIArgInfo::getIgnore();
 
   // In the PNaCl ABI we always return records/structures on the stack.
-  if (isAggregateTypeForABI(RetTy))
+  if (TargetCodeGenInfo::isAggregateTypeForABI(RetTy))
     return getNaturalAlignIndirect(RetTy);
 
   // Treat an enum type as its underlying type.
@@ -1103,7 +1127,7 @@ ABIArgInfo X86_32ABIInfo::classifyReturnType(QualType RetTy,
     return ABIArgInfo::getDirect();
   }
 
-  if (isAggregateTypeForABI(RetTy)) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(RetTy)) {
     if (const RecordType *RT = RetTy->getAs<RecordType>()) {
       // Structures with flexible arrays are always indirect.
       if (RT->getDecl()->hasFlexibleArrayMember())
@@ -1338,7 +1362,7 @@ ABIArgInfo X86_32ABIInfo::classifyArgumentType(QualType Ty,
     return getIndirectResult(Ty, /*ByVal=*/false, State);
   }
 
-  if (isAggregateTypeForABI(Ty)) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     if (RT) {
       // Structs are always byval on win32, regardless of what they contain.
       if (IsWin32StructABI)
@@ -1419,6 +1443,20 @@ ABIArgInfo X86_32ABIInfo::classifyArgumentType(QualType Ty,
 }
 
 void X86_32ABIInfo::computeInfo(CGFunctionInfo &FI) const {
+  QualType RetTy = FI.getReturnType();
+
+  // TODO: why is this here?
+  if (getContext().getLangOpts().OpenCL) {
+    // Use OpenCL clessify to prevent coercing
+    FI.getReturnInfo() = classifyOpenCL(RetTy);
+
+    for (CGFunctionInfo::arg_iterator it = FI.arg_begin(), ie = FI.arg_end();
+         it != ie; ++it)
+      it->info= classifyOpenCL(it->type);
+
+    return;
+  }
+
   CCState State(FI.getCallingConvention());
   if (IsMCUABI)
     State.FreeRegs = 3;
@@ -2442,7 +2480,7 @@ void X86_64ABIInfo::classify(QualType Ty, uint64_t OffsetBase,
 ABIArgInfo X86_64ABIInfo::getIndirectReturnResult(QualType Ty) const {
   // If this is a scalar LLVM value then assume LLVM will pass it in the right
   // place naturally.
-  if (!isAggregateTypeForABI(Ty)) {
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     // Treat an enum type as its underlying type.
     if (const EnumType *EnumTy = Ty->getAs<EnumType>())
       Ty = EnumTy->getDecl()->getIntegerType();
@@ -2475,7 +2513,7 @@ ABIArgInfo X86_64ABIInfo::getIndirectResult(QualType Ty,
   // the argument in the free register. This does not seem to happen currently,
   // but this code would be much safer if we could mark the argument with
   // 'onstack'. See PR12193.
-  if (!isAggregateTypeForABI(Ty) && !IsIllegalVectorType(Ty)) {
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(Ty) && !IsIllegalVectorType(Ty)) {
     // Treat an enum type as its underlying type.
     if (const EnumType *EnumTy = Ty->getAs<EnumType>())
       Ty = EnumTy->getDecl()->getIntegerType();
@@ -3065,6 +3103,19 @@ ABIArgInfo X86_64ABIInfo::classifyArgumentType(
 }
 
 void X86_64ABIInfo::computeInfo(CGFunctionInfo &FI) const {
+  QualType RetTy = FI.getReturnType();
+
+  // TODO: again, why is this here?
+  if (getContext().getLangOpts().OpenCL) {
+    // Use OpenCL clessify to prevent coercing
+    FI.getReturnInfo() = classifyOpenCL(RetTy);
+
+    for (CGFunctionInfo::arg_iterator it = FI.arg_begin(), ie = FI.arg_end();
+         it != ie; ++it)
+      it->info= classifyOpenCL(it->type);
+
+    return;
+  }
 
   if (!getCXXABI().classifyReturnType(FI))
     FI.getReturnInfo() = classifyReturnType(FI.getReturnType());
@@ -3430,6 +3481,18 @@ void WinX86_64ABIInfo::computeInfo(CGFunctionInfo &FI) const {
   if (!getCXXABI().classifyReturnType(FI))
     FI.getReturnInfo() = classify(FI.getReturnType(), FreeSSERegs, true);
 
+  // TODO: ... why is this here?
+  if (getContext().getLangOpts().OpenCL) {
+    // Use OpenCL classify to prevent coercing
+    FI.getReturnInfo() = classifyOpenCL(FI.getReturnType());
+
+    for (CGFunctionInfo::arg_iterator it = FI.arg_begin(), ie = FI.arg_end();
+         it != ie; ++it)
+      it->info= classifyOpenCL(it->type);
+
+    return;
+  }
+
   // We can use up to 6 SSE register parameters with vectorcall.
   FreeSSERegs = IsVectorCall ? 6 : 0;
   for (auto &I : FI.arguments())
@@ -3840,7 +3903,7 @@ CharUnits PPC64_SVR4_ABIInfo::getParamTypeAlignment(QualType Ty) const {
   const Type *Base = nullptr;
   uint64_t Members = 0;
   if (!AlignAsType && Kind == ELFv2 &&
-      isAggregateTypeForABI(Ty) && isHomogeneousAggregate(Ty, Base, Members))
+      TargetCodeGenInfo::isAggregateTypeForABI(Ty) && isHomogeneousAggregate(Ty, Base, Members))
     AlignAsType = Base;
 
   // With special case aggregates, only vector base types need alignment.
@@ -3855,7 +3918,7 @@ CharUnits PPC64_SVR4_ABIInfo::getParamTypeAlignment(QualType Ty) const {
 
   // Otherwise, we only need alignment for any aggregate type that
   // has an alignment requirement of >= 16 bytes.
-  if (isAggregateTypeForABI(Ty) && getContext().getTypeAlign(Ty) >= 128) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(Ty) && getContext().getTypeAlign(Ty) >= 128) {
     if (HasQPX && getContext().getTypeAlign(Ty) >= 256)
       return CharUnits::fromQuantity(32);
     return CharUnits::fromQuantity(16);
@@ -4001,7 +4064,7 @@ PPC64_SVR4_ABIInfo::classifyArgumentType(QualType Ty) const {
     }
   }
 
-  if (isAggregateTypeForABI(Ty)) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     if (CGCXXABI::RecordArgABI RAA = getRecordArgABI(Ty, getCXXABI()))
       return getNaturalAlignIndirect(Ty, RAA == CGCXXABI::RAA_DirectInMemory);
 
@@ -4073,7 +4136,7 @@ PPC64_SVR4_ABIInfo::classifyReturnType(QualType RetTy) const {
     }
   }
 
-  if (isAggregateTypeForABI(RetTy)) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(RetTy)) {
     // ELFv2 homogeneous aggregates are returned as array types.
     const Type *Base = nullptr;
     uint64_t Members = 0;
@@ -4306,7 +4369,7 @@ ABIArgInfo AArch64ABIInfo::classifyArgumentType(QualType Ty) const {
     return getNaturalAlignIndirect(Ty, /*ByVal=*/false);
   }
 
-  if (!isAggregateTypeForABI(Ty)) {
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     // Treat an enum type as its underlying type.
     if (const EnumType *EnumTy = Ty->getAs<EnumType>())
       Ty = EnumTy->getDecl()->getIntegerType();
@@ -4366,7 +4429,7 @@ ABIArgInfo AArch64ABIInfo::classifyReturnType(QualType RetTy) const {
   if (RetTy->isVectorType() && getContext().getTypeSize(RetTy) > 128)
     return getNaturalAlignIndirect(RetTy);
 
-  if (!isAggregateTypeForABI(RetTy)) {
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(RetTy)) {
     // Treat an enum type as its underlying type.
     if (const EnumType *EnumTy = RetTy->getAs<EnumType>())
       RetTy = EnumTy->getDecl()->getIntegerType();
@@ -4614,7 +4677,7 @@ Address AArch64ABIInfo::EmitAAPCSVAArg(Address VAListAddr,
     // It might be right-aligned in its slot.
     CharUnits SlotSize = BaseAddr.getAlignment();
     if (CGF.CGM.getDataLayout().isBigEndian() && !IsIndirect &&
-        (IsHFA || !isAggregateTypeForABI(Ty)) &&
+        (IsHFA || !TargetCodeGenInfo::isAggregateTypeForABI(Ty)) &&
         TyInfo.first < SlotSize) {
       CharUnits Offset = SlotSize - TyInfo.first;
       BaseAddr = CGF.Builder.CreateConstInBoundsByteGEP(BaseAddr, Offset);
@@ -4668,7 +4731,7 @@ Address AArch64ABIInfo::EmitAAPCSVAArg(Address VAListAddr,
   // Write the new value of __stack for the next call to va_arg
   CGF.Builder.CreateStore(NewStack, stack_p);
 
-  if (CGF.CGM.getDataLayout().isBigEndian() && !isAggregateTypeForABI(Ty) &&
+  if (CGF.CGM.getDataLayout().isBigEndian() && !TargetCodeGenInfo::isAggregateTypeForABI(Ty) &&
       TyInfo.first < StackSlotSize) {
     CharUnits Offset = StackSlotSize - TyInfo.first;
     OnStackAddr = CGF.Builder.CreateConstInBoundsByteGEP(OnStackAddr, Offset);
@@ -4698,7 +4761,7 @@ Address AArch64ABIInfo::EmitDarwinVAArg(Address VAListAddr, QualType Ty,
   // The backend's lowering doesn't support va_arg for aggregates or
   // illegal vector types.  Lower VAArg here for these cases and use
   // the LLVM va_arg instruction for everything else.
-  if (!isAggregateTypeForABI(Ty) && !isIllegalVectorType(Ty))
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(Ty) && !isIllegalVectorType(Ty))
     return Address::invalid();
 
   CharUnits SlotSize = CharUnits::fromQuantity(8);
@@ -4995,7 +5058,7 @@ ABIArgInfo ARMABIInfo::classifyArgumentType(QualType Ty,
     return ABIArgInfo::getDirect(ResType);
   }
 
-  if (!isAggregateTypeForABI(Ty)) {
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     // Treat an enum type as its underlying type.
     if (const EnumType *EnumTy = Ty->getAs<EnumType>()) {
       Ty = EnumTy->getDecl()->getIntegerType();
@@ -5187,7 +5250,7 @@ ABIArgInfo ARMABIInfo::classifyReturnType(QualType RetTy,
     return ABIArgInfo::getDirect(ResType);
   }
 
-  if (!isAggregateTypeForABI(RetTy)) {
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(RetTy)) {
     // Treat an enum type as its underlying type.
     if (const EnumType *EnumTy = RetTy->getAs<EnumType>())
       RetTy = EnumTy->getDecl()->getIntegerType();
@@ -5413,10 +5476,6 @@ ABIArgInfo NVPTXABIInfo::classifyArgumentType(QualType Ty) const {
   if (const EnumType *EnumTy = Ty->getAs<EnumType>())
     Ty = EnumTy->getDecl()->getIntegerType();
 
-  // Return aggregates type as indirect by value
-  if (isAggregateTypeForABI(Ty))
-    return getNaturalAlignIndirect(Ty, /* byval */ true);
-
   return (Ty->isPromotableIntegerType() ?
           ABIArgInfo::getExtend() : ABIArgInfo::getDirect());
 }
@@ -5451,7 +5510,7 @@ setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
   if (M.getLangOpts().OpenCL) {
     // Use OpenCL function attributes to check for kernel functions
     // By default, all functions are device functions
-    if (FD->hasAttr<OpenCLKernelAttr>()) {
+    if (FD->hasAttr<ComputeKernelAttr>()) {
       // OpenCL __kernel functions get kernel metadata
       // Create !{<func-ref>, metadata !"kernel", i32 1} node
       addNVVMMetadata(F, "kernel", 1);
@@ -5465,7 +5524,7 @@ setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
     // CUDA __global__ functions get a kernel metadata entry.  Since
     // __global__ functions cannot be called from the device, we do not
     // need to set the noinline attribute.
-    if (FD->hasAttr<CUDAGlobalAttr>()) {
+    if (FD->hasAttr<ComputeKernelAttr>()) {
       // Create !{<func-ref>, metadata !"kernel", i32 1} node
       addNVVMMetadata(F, "kernel", 1);
     }
@@ -5508,6 +5567,101 @@ void NVPTXTargetCodeGenInfo::addNVVMMetadata(llvm::Function *F, StringRef Name,
 }
 
 //===----------------------------------------------------------------------===//
+// OpenCL/SPIR ABI Implementation
+//===----------------------------------------------------------------------===//
+
+namespace {
+
+class SPIRABIInfo : public DefaultABIInfo {
+public:
+  SPIRABIInfo(CodeGenTypes &CGT) : DefaultABIInfo(CGT) {}
+};
+
+class SPIRTargetCodeGenInfo : public TargetCodeGenInfo {
+public:
+  SPIRTargetCodeGenInfo(CodeGenTypes &CGT)
+    : TargetCodeGenInfo(new SPIRABIInfo(CGT)) {}
+};
+	
+}
+
+//===----------------------------------------------------------------------===//
+// Metal/AIR ABI Implementation
+//===----------------------------------------------------------------------===//
+
+namespace {
+
+class AIRABIInfo : public ABIInfo {
+public:
+  AIRABIInfo(CodeGenTypes &CGT) : ABIInfo(CGT) {}
+
+  ABIArgInfo classifyReturnType(QualType RetTy) const;
+  ABIArgInfo classifyArgumentType(QualType Ty) const;
+
+  void computeInfo(CGFunctionInfo &FI) const override;
+  Address EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
+                    QualType Ty) const override;
+};
+
+class AIRTargetCodeGenInfo : public TargetCodeGenInfo {
+public:
+  AIRTargetCodeGenInfo(CodeGenTypes &CGT)
+    : TargetCodeGenInfo(new AIRABIInfo(CGT)) {}
+};
+
+ABIArgInfo AIRABIInfo::classifyReturnType(QualType RetTy) const {
+  if (RetTy->isVoidType())
+    return ABIArgInfo::getIgnore();
+
+  // note: this is different from default ABI
+  if (!RetTy->isScalarType())
+    return ABIArgInfo::getDirect();
+
+  // Treat an enum type as its underlying type.
+  if (const EnumType *EnumTy = RetTy->getAs<EnumType>())
+    RetTy = EnumTy->getDecl()->getIntegerType();
+
+  return (RetTy->isPromotableIntegerType() ?
+          ABIArgInfo::getExtend() : ABIArgInfo::getDirect());
+}
+
+ABIArgInfo AIRABIInfo::classifyArgumentType(QualType Ty) const {
+  if (CodeGenFunction::hasAggregateEvaluationKind(Ty) &&
+      Ty->isStructureOrClassType()) {
+    return ABIArgInfo::getExpand();
+  }
+
+  // Treat an enum type as its underlying type.
+  if (const EnumType *EnumTy = Ty->getAs<EnumType>())
+    Ty = EnumTy->getDecl()->getIntegerType();
+
+  return (Ty->isPromotableIntegerType() ?
+          ABIArgInfo::getExtend() : ABIArgInfo::getDirect());
+}
+
+void AIRABIInfo::computeInfo(CGFunctionInfo &FI) const {
+  // return type should never be indirect
+  // TODO: ... if the function is a kernel/vs/fs
+  FI.getReturnInfo() = classifyReturnType(FI.getReturnType());
+
+  for (auto &I : FI.arguments())
+    I.info = classifyArgumentType(I.type);
+
+  // Always honor user-specified calling convention.
+  if (FI.getCallingConvention() != llvm::CallingConv::C)
+    return;
+
+  FI.setEffectiveCallingConvention(getRuntimeCC());
+}
+
+Address AIRABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
+                              QualType Ty) const {
+  llvm_unreachable("AIR does not support varargs");
+}
+
+}
+
+//===----------------------------------------------------------------------===//
 // SystemZ ABI Implementation
 //===----------------------------------------------------------------------===//
 
@@ -5572,7 +5726,7 @@ bool SystemZABIInfo::isPromotableIntegerType(QualType Ty) const {
 bool SystemZABIInfo::isCompoundType(QualType Ty) const {
   return (Ty->isAnyComplexType() ||
           Ty->isVectorType() ||
-          isAggregateTypeForABI(Ty));
+          TargetCodeGenInfo::isAggregateTypeForABI(Ty));
 }
 
 bool SystemZABIInfo::isVectorArgumentType(QualType Ty) const {
@@ -6070,7 +6224,7 @@ MipsABIInfo::classifyArgumentType(QualType Ty, uint64_t &Offset) const {
   unsigned CurrOffset = llvm::RoundUpToAlignment(Offset, Align);
   Offset = CurrOffset + llvm::RoundUpToAlignment(TySize, Align * 8) / 8;
 
-  if (isAggregateTypeForABI(Ty) || Ty->isVectorType()) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(Ty) || Ty->isVectorType()) {
     // Ignore empty aggregates.
     if (TySize == 0)
       return ABIArgInfo::getIgnore();
@@ -6155,7 +6309,7 @@ ABIArgInfo MipsABIInfo::classifyReturnType(QualType RetTy) const {
   if (!IsO32 && Size == 0)
     return ABIArgInfo::getIgnore();
 
-  if (isAggregateTypeForABI(RetTy) || RetTy->isVectorType()) {
+  if (TargetCodeGenInfo::isAggregateTypeForABI(RetTy) || RetTy->isVectorType()) {
     if (Size <= 128) {
       if (RetTy->isAnyComplexType())
         return ABIArgInfo::getDirect();
@@ -6308,7 +6462,7 @@ void TCETargetCodeGenInfo::setTargetAttributes(
   llvm::Function *F = cast<llvm::Function>(GV);
 
   if (M.getLangOpts().OpenCL) {
-    if (FD->hasAttr<OpenCLKernelAttr>()) {
+    if (FD->hasAttr<ComputeKernelAttr>()) {
       // OpenCL C Kernel functions are not subject to inlining
       F->addFnAttr(llvm::Attribute::NoInline);
       const ReqdWorkGroupSizeAttr *Attr = FD->getAttr<ReqdWorkGroupSizeAttr>();
@@ -6388,7 +6542,7 @@ void HexagonABIInfo::computeInfo(CGFunctionInfo &FI) const {
 }
 
 ABIArgInfo HexagonABIInfo::classifyArgumentType(QualType Ty) const {
-  if (!isAggregateTypeForABI(Ty)) {
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(Ty)) {
     // Treat an enum type as its underlying type.
     if (const EnumType *EnumTy = Ty->getAs<EnumType>())
       Ty = EnumTy->getDecl()->getIntegerType();
@@ -6426,7 +6580,7 @@ ABIArgInfo HexagonABIInfo::classifyReturnType(QualType RetTy) const {
   if (RetTy->isVectorType() && getContext().getTypeSize(RetTy) > 64)
     return getNaturalAlignIndirect(RetTy);
 
-  if (!isAggregateTypeForABI(RetTy)) {
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(RetTy)) {
     // Treat an enum type as its underlying type.
     if (const EnumType *EnumTy = RetTy->getAs<EnumType>())
       RetTy = EnumTy->getDecl()->getIntegerType();
@@ -6670,7 +6824,7 @@ SparcV9ABIInfo::classifyType(QualType Ty, unsigned SizeLimit) const {
     return ABIArgInfo::getExtend();
 
   // Other non-aggregates go in registers.
-  if (!isAggregateTypeForABI(Ty))
+  if (!TargetCodeGenInfo::isAggregateTypeForABI(Ty))
     return ABIArgInfo::getDirect();
 
   // If a C++ object has either a non-trivial copy constructor or a non-trivial
@@ -7585,5 +7739,10 @@ const TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {
     return *(TheTargetCodeGenInfo = new SparcV9TargetCodeGenInfo(Types));
   case llvm::Triple::xcore:
     return *(TheTargetCodeGenInfo = new XCoreTargetCodeGenInfo(Types));
+  case llvm::Triple::spir:
+  case llvm::Triple::spir64:
+    return *(TheTargetCodeGenInfo = new SPIRTargetCodeGenInfo(Types));
+  case llvm::Triple::air64:
+    return *(TheTargetCodeGenInfo = new AIRTargetCodeGenInfo(Types));
   }
 }
diff --git a/lib/CodeGen/TargetInfo.h b/lib/CodeGen/TargetInfo.h
index 87b4704..1eecb63 100644
--- a/lib/CodeGen/TargetInfo.h
+++ b/lib/CodeGen/TargetInfo.h
@@ -218,6 +218,9 @@ public:
   virtual void getDetectMismatchOption(llvm::StringRef Name,
                                        llvm::StringRef Value,
                                        llvm::SmallString<32> &Opt) const {}
+
+  static bool isAggregateTypeForABI(QualType T);
+
 };
 } // namespace clang
 
diff --git a/lib/Driver/Action.cpp b/lib/Driver/Action.cpp
index e9490e9..8a38f0d 100644
--- a/lib/Driver/Action.cpp
+++ b/lib/Driver/Action.cpp
@@ -66,6 +66,10 @@ static const char* GpuArchToComputeName(const char *ArchName) {
       .Case("sm_50", "compute_50")
       .Case("sm_52", "compute_52")
       .Case("sm_53", "compute_53")
+      .Case("sm_60", "compute_60")
+      .Case("sm_61", "compute_61")
+      .Case("sm_62", "compute_62")
+      .Case("sm_70", "compute_70")
       .Default(nullptr);
 }
 
diff --git a/lib/Driver/Driver.cpp b/lib/Driver/Driver.cpp
index 1e0a48d..e1ab7e4 100644
--- a/lib/Driver/Driver.cpp
+++ b/lib/Driver/Driver.cpp
@@ -1584,6 +1584,10 @@ Action *Driver::ConstructPhaseAction(Compilation &C, const ToolChain &TC,
       return C.MakeAction<CompileJobAction>(Input, types::TY_ModuleFile);
     if (Args.hasArg(options::OPT_verify_pch))
       return C.MakeAction<VerifyPCHJobAction>(Input, types::TY_Nothing);
+    if (Args.hasArg(options::OPT_llvm_bc_32))
+      return C.MakeAction<CompileJobAction>(Input, types::TY_LLVM_BC_32);
+    if (Args.hasArg(options::OPT_llvm_bc_35))
+      return C.MakeAction<CompileJobAction>(Input, types::TY_LLVM_BC_35);
     return C.MakeAction<CompileJobAction>(Input, types::TY_LLVM_BC);
   }
   case phases::Backend: {
@@ -1593,8 +1597,14 @@ Action *Driver::ConstructPhaseAction(Compilation &C, const ToolChain &TC,
       return C.MakeAction<BackendJobAction>(Input, Output);
     }
     if (Args.hasArg(options::OPT_emit_llvm)) {
-      types::ID Output =
-          Args.hasArg(options::OPT_S) ? types::TY_LLVM_IR : types::TY_LLVM_BC;
+      types::ID Output = types::TY_LLVM_BC;
+      if (Args.hasArg(options::OPT_S)) {
+        Output = types::TY_LLVM_IR;
+      }
+      else {
+        if (Args.hasArg(options::OPT_llvm_bc_32)) Output = types::TY_LLVM_BC_32;
+        if (Args.hasArg(options::OPT_llvm_bc_35)) Output = types::TY_LLVM_BC_35;
+      }
       return C.MakeAction<BackendJobAction>(Input, Output);
     }
     return C.MakeAction<BackendJobAction>(Input, types::TY_PP_Asm);
@@ -2051,8 +2061,11 @@ const char *Driver::GetNamedOutputPath(Compilation &C, const JobAction &JA,
     // the unoptimized bitcode so that it does not get overwritten by the ".bc"
     // optimized bitcode output.
     if (!AtTopLevel && C.getArgs().hasArg(options::OPT_emit_llvm) &&
-        JA.getType() == types::TY_LLVM_BC)
+        (JA.getType() == types::TY_LLVM_BC ||
+         JA.getType() == types::TY_LLVM_BC_32 ||
+         JA.getType() == types::TY_LLVM_BC_35)) {
       Suffixed += ".tmp";
+    }
     Suffixed += '.';
     Suffixed += Suffix;
     NamedOutput = C.getArgs().MakeArgString(Suffixed.c_str());
diff --git a/lib/Driver/ToolChains.cpp b/lib/Driver/ToolChains.cpp
index 99c7b8e..80e4ce4 100644
--- a/lib/Driver/ToolChains.cpp
+++ b/lib/Driver/ToolChains.cpp
@@ -67,6 +67,8 @@ bool MachO::HasNativeLLVMSupport() const { return true; }
 
 /// Darwin provides an ARC runtime starting in MacOS X 10.7 and iOS 5.0.
 ObjCRuntime Darwin::getDefaultObjCRuntime(bool isNonFragile) const {
+  if (getTriple().getArch() == llvm::Triple::ArchType::air64)
+    return ObjCRuntime(ObjCRuntime::FragileMacOSX, TargetVersion);
   if (isTargetWatchOSBased())
     return ObjCRuntime(ObjCRuntime::WatchOS, TargetVersion);
   if (isTargetIOSBased())
@@ -78,6 +80,8 @@ ObjCRuntime Darwin::getDefaultObjCRuntime(bool isNonFragile) const {
 
 /// Darwin provides a blocks runtime starting in MacOS X 10.6 and iOS 3.2.
 bool Darwin::hasBlocksRuntime() const {
+  if (getTriple().getArch() == llvm::Triple::ArchType::air64)
+    return false;
   if (isTargetWatchOSBased())
     return true;
   else if (isTargetIOSBased())
@@ -228,6 +232,10 @@ DarwinClang::DarwinClang(const Driver &D, const llvm::Triple &Triple,
     : Darwin(D, Triple, Args) {}
 
 void DarwinClang::addClangWarningOptions(ArgStringList &CC1Args) const {
+  // nothing of interest in here for air/metal
+  if (getTriple().getArch() == llvm::Triple::ArchType::air64)
+    return;
+
   // For modern targets, promote certain warnings to errors.
   if (isTargetWatchOSBased() || getTriple().isArch64Bit()) {
     // Always enable -Wdeprecated-objc-isa-usage and promote it
@@ -1213,6 +1221,11 @@ void Darwin::CheckObjCARC() const {
 
 SanitizerMask Darwin::getSupportedSanitizers() const {
   SanitizerMask Res = ToolChain::getSupportedSanitizers();
+
+  // no additional ones
+  if (getTriple().getArch() == llvm::Triple::ArchType::air64)
+    return Res;
+
   if (isTargetMacOS() || isTargetIOSSimulator())
     Res |= SanitizerKind::Address;
   if (isTargetMacOS()) {
@@ -4129,8 +4142,6 @@ void Linux::AddCudaIncludeArgs(const ArgList &DriverArgs,
 
   if (CudaInstallation.isValid()) {
     addSystemInclude(DriverArgs, CC1Args, CudaInstallation.getIncludePath());
-    CC1Args.push_back("-include");
-    CC1Args.push_back("__clang_cuda_runtime_wrapper.h");
   }
 }
 
diff --git a/lib/Driver/ToolChains.h b/lib/Driver/ToolChains.h
index f940e58..ac06236 100644
--- a/lib/Driver/ToolChains.h
+++ b/lib/Driver/ToolChains.h
@@ -518,6 +518,10 @@ public:
   }
 
   unsigned GetDefaultStackProtectorLevel(bool KernelOrKext) const override {
+    // not supported on air/metal
+    if (getTriple().getArch() == llvm::Triple::ArchType::air64)
+      return 0;
+
     // Stack protectors default to on for user code on 10.5,
     // and for everything in 10.6 and beyond
     if (isTargetIOSBased() || isTargetWatchOSBased())
diff --git a/lib/Driver/Tools.cpp b/lib/Driver/Tools.cpp
index b7ac24f..3acef1d 100644
--- a/lib/Driver/Tools.cpp
+++ b/lib/Driver/Tools.cpp
@@ -3532,6 +3532,12 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
     } else if (JA.getType() == types::TY_LLVM_BC ||
                JA.getType() == types::TY_LTO_BC) {
       CmdArgs.push_back("-emit-llvm-bc");
+    } else if (JA.getType() == types::TY_LLVM_BC_32) {
+      CmdArgs.push_back("-emit-llvm-bc"); // order matters
+      CmdArgs.push_back("-llvm-bc-32");
+    } else if (JA.getType() == types::TY_LLVM_BC_35) {
+      CmdArgs.push_back("-emit-llvm-bc"); // order matters
+      CmdArgs.push_back("-llvm-bc-35");
     } else if (JA.getType() == types::TY_PP_Asm) {
       CmdArgs.push_back("-S");
     } else if (JA.getType() == types::TY_AST) {
@@ -3552,7 +3558,7 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
     // loading the bitcode up in 'opt' or 'llc' and running passes gives the
     // same result as running passes here.  For LTO, we don't need to preserve
     // the use-list order, since serialization to bitcode is part of the flow.
-    if (JA.getType() == types::TY_LLVM_BC)
+    if (JA.getType() == types::TY_LLVM_BC) // NOTE: don't do this for 3.2/3.5
       CmdArgs.push_back("-emit-llvm-uselists");
 
     if (D.isUsingLTO())
@@ -6224,6 +6230,8 @@ void gcc::Compiler::RenderExtraToolArgs(const JobAction &JA,
   case types::TY_LLVM_IR:
   case types::TY_LTO_IR:
   case types::TY_LLVM_BC:
+  case types::TY_LLVM_BC_32:
+  case types::TY_LLVM_BC_35:
   case types::TY_LTO_BC:
     CmdArgs.push_back("-c");
     break;
@@ -6770,6 +6778,8 @@ llvm::Triple::ArchType darwin::getArchTypeForMachOArchName(StringRef Str) {
       .Case("nvptx64", llvm::Triple::nvptx64)
       .Case("amdil", llvm::Triple::amdil)
       .Case("spir", llvm::Triple::spir)
+      .Case("spir64", llvm::Triple::spir64)
+      .Case("air64", llvm::Triple::air64)
       .Default(llvm::Triple::UnknownArch);
 }
 
diff --git a/lib/Driver/Types.cpp b/lib/Driver/Types.cpp
index c29ce94..95e10ee 100644
--- a/lib/Driver/Types.cpp
+++ b/lib/Driver/Types.cpp
@@ -97,6 +97,7 @@ bool types::isAcceptedByClang(ID Id) {
   case TY_ObjCXXHeader: case TY_PP_ObjCXXHeader:
   case TY_AST: case TY_ModuleFile:
   case TY_LLVM_IR: case TY_LLVM_BC:
+  case TY_LLVM_BC_32: case TY_LLVM_BC_35:
     return true;
   }
 }
@@ -135,6 +136,8 @@ bool types::isLLVMIR(ID Id) {
 
   case TY_LLVM_IR:
   case TY_LLVM_BC:
+  case TY_LLVM_BC_32:
+  case TY_LLVM_BC_35:
   case TY_LTO_IR:
   case TY_LTO_BC:
     return true;
@@ -174,6 +177,8 @@ types::ID types::lookupTypeForExtension(const char *Ext) {
            .Case("mi", TY_PP_ObjC)
            .Case("mm", TY_ObjCXX)
            .Case("bc", TY_LLVM_BC)
+           .Case("bc32", TY_LLVM_BC_32) // not ideal
+           .Case("bc35", TY_LLVM_BC_35) // not ideal
            .Case("cc", TY_CXX)
            .Case("CC", TY_CXX)
            .Case("cl", TY_CL)
diff --git a/lib/Edit/RewriteObjCFoundationAPI.cpp b/lib/Edit/RewriteObjCFoundationAPI.cpp
index 482c0f6..2148316 100644
--- a/lib/Edit/RewriteObjCFoundationAPI.cpp
+++ b/lib/Edit/RewriteObjCFoundationAPI.cpp
@@ -1076,6 +1076,8 @@ static bool rewriteToNumericBoxedExpression(const ObjCMessageExpr *Msg,
     case CK_CopyAndAutoreleaseBlockObject:
     case CK_BuiltinFnToFnPtr:
     case CK_ZeroToOCLEvent:
+    case CK_ZeroToOCLQueue:
+    case CK_IntToOCLSampler:
       return false;
 
     case CK_BooleanToSignedIntegral:
diff --git a/lib/Frontend/CompilerInstance.cpp b/lib/Frontend/CompilerInstance.cpp
index 3edcf5d..fdc26d2 100644
--- a/lib/Frontend/CompilerInstance.cpp
+++ b/lib/Frontend/CompilerInstance.cpp
@@ -872,6 +872,8 @@ bool CompilerInstance::ExecuteAction(FrontendAction &Act) {
 /// \brief Determine the appropriate source input kind based on language
 /// options.
 static InputKind getSourceInputKindFromOptions(const LangOptions &LangOpts) {
+  if (LangOpts.Metal)
+    return IK_Metal;
   if (LangOpts.OpenCL)
     return IK_OpenCL;
   if (LangOpts.CUDA)
diff --git a/lib/Frontend/CompilerInvocation.cpp b/lib/Frontend/CompilerInvocation.cpp
index 237a447..7a2c696 100644
--- a/lib/Frontend/CompilerInvocation.cpp
+++ b/lib/Frontend/CompilerInvocation.cpp
@@ -42,6 +42,7 @@
 #include "llvm/Target/TargetOptions.h"
 #include <atomic>
 #include <memory>
+#include <fstream>
 #include <sys/stat.h>
 #include <system_error>
 using namespace clang;
@@ -79,7 +80,7 @@ using namespace llvm::opt;
 static unsigned getOptimizationLevel(ArgList &Args, InputKind IK,
                                      DiagnosticsEngine &Diags) {
   unsigned DefaultOpt = 0;
-  if (IK == IK_OpenCL && !Args.hasArg(OPT_cl_opt_disable))
+  if ((IK == IK_OpenCL || IK == IK_Metal) && !Args.hasArg(OPT_cl_opt_disable) && !Args.hasArg(OPT_emit_spirv))
     DefaultOpt = 2;
 
   if (Arg *A = Args.getLastArg(options::OPT_O_Group)) {
@@ -509,7 +510,9 @@ static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
     else
       Opts.EABIVersion = Value;
   }
-  Opts.LessPreciseFPMAD = Args.hasArg(OPT_cl_mad_enable);
+  Opts.LessPreciseFPMAD = Args.hasArg(OPT_cl_mad_enable) ||
+                          Args.hasArg(OPT_cl_unsafe_math_optimizations) ||
+                          Args.hasArg(OPT_cl_fast_relaxed_math);
   Opts.LimitFloatPrecision = Args.getLastArgValue(OPT_mlimit_float_precision);
   Opts.NoInfsFPMath = (Args.hasArg(OPT_menable_no_infinities) ||
                        Args.hasArg(OPT_cl_finite_math_only) ||
@@ -576,6 +579,13 @@ static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
   Opts.MainFileName = Args.getLastArgValue(OPT_main_file_name);
   Opts.VerifyModule = !Args.hasArg(OPT_disable_llvm_verifier);
 
+  Opts.DenormsAreZero = Args.hasArg(OPT_cl_denorms_are_zero);
+  Opts.CorrectFPDivideSqrt = Args.hasArg(OPT_cl_fp32_correctly_rounded_divide_sqrt);
+  Opts.OptDisable = Args.hasArg(OPT_cl_opt_disable);
+  Opts.NoSignedZeros = Args.hasArg(OPT_fno_signed_zeros) ||
+                       Args.hasArg(OPT_cl_unsafe_math_optimizations) ||
+                       Args.hasArg(OPT_cl_fast_relaxed_math);
+
   Opts.DisableGCov = Args.hasArg(OPT_test_coverage);
   Opts.EmitGcovArcs = Args.hasArg(OPT_femit_coverage_data);
   Opts.EmitGcovNotes = Args.hasArg(OPT_femit_coverage_notes);
@@ -600,7 +610,13 @@ static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
 
   Opts.InstrumentFunctions = Args.hasArg(OPT_finstrument_functions);
   Opts.InstrumentForProfiling = Args.hasArg(OPT_pg);
-  Opts.EmitOpenCLArgMetadata = Args.hasArg(OPT_cl_kernel_arg_info);
+  Opts.EmitOpenCLArgMetadata = Args.hasArg(OPT_cl_kernel_arg_info) || Args.hasArg(OPT_emit_spirv);
+  if (IK == IK_Metal) {
+    // dwarf version must always be 2 for metal/air
+    Opts.DwarfVersion = 2;
+  }
+  Opts.EmitAppleCLMetadata = Args.hasArg(OPT_applecl_kernel_info);
+  Opts.MetalIntelWorkarounds = Args.hasArg(OPT_metal_intel_workarounds);
   Opts.CompressDebugSections = Args.hasArg(OPT_compress_debug_sections);
   Opts.DebugCompilationDir = Args.getLastArgValue(OPT_fdebug_compilation_dir);
   for (auto A : Args.filtered(OPT_mlink_bitcode_file, OPT_mlink_cuda_bitcode)) {
@@ -675,6 +691,7 @@ static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
     }
   }
 
+  Opts.SPIRCompileOptions = Args.getLastArgValue(OPT_cl_spir_compile_options).trim("\t\n\v\f\r\" ");
   if (Arg *A = Args.getLastArg(OPT_ffp_contract)) {
     StringRef Val = A->getValue();
     if (Val == "fast")
@@ -945,6 +962,12 @@ static InputKind ParseFrontendArgs(FrontendOptions &Opts, ArgList &Args,
       Opts.ProgramAction = frontend::EmitAssembly; break;
     case OPT_emit_llvm_bc:
       Opts.ProgramAction = frontend::EmitBC; break;
+    case OPT_llvm_bc_32:
+      Opts.ProgramAction = frontend::EmitBC32; break;
+    case OPT_llvm_bc_35:
+      Opts.ProgramAction = frontend::EmitBC35; break;
+    case OPT_emit_spirv:
+      Opts.ProgramAction = frontend::EmitSPIRV; break;
     case OPT_emit_html:
       Opts.ProgramAction = frontend::EmitHTML; break;
     case OPT_emit_llvm:
@@ -1145,6 +1168,7 @@ static InputKind ParseFrontendArgs(FrontendOptions &Opts, ArgList &Args,
     DashX = llvm::StringSwitch<InputKind>(A->getValue())
       .Case("c", IK_C)
       .Case("cl", IK_OpenCL)
+      .Case("metal", IK_Metal)
       .Case("cuda", IK_CUDA)
       .Case("c++", IK_CXX)
       .Case("objective-c", IK_ObjC)
@@ -1159,6 +1183,7 @@ static InputKind ParseFrontendArgs(FrontendOptions &Opts, ArgList &Args,
       .Case("objc++-cpp-output", IK_PreprocessedObjCXX)
       .Case("c-header", IK_C)
       .Case("cl-header", IK_OpenCL)
+      .Case("metal-header", IK_Metal)
       .Case("objective-c-header", IK_ObjC)
       .Case("c++-header", IK_CXX)
       .Case("objective-c++-header", IK_ObjCXX)
@@ -1333,6 +1358,9 @@ void CompilerInvocation::setLangDefaults(LangOptions &Opts, InputKind IK,
     case IK_OpenCL:
       LangStd = LangStandard::lang_opencl;
       break;
+    case IK_Metal:
+      LangStd = LangStandard::lang_metal11;
+      break;
     case IK_CUDA:
     case IK_PreprocessedCuda:
       LangStd = LangStandard::lang_cuda;
@@ -1377,6 +1405,17 @@ void CompilerInvocation::setLangDefaults(LangOptions &Opts, InputKind IK,
     Opts.OpenCLVersion = 120;
   else if (LangStd == LangStandard::lang_opencl20)
     Opts.OpenCLVersion = 200;
+  else if (LangStd == LangStandard::lang_opencl21)
+    Opts.OpenCLVersion = 210;
+  else if (LangStd == LangStandard::lang_opencl22)
+    Opts.OpenCLVersion = 220;
+
+  // as Metal is largely compiled as OpenCL, also enable + init opencl
+  if (LangStd == LangStandard::lang_metal11 || IK == IK_Metal) {
+    Opts.Metal = 1;
+    Opts.OpenCL = 1;
+    Opts.OpenCLVersion = 120;
+  }
 
   // OpenCL has some additional defaults.
   if (Opts.OpenCL) {
@@ -1459,10 +1498,15 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
             << A->getAsString(Args) << "C++/ObjC++";
         break;
       case IK_OpenCL:
-        if (!Std.isC99())
+        if (!Std.isC99() && !Std.isCPlusPlus())
           Diags.Report(diag::err_drv_argument_not_allowed_with)
             << A->getAsString(Args) << "OpenCL";
         break;
+      case IK_Metal:
+        if (!Std.isCPlusPlus())
+          Diags.Report(diag::err_drv_argument_not_allowed_with)
+            << A->getAsString(Args) << "Metal";
+        break;
       case IK_CUDA:
       case IK_PreprocessedCuda:
         if (!Std.isCPlusPlus())
@@ -1484,6 +1528,8 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
     .Case("CL1.1", LangStandard::lang_opencl11)
     .Case("CL1.2", LangStandard::lang_opencl12)
     .Case("CL2.0", LangStandard::lang_opencl20)
+    .Case("CL2.1", LangStandard::lang_opencl21)
+    .Case("CL2.2", LangStandard::lang_opencl22)
     .Default(LangStandard::lang_unspecified);
 
     if (OpenCLLangStd == LangStandard::lang_unspecified) {
@@ -1496,6 +1542,23 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
 
   CompilerInvocation::setLangDefaults(Opts, IK, LangStd);
 
+  // open libfloor function info file
+  if (const Arg *A = Args.getLastArg(OPT_floor_function_info)) {
+    if (A->getValue() != nullptr && strlen(A->getValue()) > 0) {
+      Opts.floor_function_info = new std::fstream(A->getValue(), std::ios::out | std::ios::binary);
+      if (Opts.floor_function_info == nullptr ||
+          !Opts.floor_function_info->is_open()) {
+        Diags.Report(diag::err_drv_floor_function_info);
+      }
+    }
+  }
+
+  // extract libfloor image capabilities
+  if (const Arg *A = Args.getLastArg(OPT_floor_image_capabilities)) {
+    StringRef image_caps = A->getValue();
+    Opts.floor_image_capabilities = (unsigned int)std::stoul(image_caps);
+  }
+
   // We abuse '-f[no-]gnu-keywords' to force overriding all GNU-extension
   // keywords. This behavior is provided by GCC's poorly named '-fasm' flag,
   // while a subset (the non-C++ GNU keywords) is provided by GCC's
@@ -1667,6 +1730,11 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
   Opts.RTTI = !Args.hasArg(OPT_fno_rtti);
   Opts.RTTIData = Opts.RTTI && !Args.hasArg(OPT_fno_rtti_data);
   Opts.Blocks = Args.hasArg(OPT_fblocks);
+  if (Opts.OpenCLVersion >= 200) {
+    Opts.Blocks = 1;
+  } else {
+    Opts.Blocks = Args.hasArg(OPT_fblocks);
+  }
   Opts.BlocksRuntimeOptional = Args.hasArg(OPT_fblocks_runtime_optional);
   Opts.Coroutines = Args.hasArg(OPT_fcoroutines);
   Opts.Modules = Args.hasArg(OPT_fmodules);
@@ -1867,6 +1935,20 @@ static void ParseLangArgs(LangOptions &Opts, ArgList &Args, InputKind IK,
   Opts.RetainCommentsFromSystemHeaders =
       Args.hasArg(OPT_fretain_comments_from_system_headers);
 
+  Opts.CLEnableHalf = Args.hasArg(OPT_cl_enable_half);
+  Opts.CLVerifySPIR = Args.hasArg(OPT_cl_verify_spir);
+
+  if(const Arg* A = Args.getLastArg(OPT_cl_sampler_type)) {
+      Opts.CLSamplerOpaque  = llvm::StringSwitch<unsigned int>(A->getValue())
+        .Case("i32", 0u)
+        .Case("opaque", 1u)
+        .Default(~0u);
+      if(Opts.CLSamplerOpaque == ~0u)
+        Diags.Report(diag::err_drv_invalid_value) << A->getAsString(Args)
+                                                  << A->getValue();
+  } else
+    Opts.CLSamplerOpaque = 1;
+
   unsigned SSP = getLastArgIntValue(Args, OPT_stack_protector, 0, Diags);
   switch (SSP) {
   default:
@@ -1980,6 +2062,9 @@ static void ParsePreprocessorOutputArgs(PreprocessorOutputOptions &Opts,
   case frontend::ASTView:
   case frontend::EmitAssembly:
   case frontend::EmitBC:
+  case frontend::EmitBC32:
+  case frontend::EmitBC35:
+  case frontend::EmitSPIRV:
   case frontend::EmitHTML:
   case frontend::EmitLLVM:
   case frontend::EmitLLVMOnly:
diff --git a/lib/Frontend/FrontendActions.cpp b/lib/Frontend/FrontendActions.cpp
index 407ccea..12a9f03 100644
--- a/lib/Frontend/FrontendActions.cpp
+++ b/lib/Frontend/FrontendActions.cpp
@@ -725,6 +725,7 @@ void PrintPreambleAction::ExecuteAction() {
   case IK_ObjC:
   case IK_ObjCXX:
   case IK_OpenCL:
+  case IK_Metal:
   case IK_CUDA:
     break;
       
diff --git a/lib/Frontend/InitPreprocessor.cpp b/lib/Frontend/InitPreprocessor.cpp
index 15aa546..934fa96 100644
--- a/lib/Frontend/InitPreprocessor.cpp
+++ b/lib/Frontend/InitPreprocessor.cpp
@@ -112,11 +112,14 @@ static void AddImplicitIncludePCH(MacroBuilder &Builder, Preprocessor &PP,
 /// PickFP - This is used to pick a value based on the FP semantics of the
 /// specified FP model.
 template <typename T>
-static T PickFP(const llvm::fltSemantics *Sem, T IEEESingleVal,
+static T PickFP(const llvm::fltSemantics *Sem,
+				T IEEEHalfVal, T IEEESingleVal,
                 T IEEEDoubleVal, T X87DoubleExtendedVal, T PPCDoubleDoubleVal,
                 T IEEEQuadVal) {
   if (Sem == (const llvm::fltSemantics*)&llvm::APFloat::IEEEsingle)
     return IEEESingleVal;
+  if (Sem == (const llvm::fltSemantics*)&llvm::APFloat::IEEEhalf)
+    return IEEEHalfVal;
   if (Sem == (const llvm::fltSemantics*)&llvm::APFloat::IEEEdouble)
     return IEEEDoubleVal;
   if (Sem == (const llvm::fltSemantics*)&llvm::APFloat::x87DoubleExtended)
@@ -130,26 +133,26 @@ static T PickFP(const llvm::fltSemantics *Sem, T IEEESingleVal,
 static void DefineFloatMacros(MacroBuilder &Builder, StringRef Prefix,
                               const llvm::fltSemantics *Sem, StringRef Ext) {
   const char *DenormMin, *Epsilon, *Max, *Min;
-  DenormMin = PickFP(Sem, "1.40129846e-45", "4.9406564584124654e-324",
+  DenormMin = PickFP(Sem, "6.10352e-5", "1.40129846e-45", "4.9406564584124654e-324",
                      "3.64519953188247460253e-4951",
                      "4.94065645841246544176568792868221e-324",
                      "6.47517511943802511092443895822764655e-4966");
-  int Digits = PickFP(Sem, 6, 15, 18, 31, 33);
-  int DecimalDigits = PickFP(Sem, 9, 17, 21, 33, 36);
-  Epsilon = PickFP(Sem, "1.19209290e-7", "2.2204460492503131e-16",
+  int Digits = PickFP(Sem, 3, 6, 15, 18, 31, 33);
+  int DecimalDigits = PickFP(Sem, 6, 9, 17, 21, 33, 36);
+  Epsilon = PickFP(Sem, "0x1.0p-10", "1.19209290e-7", "2.2204460492503131e-16",
                    "1.08420217248550443401e-19",
                    "4.94065645841246544176568792868221e-324",
                    "1.92592994438723585305597794258492732e-34");
-  int MantissaDigits = PickFP(Sem, 24, 53, 64, 106, 113);
-  int Min10Exp = PickFP(Sem, -37, -307, -4931, -291, -4931);
-  int Max10Exp = PickFP(Sem, 38, 308, 4932, 308, 4932);
-  int MinExp = PickFP(Sem, -125, -1021, -16381, -968, -16381);
-  int MaxExp = PickFP(Sem, 128, 1024, 16384, 1024, 16384);
-  Min = PickFP(Sem, "1.17549435e-38", "2.2250738585072014e-308",
+  int MantissaDigits = PickFP(Sem, 11, 24, 53, 64, 106, 113);
+  int Min10Exp = PickFP(Sem, -4, -37, -307, -4931, -291, -4931);
+  int Max10Exp = PickFP(Sem, 4, 38, 308, 4932, 308, 4932);
+  int MinExp = PickFP(Sem, -13, -125, -1021, -16381, -968, -16381);
+  int MaxExp = PickFP(Sem, 16, 128, 1024, 16384, 1024, 16384);
+  Min = PickFP(Sem, "0x1.0p-14", "1.17549435e-38", "2.2250738585072014e-308",
                "3.36210314311209350626e-4932",
                "2.00416836000897277799610805135016e-292",
                "3.36210314311209350626267781732175260e-4932");
-  Max = PickFP(Sem, "3.40282347e+38", "1.7976931348623157e+308",
+  Max = PickFP(Sem, "0x1.ffcp15", "3.40282347e+38", "1.7976931348623157e+308",
                "1.18973149535723176502e+4932",
                "1.79769313486231580793728971405301e+308",
                "1.18973149535723176508575932662800702e+4932");
@@ -408,6 +411,41 @@ static void InitializeStandardPredefinedMacros(const TargetInfo &TI,
   if (LangOpts.ObjC1)
     Builder.defineMacro("__OBJC__");
 
+  // OpenCL v1.0/1.1 s6.9, v1.2/2.0 s6.10: Preprocessor Directives and Macros.
+  if (LangOpts.OpenCL) {
+    // OpenCL v1.0 and v1.1 do not have a predefined macro to indicate the
+    // language standard with which the program is compiled. __OPENCL_VERSION__
+    // is for the OpenCL version supported by the OpenCL device, which is not
+    // necessarily the language standard with which the program is compiled.
+    // A shared OpenCL header file requires a macro to indicate the language
+    // standard. As a workaround, __OPENCL_C_VERSION__ is defined for
+    // OpenCL v1.0 and v1.1.
+    switch (LangOpts.OpenCLVersion) {
+    case 100:
+      Builder.defineMacro("__OPENCL_C_VERSION__", "100");
+      break;
+    case 110:
+      Builder.defineMacro("__OPENCL_C_VERSION__", "110");
+      break;
+    case 120:
+      Builder.defineMacro("__OPENCL_C_VERSION__", "120");
+      break;
+    case 200:
+    case 210:
+    case 220:
+      Builder.defineMacro("__OPENCL_C_VERSION__", "200");
+      break;
+    default:
+      llvm_unreachable("Unsupported OpenCL version");
+    }
+    Builder.defineMacro("CL_VERSION_1_0", "100");
+    Builder.defineMacro("CL_VERSION_1_1", "110");
+    Builder.defineMacro("CL_VERSION_1_2", "120");
+    Builder.defineMacro("CL_VERSION_2_0", "200");
+
+    if (LangOpts.FastRelaxedMath)
+      Builder.defineMacro("__FAST_RELAXED_MATH__");
+  }
   // Not "standard" per se, but available even with the -undef flag.
   if (LangOpts.AsmPreprocessor)
     Builder.defineMacro("__ASSEMBLER__");
@@ -711,6 +749,7 @@ static void InitializePredefinedMacros(const TargetInfo &TI,
   DefineFmt("__UINTPTR", TI.getUIntPtrType(), TI, Builder);
   DefineTypeWidth("__UINTPTR_WIDTH__", TI.getUIntPtrType(), TI, Builder);
 
+  DefineFloatMacros(Builder, "HALF", &TI.getHalfFormat(), "H");
   DefineFloatMacros(Builder, "FLT", &TI.getFloatFormat(), "F");
   DefineFloatMacros(Builder, "DBL", &TI.getDoubleFormat(), "");
   DefineFloatMacros(Builder, "LDBL", &TI.getLongDoubleFormat(), "L");
@@ -922,6 +961,9 @@ void clang::InitializePreprocessor(
   llvm::raw_string_ostream Predefines(PredefineBuffer);
   MacroBuilder Builder(Predefines);
 
+  // Setup pragma support
+  PP.setSupportedPragmas(InitOpts.SupportedPragmas);
+
   // Emit line markers for various builtin sections of the file.  We don't do
   // this in asm preprocessor mode, because "# 4" is not a line marker directive
   // in this mode.
diff --git a/lib/FrontendTool/ExecuteCompilerInvocation.cpp b/lib/FrontendTool/ExecuteCompilerInvocation.cpp
index 79cf004..0135c50 100644
--- a/lib/FrontendTool/ExecuteCompilerInvocation.cpp
+++ b/lib/FrontendTool/ExecuteCompilerInvocation.cpp
@@ -45,6 +45,9 @@ static FrontendAction *CreateFrontendBaseAction(CompilerInstance &CI) {
   case DumpTokens:             return new DumpTokensAction();
   case EmitAssembly:           return new EmitAssemblyAction();
   case EmitBC:                 return new EmitBCAction();
+  case EmitBC32:               return new EmitBC32Action();
+  case EmitBC35:               return new EmitBC35Action();
+  case EmitSPIRV:              return new EmitSPIRVAction();
   case EmitHTML:               return new HTMLPrintAction();
   case EmitLLVM:               return new EmitLLVMAction();
   case EmitLLVMOnly:           return new EmitLLVMOnlyAction();
diff --git a/lib/Headers/CMakeLists.txt b/lib/Headers/CMakeLists.txt
index bbe0688..189d737 100644
--- a/lib/Headers/CMakeLists.txt
+++ b/lib/Headers/CMakeLists.txt
@@ -16,7 +16,6 @@ set(files
   avxintrin.h
   bmi2intrin.h
   bmiintrin.h
-  __clang_cuda_runtime_wrapper.h
   cpuid.h
   cuda_builtin_vars.h
   emmintrin.h
diff --git a/lib/Headers/Makefile b/lib/Headers/Makefile
index 903acac..dc8bfb8 100644
--- a/lib/Headers/Makefile
+++ b/lib/Headers/Makefile
@@ -19,7 +19,8 @@ CLANG_VERSION := $(word 3,$(shell grep "CLANG_VERSION " \
 
 HeaderDir := $(PROJ_OBJ_ROOT)/$(BuildMode)/lib/clang/$(CLANG_VERSION)/include
 
-HEADERS := $(notdir $(wildcard $(PROJ_SRC_DIR)/*.h))
+UNWANTED_HEADERS := opencl-12.h opencl-20.h __clang_cuda_runtime_wrapper.h
+HEADERS := $(filter-out $(UNWANTED_HEADERS),$(notdir $(wildcard $(PROJ_SRC_DIR)/*.h)))
 
 OBJHEADERS := $(addprefix $(HeaderDir)/, $(HEADERS))
 
diff --git a/lib/Index/USRGeneration.cpp b/lib/Index/USRGeneration.cpp
index c57694f..cd77ecc 100644
--- a/lib/Index/USRGeneration.cpp
+++ b/lib/Index/USRGeneration.cpp
@@ -605,18 +605,9 @@ void USRGenerator::VisitType(QualType T) {
 #define PLACEHOLDER_TYPE(Id, SingletonId) case BuiltinType::Id:
 #include "clang/AST/BuiltinTypes.def"
         case BuiltinType::Dependent:
-        case BuiltinType::OCLImage1d:
-        case BuiltinType::OCLImage1dArray:
-        case BuiltinType::OCLImage1dBuffer:
-        case BuiltinType::OCLImage2d:
-        case BuiltinType::OCLImage2dArray:
-        case BuiltinType::OCLImage2dDepth:
-        case BuiltinType::OCLImage2dArrayDepth:
-        case BuiltinType::OCLImage2dMSAA:
-        case BuiltinType::OCLImage2dArrayMSAA:
-        case BuiltinType::OCLImage2dMSAADepth:
-        case BuiltinType::OCLImage2dArrayMSAADepth:
-        case BuiltinType::OCLImage3d:
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+        case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
         case BuiltinType::OCLEvent:
         case BuiltinType::OCLClkEvent:
         case BuiltinType::OCLQueue:
diff --git a/lib/Lex/LiteralSupport.cpp b/lib/Lex/LiteralSupport.cpp
index 5b1c493..9fd5e3d 100644
--- a/lib/Lex/LiteralSupport.cpp
+++ b/lib/Lex/LiteralSupport.cpp
@@ -522,6 +522,7 @@ NumericLiteralParser::NumericLiteralParser(StringRef TokSpelling,
   isLong = false;
   isUnsigned = false;
   isLongLong = false;
+  isHalf = false;
   isFloat = false;
   isImaginary = false;
   MicrosoftInteger = 0;
@@ -585,6 +586,12 @@ NumericLiteralParser::NumericLiteralParser(StringRef TokSpelling,
       if (isFloat || isLong) break; // FF, LF invalid.
       isFloat = true;
       continue;  // Success.
+    case 'h':      // FP Suffix for "float"
+    case 'H':
+      if (!isFPConstant) break;  // Error for integer constant.
+      if (isFloat || isLong) break; // FF, LF invalid.
+      isFloat = true;
+      continue;  // Success.
     case 'u':
     case 'U':
       if (isFPConstant) break;  // Error for floating constant.
diff --git a/lib/Lex/PPDirectives.cpp b/lib/Lex/PPDirectives.cpp
index c02a0cb..6679316 100644
--- a/lib/Lex/PPDirectives.cpp
+++ b/lib/Lex/PPDirectives.cpp
@@ -1935,7 +1935,7 @@ bool Preprocessor::ReadMacroDefinitionArgList(MacroInfo *MI, Token &Tok) {
              diag::ext_variadic_macro);
 
       // OpenCL v1.2 s6.9.e: variadic macros are not supported.
-      if (LangOpts.OpenCL) {
+      if (LangOpts.OpenCL && !LangOpts.CPlusPlus) {
         Diag(Tok, diag::err_pp_opencl_variadic_macros);
         return true;
       }
diff --git a/lib/Parse/ParseDecl.cpp b/lib/Parse/ParseDecl.cpp
index c64b97d..1ef9869 100644
--- a/lib/Parse/ParseDecl.cpp
+++ b/lib/Parse/ParseDecl.cpp
@@ -670,23 +670,6 @@ void Parser::ParseBorlandTypeAttributes(ParsedAttributes &attrs) {
   }
 }
 
-void Parser::ParseOpenCLAttributes(ParsedAttributes &attrs) {
-  // Treat these like attributes
-  while (Tok.is(tok::kw___kernel)) {
-    IdentifierInfo *AttrName = Tok.getIdentifierInfo();
-    SourceLocation AttrNameLoc = ConsumeToken();
-    attrs.addNew(AttrName, AttrNameLoc, nullptr, AttrNameLoc, nullptr, 0,
-                 AttributeList::AS_Keyword);
-  }
-}
-
-void Parser::ParseOpenCLQualifiers(ParsedAttributes &Attrs) {
-  IdentifierInfo *AttrName = Tok.getIdentifierInfo();
-  SourceLocation AttrNameLoc = Tok.getLocation();
-  Attrs.addNew(AttrName, AttrNameLoc, nullptr, AttrNameLoc, nullptr, 0,
-               AttributeList::AS_Keyword);
-}
-
 void Parser::ParseNullabilityTypeSpecifiers(ParsedAttributes &attrs) {
   // Treat these like attributes, even though they're type specifiers.
   while (true) {
@@ -2612,7 +2595,6 @@ Parser::DiagnoseMissingSemiAfterTagDefinition(DeclSpec &DS, AccessSpecifier AS,
 /// [C99]   'inline'
 /// [C++]   'virtual'
 /// [C++]   'explicit'
-/// [OpenCL] '__kernel'
 ///       'friend': [C++ dcl.friend]
 ///       'constexpr': [C++0x dcl.constexpr]
 void Parser::ParseDeclarationSpecifiers(DeclSpec &DS,
@@ -3078,11 +3060,6 @@ void Parser::ParseDeclarationSpecifiers(DeclSpec &DS,
       ParseBorlandTypeAttributes(DS.getAttributes());
       continue;
 
-    // OpenCL single token adornments.
-    case tok::kw___kernel:
-      ParseOpenCLAttributes(DS.getAttributes());
-      continue;
-
     // Nullability type specifiers.
     case tok::kw__Nonnull:
     case tok::kw__Nullable:
@@ -3335,6 +3312,26 @@ void Parser::ParseDeclarationSpecifiers(DeclSpec &DS,
       }
       isInvalid = DS.SetTypePipe(true, Loc, PrevSpec, DiagID, Policy);
       break;
+    case tok::kw_sampler_t:
+      isInvalid = DS.SetTypeSpecType(DeclSpec::TST_sampler_t, Loc,
+                                     PrevSpec, DiagID, Policy);
+      break;
+    case tok::kw_event_t:
+      isInvalid = DS.SetTypeSpecType(DeclSpec::TST_event_t, Loc,
+                                     PrevSpec, DiagID, Policy);
+      break;
+    case tok::kw_queue_t:
+      isInvalid = DS.SetTypeSpecType(DeclSpec::TST_queue_t, Loc,
+                                     PrevSpec, DiagID, Policy);
+      break;
+    case tok::kw_clk_event_t:
+      isInvalid = DS.SetTypeSpecType(DeclSpec::TST_clk_event_t, Loc,
+                                     PrevSpec, DiagID, Policy);
+      break;
+    case tok::kw_reserve_id_t:
+      isInvalid = DS.SetTypeSpecType(DeclSpec::TST_reserve_id_t, Loc,
+                                     PrevSpec, DiagID, Policy);
+      break;
     case tok::kw___unknown_anytype:
       isInvalid = DS.SetTypeSpecType(TST_unknown_anytype, Loc,
                                      PrevSpec, DiagID, Policy);
@@ -3420,26 +3417,6 @@ void Parser::ParseDeclarationSpecifiers(DeclSpec &DS,
                                  getLangOpts());
       break;
 
-    // OpenCL qualifiers:
-    case tok::kw___generic:
-      // generic address space is introduced only in OpenCL v2.0
-      // see OpenCL C Spec v2.0 s6.5.5
-      if (Actions.getLangOpts().OpenCLVersion < 200) {
-        DiagID = diag::err_opencl_unknown_type_specifier;
-        PrevSpec = Tok.getIdentifierInfo()->getNameStart();
-        isInvalid = true;
-        break;
-      };
-    case tok::kw___private:
-    case tok::kw___global:
-    case tok::kw___local:
-    case tok::kw___constant:
-    case tok::kw___read_only:
-    case tok::kw___write_only:
-    case tok::kw___read_write:
-      ParseOpenCLQualifiers(DS.getAttributes());
-      break;
-
     case tok::less:
       // GCC ObjC supports types like "<SomeProtocol>" as a synonym for
       // "id<SomeProtocol>".  This is hopelessly old fashioned and dangerous,
@@ -3667,10 +3644,10 @@ void Parser::ParseStructUnionBody(SourceLocation RecordLoc,
       ExpectAndConsume(tok::r_paren);
     }
 
-    if (TryConsumeToken(tok::semi))
+    if (TryConsumeToken(tok::semi)) {
       continue;
 
-    if (Tok.is(tok::r_brace)) {
+    } else if (Tok.is(tok::r_brace) && !getLangOpts().OpenCL) {
       ExpectAndConsume(tok::semi, diag::ext_expected_semi_decl_list);
       break;
     }
@@ -4228,14 +4205,6 @@ bool Parser::isTypeQualifier() const {
   case tok::kw_const:
   case tok::kw_volatile:
   case tok::kw_restrict:
-  case tok::kw___private:
-  case tok::kw___local:
-  case tok::kw___global:
-  case tok::kw___constant:
-  case tok::kw___generic:
-  case tok::kw___read_only:
-  case tok::kw___read_write:
-  case tok::kw___write_only:
     return true;
   }
 }
@@ -4271,6 +4240,12 @@ bool Parser::isKnownToBeTypeSpecifier(const Token &Tok) const {
   case tok::kw__Decimal128:
   case tok::kw___vector:
 
+    // OpenCL specific types:
+  case tok::kw_sampler_t:
+  case tok::kw_event_t:
+  case tok::kw_queue_t:
+  case tok::kw_clk_event_t:
+
     // struct-or-union-specifier (C99) or class-specifier (C++)
   case tok::kw_class:
   case tok::kw_struct:
@@ -4343,6 +4318,12 @@ bool Parser::isTypeSpecifierQualifier() {
   case tok::kw__Decimal128:
   case tok::kw___vector:
 
+    // OpenCL specific types:
+  case tok::kw_sampler_t:
+  case tok::kw_event_t:
+  case tok::kw_queue_t:
+  case tok::kw_clk_event_t:
+
     // struct-or-union-specifier (C99) or class-specifier (C++)
   case tok::kw_class:
   case tok::kw_struct:
@@ -4384,17 +4365,11 @@ bool Parser::isTypeSpecifierQualifier() {
 
   case tok::kw___kindof:
 
-  case tok::kw___private:
-  case tok::kw___local:
-  case tok::kw___global:
-  case tok::kw___constant:
-  case tok::kw___generic:
-  case tok::kw___read_only:
-  case tok::kw___read_write:
-  case tok::kw___write_only:
-
     return true;
 
+  case tok::kw_reserve_id_t:
+    return getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200;
+
   // C11 _Atomic
   case tok::kw__Atomic:
     return true;
@@ -4495,6 +4470,13 @@ bool Parser::isDeclarationSpecifier(bool DisambiguatingWithExpression) {
   case tok::kw__Decimal128:
   case tok::kw___vector:
 
+    // OpenCL specific types:
+  case tok::kw_sampler_t:
+  case tok::kw_event_t:
+  case tok::kw_queue_t:
+  case tok::kw_clk_event_t:
+  case tok::kw_reserve_id_t:
+
     // struct-or-union-specifier (C99) or class-specifier (C++)
   case tok::kw_class:
   case tok::kw_struct:
@@ -4570,15 +4552,6 @@ bool Parser::isDeclarationSpecifier(bool DisambiguatingWithExpression) {
 
   case tok::kw___kindof:
 
-  case tok::kw___private:
-  case tok::kw___local:
-  case tok::kw___global:
-  case tok::kw___constant:
-  case tok::kw___generic:
-  case tok::kw___read_only:
-  case tok::kw___read_write:
-  case tok::kw___write_only:
-
     return true;
   }
 }
@@ -4758,18 +4731,6 @@ void Parser::ParseTypeQualifierListOpt(DeclSpec &DS, unsigned AttrReqs,
                                  getLangOpts());
       break;
 
-    // OpenCL qualifiers:
-    case tok::kw___private:
-    case tok::kw___global:
-    case tok::kw___local:
-    case tok::kw___constant:
-    case tok::kw___generic:
-    case tok::kw___read_only:
-    case tok::kw___write_only:
-    case tok::kw___read_write:
-      ParseOpenCLQualifiers(DS.getAttributes());
-      break;
-
     case tok::kw___uptr:
       // GNU libc headers in C mode use '__uptr' as an identifer which conflicts
       // with the MS modifier keyword.
@@ -4968,6 +4929,8 @@ void Parser::ParseDeclaratorInternal(Declarator &D,
 
   tok::TokenKind Kind = Tok.getKind();
 
+  // Add pipe type info, only if it is not already there. (It may already been
+  // added by the recursive call).
   if (D.getDeclSpec().isTypeSpecPipe() && !isPipeDeclerator(D)) {
     DeclSpec &DS = D.getMutableDeclSpec();
 
diff --git a/lib/Parse/ParseExpr.cpp b/lib/Parse/ParseExpr.cpp
index 1fd98c1..8cbd3fd 100644
--- a/lib/Parse/ParseExpr.cpp
+++ b/lib/Parse/ParseExpr.cpp
@@ -460,12 +460,14 @@ Parser::ParseRHSOfBinaryExpression(ExprResult LHS, prec::Level MinPrec) {
 ///
 ExprResult Parser::ParseCastExpression(bool isUnaryExpression,
                                        bool isAddressOfOperand,
-                                       TypeCastState isTypeCast) {
+                                       TypeCastState isTypeCast,
+                                       bool isVectorLiteral) {
   bool NotCastExpr;
   ExprResult Res = ParseCastExpression(isUnaryExpression,
                                        isAddressOfOperand,
                                        NotCastExpr,
-                                       isTypeCast);
+                                       isTypeCast,
+                                       isVectorLiteral);
   if (NotCastExpr)
     Diag(Tok, diag::err_expected_expression);
   return Res;
@@ -681,7 +683,8 @@ class CastExpressionIdValidator : public CorrectionCandidateCallback {
 ExprResult Parser::ParseCastExpression(bool isUnaryExpression,
                                        bool isAddressOfOperand,
                                        bool &NotCastExpr,
-                                       TypeCastState isTypeCast) {
+                                       TypeCastState isTypeCast,
+                                       bool isVectorLiteral) {
   ExprResult Res;
   tok::TokenKind SavedKind = Tok.getKind();
   NotCastExpr = false;
@@ -709,6 +712,11 @@ ExprResult Parser::ParseCastExpression(bool isUnaryExpression,
     Res = ParseParenExpression(ParenExprType, false/*stopIfCastExr*/,
                                isTypeCast == IsTypeCast, CastTy, RParenLoc);
 
+    if (isVectorLiteral)
+    {
+        return Res;
+    }
+
     switch (ParenExprType) {
     case SimpleExpr:   break;    // Nothing else to do.
     case CompoundStmt: break;  // Nothing else to do.
@@ -1024,7 +1032,7 @@ ExprResult Parser::ParseCastExpression(bool isUnaryExpression,
   case tok::amp: {         // unary-expression: '&' cast-expression
     // Special treatment because of member pointers
     SourceLocation SavedLoc = ConsumeToken();
-    Res = ParseCastExpression(false, true);
+    Res = ParseCastExpression(false, true, NotTypeCast, false);
     if (!Res.isInvalid())
       Res = Actions.ActOnUnaryOp(getCurScope(), SavedLoc, SavedKind, Res.get());
     return Res;
@@ -1079,6 +1087,9 @@ ExprResult Parser::ParseCastExpression(bool isUnaryExpression,
     if (Tok.isNot(tok::identifier))
       return ExprError(Diag(Tok, diag::err_expected) << tok::identifier);
 
+    if (getLangOpts().OpenCL)
+      return ExprError(Diag(Tok, diag::err_opencl_address_of_label));
+
     if (getCurScope()->getFnParent() == nullptr)
       return ExprError(Diag(Tok, diag::err_address_of_label_outside_fn));
     
@@ -1151,6 +1162,10 @@ ExprResult Parser::ParseCastExpression(bool isUnaryExpression,
   case tok::kw_void:
   case tok::kw_typename:
   case tok::kw_typeof:
+  case tok::kw_sampler_t:
+  case tok::kw_event_t:
+  case tok::kw_queue_t:
+  case tok::kw_clk_event_t:
   case tok::kw___vector: {
     if (!getLangOpts().CPlusPlus) {
       Diag(Tok, diag::err_expected_expression);
@@ -1340,7 +1355,7 @@ ExprResult Parser::ParseCastExpression(bool isUnaryExpression,
 
   // These can be followed by postfix-expr pieces.
   Res = ParsePostfixExpressionSuffix(Res);
-  if (getLangOpts().OpenCL)
+  if (getLangOpts().OpenCL && !getLangOpts().CPlusPlus)
     if (Expr *PostfixExpr = Res.get()) {
       QualType Ty = PostfixExpr->getType();
       if (!Ty.isNull() && Ty->isFunctionType()) {
@@ -2306,6 +2321,48 @@ Parser::ParseParenExpression(ParenParseOption &ExprType, bool stopIfCastExpr,
         return ParseCompoundLiteralExpression(Ty.get(), OpenLoc, RParenLoc);
       }
 
+      if (Tok.is(tok::l_paren)) {
+        // This could be OpenCL vector Literals
+        if (getLangOpts().OpenCL)
+        {
+          TypeResult Ty;
+          {
+            InMessageExpressionRAIIObject InMessage(*this, false);
+            Ty = Actions.ActOnTypeName(getCurScope(), DeclaratorInfo);
+          }
+          if(Ty.isInvalid())
+          {
+             return ExprError();
+          }
+          QualType QT = Ty.get().get().getCanonicalType();
+          if (QT->isVectorType())
+          {
+            // We parsed '(' vector-type-name ')' followed by '('
+
+            // Parse the cast-expression that follows it next.
+            // isVectorLiteral = true will make sure we don't parse any
+            // Postfix expression yet
+            Result = ParseCastExpression(/*isUnaryExpression=*/false,
+                                         /*isAddressOfOperand=*/false,
+                                         /*isTypeCast=*/IsTypeCast,
+                                         /*isVectorLiteral=*/true);
+
+            if (!Result.isInvalid()) {
+              Result = Actions.ActOnCastExpr(getCurScope(), OpenLoc,
+                                             DeclaratorInfo, CastTy,
+                                             RParenLoc, Result.get());
+            }
+
+            // After we performed the cast we can check for postfix-expr pieces.
+            if (!Result.isInvalid()) {
+              Result = ParsePostfixExpressionSuffix(Result);
+            }
+
+            return Result;
+          }
+        }
+      }
+
       if (ExprType == CastExpr) {
         // We parsed '(' type-name ')' and the thing after it wasn't a '{'.
 
diff --git a/lib/Parse/ParsePragma.cpp b/lib/Parse/ParsePragma.cpp
index bc70942..d035682 100644
--- a/lib/Parse/ParsePragma.cpp
+++ b/lib/Parse/ParsePragma.cpp
@@ -469,20 +469,28 @@ void Parser::HandlePragmaOpenCLExtension() {
   SourceLocation NameLoc = Tok.getLocation();
   ConsumeToken(); // The annotation token.
 
+  OpenCLOptions &af = Actions.getASTContext().OpenCLFeatures;
   OpenCLOptions &f = Actions.getOpenCLOptions();
   // OpenCL 1.1 9.1: "The all variant sets the behavior for all extensions,
   // overriding all previously issued extension directives, but only if the
   // behavior is set to disable."
   if (state == 0 && ename->isStr("all")) {
-#define OPENCLEXT(nm)   f.nm = 0;
+#define OPENCLEXT(nm)   f.nm = 0; af.nm = 0;
 #include "clang/Basic/OpenCLExtensions.def"
   }
-#define OPENCLEXT(nm) else if (ename->isStr(#nm)) { f.nm = state; }
+#define OPENCLEXT(nm) else if (ename->isStr(#nm)) { f.nm = state; af.nm = state; }
 #include "clang/Basic/OpenCLExtensions.def"
   else {
     PP.Diag(NameLoc, diag::warn_pragma_unknown_extension) << ename;
     return;
   }
+
+  // Check if pragma is supported
+  const OpenCLOptions &supported = PP.getSupportedPragmas();
+#define OPENCLEXT(nm) if ((supported.nm == 0) && (f.nm == 1)) { \
+    PP.Diag(NameLoc, diag::err_pragma_enabled_unsupported) << ename;\
+  }
+#include "clang/Basic/OpenCLExtensions.def"
 }
 
 void Parser::HandlePragmaMSPointersToMembers() {
diff --git a/lib/Parse/ParseTentative.cpp b/lib/Parse/ParseTentative.cpp
index 6fbcfd9..55e4849 100644
--- a/lib/Parse/ParseTentative.cpp
+++ b/lib/Parse/ParseTentative.cpp
@@ -987,6 +987,10 @@ Parser::isExpressionOrTypeSpecifierSimple(tok::TokenKind Kind) {
   case tok::kw___pixel:
   case tok::kw___bool:
   case tok::kw__Atomic:
+  case tok::kw_sampler_t:
+  case tok::kw_event_t:
+  case tok::kw_queue_t:
+  case tok::kw_clk_event_t:
   case tok::kw___unknown_anytype:
     return TPResult::False;
 
diff --git a/lib/Sema/DeclSpec.cpp b/lib/Sema/DeclSpec.cpp
index 6f6c4ca..248eb55 100644
--- a/lib/Sema/DeclSpec.cpp
+++ b/lib/Sema/DeclSpec.cpp
@@ -302,6 +302,13 @@ bool Declarator::isDeclarationOfFunction() const {
     case TST_unspecified:
     case TST_void:
     case TST_wchar:
+#define GENERIC_IMAGE_TYPE(ImgType, Id) case TST_##ImgType##_t:
+#include "clang/Basic/OpenCLImageTypes.def"
+    case TST_sampler_t:
+    case TST_event_t:
+    case TST_queue_t:
+    case TST_clk_event_t:
+    case TST_reserve_id_t:
       return false;
 
     case TST_decltype_auto:
@@ -474,6 +481,15 @@ const char *DeclSpec::getSpecifierName(DeclSpec::TST T,
   case DeclSpec::TST_underlyingType: return "__underlying_type";
   case DeclSpec::TST_unknown_anytype: return "__unknown_anytype";
   case DeclSpec::TST_atomic: return "_Atomic";
+#define GENERIC_IMAGE_TYPE(ImgType, Id) \
+  case DeclSpec::TST_##ImgType##_t: \
+    return #ImgType "_t";
+#include "clang/Basic/OpenCLImageTypes.def"
+  case DeclSpec::TST_sampler_t:   return "sampler_t";
+  case DeclSpec::TST_event_t:     return "event_t";
+  case DeclSpec::TST_queue_t:     return "queue_t";
+  case DeclSpec::TST_clk_event_t: return "clk_event_t";
+  case DeclSpec::TST_reserve_id_t: return "reserve_id_t";
   case DeclSpec::TST_error:       return "(error)";
   }
   llvm_unreachable("Unknown typespec!");
diff --git a/lib/Sema/Sema.cpp b/lib/Sema/Sema.cpp
index 39b8cc9..2a26942 100644
--- a/lib/Sema/Sema.cpp
+++ b/lib/Sema/Sema.cpp
@@ -74,7 +74,9 @@ Sema::Sema(Preprocessor &pp, ASTContext &ctxt, ASTConsumer &consumer,
            TranslationUnitKind TUKind,
            CodeCompleteConsumer *CodeCompleter)
   : ExternalSource(nullptr),
-    isMultiplexExternalSource(false), FPFeatures(pp.getLangOpts()),
+    isMultiplexExternalSource(false),
+    OpenCLFeatures(pp.getLangOpts(), pp.getSupportedPragmas()),
+    FPFeatures(pp.getLangOpts()),
     LangOpts(pp.getLangOpts()), PP(pp), Context(ctxt), Consumer(consumer),
     Diags(PP.getDiagnostics()), SourceMgr(PP.getSourceManager()),
     CollectStats(false), CodeCompleter(CodeCompleter),
@@ -203,23 +205,12 @@ void Sema::Initialize() {
 
   // Initialize predefined OpenCL types.
   if (getLangOpts().OpenCL) {
-    addImplicitTypedef("image1d_t", Context.OCLImage1dTy);
-    addImplicitTypedef("image1d_array_t", Context.OCLImage1dArrayTy);
-    addImplicitTypedef("image1d_buffer_t", Context.OCLImage1dBufferTy);
-    addImplicitTypedef("image2d_t", Context.OCLImage2dTy);
-    addImplicitTypedef("image2d_array_t", Context.OCLImage2dArrayTy);
-    addImplicitTypedef("image3d_t", Context.OCLImage3dTy);
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    addImplicitTypedef(#ImgType #Suffix "_t", Context. SingletonId);
+#include "clang/Basic/OpenCLImageTypes.def"
     addImplicitTypedef("sampler_t", Context.OCLSamplerTy);
     addImplicitTypedef("event_t", Context.OCLEventTy);
     if (getLangOpts().OpenCLVersion >= 200) {
-      addImplicitTypedef("image2d_depth_t", Context.OCLImage2dDepthTy);
-      addImplicitTypedef("image2d_array_depth_t",
-                         Context.OCLImage2dArrayDepthTy);
-      addImplicitTypedef("image2d_msaa_t", Context.OCLImage2dMSAATy);
-      addImplicitTypedef("image2d_array_msaa_t", Context.OCLImage2dArrayMSAATy);
-      addImplicitTypedef("image2d_msaa_depth_t", Context.OCLImage2dMSAADepthTy);
-      addImplicitTypedef("image2d_array_msaa_depth_t",
-                         Context.OCLImage2dArrayMSAADepthTy);
       addImplicitTypedef("clk_event_t", Context.OCLClkEventTy);
       addImplicitTypedef("queue_t", Context.OCLQueueTy);
       addImplicitTypedef("ndrange_t", Context.OCLNDRangeTy);
diff --git a/lib/Sema/SemaAttr.cpp b/lib/Sema/SemaAttr.cpp
index 5a29bad..d716bfa 100644
--- a/lib/Sema/SemaAttr.cpp
+++ b/lib/Sema/SemaAttr.cpp
@@ -569,9 +569,12 @@ void Sema::ActOnPragmaFPContract(tok::OnOffSwitch OOS) {
     break;
   case tok::OOS_OFF:
     FPFeatures.fp_contract = 0; 
+    Context.disableFPContract();
     break;
   case tok::OOS_DEFAULT:
     FPFeatures.fp_contract = getLangOpts().DefaultFPContract;
+    if (0 == getLangOpts().DefaultFPContract)
+      Context.disableFPContract();
     break;
   }
 }
diff --git a/lib/Sema/SemaCUDA.cpp b/lib/Sema/SemaCUDA.cpp
index 61dfdd3..20139b7 100644
--- a/lib/Sema/SemaCUDA.cpp
+++ b/lib/Sema/SemaCUDA.cpp
@@ -42,22 +42,13 @@ Sema::CUDAFunctionTarget Sema::IdentifyCUDATarget(const FunctionDecl *D) {
   if (D->hasAttr<CUDAInvalidTargetAttr>())
     return CFT_InvalidTarget;
 
-  if (D->hasAttr<CUDAGlobalAttr>())
+  if (D->hasAttr<ComputeKernelAttr>())
     return CFT_Global;
 
-  if (D->hasAttr<CUDADeviceAttr>()) {
-    if (D->hasAttr<CUDAHostAttr>())
-      return CFT_HostDevice;
-    return CFT_Device;
-  } else if (D->hasAttr<CUDAHostAttr>()) {
-    return CFT_Host;
-  } else if (D->isImplicit()) {
-    // Some implicit declarations (like intrinsic functions) are not marked.
-    // Set the most lenient target on them for maximal flexibility.
-    return CFT_HostDevice;
-  }
-
-  return CFT_Host;
+  // if not a kernel, always default to device
+  // this is IMO a much saner approach and doesn't require to add the __device__
+  // attribute to _all_ functions
+  return CFT_Device;
 }
 
 // * CUDA Call preference table
diff --git a/lib/Sema/SemaCast.cpp b/lib/Sema/SemaCast.cpp
index ad1d7da..206482f 100644
--- a/lib/Sema/SemaCast.cpp
+++ b/lib/Sema/SemaCast.cpp
@@ -2394,6 +2394,12 @@ void CastOperation::CheckCStyleCast() {
       SrcExpr = ExprError();
       return;
     }
+    if (SrcExpr.get()->getType()->isHalfType()) {
+      Self.Diag(SrcExpr.get()->getLocStart(), diag::err_opencl_cast_from_half)
+        << SrcType << SrcExpr.get()->getSourceRange();
+      SrcExpr = ExprError();
+      return;
+    }
   }
 
   // ARC imposes extra restrictions on casts.
diff --git a/lib/Sema/SemaChecking.cpp b/lib/Sema/SemaChecking.cpp
index 6c2834b..1c61fee 100644
--- a/lib/Sema/SemaChecking.cpp
+++ b/lib/Sema/SemaChecking.cpp
@@ -42,6 +42,144 @@
 using namespace clang;
 using namespace sema;
 
+namespace {
+
+static ImageAccessAttr* getOpenCLImageAcces(const Decl *D) {
+  if (D->hasAttr<ImageAccessAttr>())
+    return D->getAttr<ImageAccessAttr>();
+  return nullptr;
+}
+
+//===--- Perform semantic analysis for pipe builtins calls. ---------------===//
+class PipeBiCallSema {
+  typedef bool (Type::*TypeQuery)() const;
+public:
+
+  // \param S a reference for the semantic analyzer.
+  // \param TheCall a pointer to the pipe builtin call to be inspected.
+  PipeBiCallSema(Sema &Sem, CallExpr *TheCall) : S(&Sem), Call(TheCall) {}
+
+  // \brief Validates that the first argument passed to the call has a pipe
+  //        modifier.
+  // \return true if a semantic error was found, false otherwise.
+  bool validatePipeArg() {
+    return !argQuery(0, &PipeType::isPipeType);
+  }
+
+  // \brief Validates the access modifier of the pipe arguments fits the nautre
+  // off the call (read/write).
+  bool validateAccessModifier() {
+    assert (!validatePipeArg() && "Argument is no of type pipe");
+    ImageAccessAttr* AccessQual = getAccessModifierAttr();
+
+    if (getFunctionName().startswith("read"))
+      return AccessQual == nullptr || AccessQual->isReadOnly();
+
+    return (AccessQual != nullptr) && (AccessQual->isWriteOnly() || AccessQual->isReadWrite());
+  }
+
+  // \brief Validates that the type element of the pipe object matches the type
+  //        of the object pointed by the argument in the given index.
+  // \param ArgIdx The index of the pointer to the packet argument.
+  bool validateGenType(unsigned ArgIdx) {
+    assert(!validatePipeArg() && "Validate pipe type was not called first");
+
+    const PipeType *PTy = cast<PipeType>(Call->getArg(0)->getType());
+    const Type *PipeElemTy = PTy->getElementType().getTypePtr();
+    const PointerType *ArgTy = dyn_cast<PointerType>(Call->getArg(ArgIdx)->
+                                                     getType().getTypePtr());
+
+    // We expect the pipe type and the packed type to be the same.
+    return !ArgTy || (PipeElemTy != ArgTy->getPointeeType().getTypePtr());
+  }
+
+  // \brief Dispatches the given query for the indexed argument in the call.
+  // \param ArgIdx The index of the argument to be queried.
+  // \param Q Query method.
+  // \return The value returned from calling Q.
+  bool argQuery(unsigned ArgIdx, TypeQuery Q) {
+    const Type *ArgTy = Call->getArg(ArgIdx)->getType().getTypePtr();
+    return (ArgTy->*Q)();
+  }
+
+  // Error issuing massages.
+  void errorPipeArgument() {
+    S->Diag(Call->getLocStart(), diag::err_builtin_pipe_first_arg)
+    << getFunctionName() << Call->getArg(0)->getSourceRange();
+  }
+
+  void errPacketArgument(int ArgIdx) {
+    const PipeType *PipeTy = cast<PipeType>(Call->getArg(0)->getType());
+    const Expr *ArgI = Call->getArg(ArgIdx);
+
+    S->Diag(Call->getLocStart(), diag::err_builtin_pipe_invalid_arg) <<
+    getFunctionName() << S->Context.getPointerType(PipeTy->getElementType())
+    << ArgI->getSourceRange();
+  }
+
+  void errorNumArguments() {
+    S->Diag(Call->getLocStart(), diag::err_builtin_pipe_args_num_mismatch) <<
+    getFunctionName() << Call->getSourceRange();
+  }
+
+  void errPipePacketType() {
+    const Expr *Arg0 = Call->getArg(0);
+    S->Diag(Arg0->getLocStart(),
+            diag::err_builtin_pipe_argument_type_mismatch) <<
+            Arg0->getSourceRange();
+  }
+
+  void errorAcessModifier() {
+    bool ReadOnly = getFunctionName().startswith("read");
+    const char *AM = ReadOnly ? "read_only" : "write_only";
+    S->Diag(Call->getArg(0)->getLocStart(),
+              diag::err_builtin_pipe_invalid_access_modifier) << AM <<
+              Call->getArg(0)->getSourceRange();
+  }
+
+  void errorAccessModifierVal() {
+    S->Diag(Call->getArg(0)->getLocStart(),
+            diag::err_read_write_not_allowed_for_pipes) <<
+            Call->getArg(0)->getSourceRange();
+  }
+
+  void errorReservedIdType() {
+    assert(!argQuery(1, &Type::isReserveIDT) &&
+           "parameter is of type reserve_id_t");
+
+    S->Diag(Call->getLocStart(),
+              diag::err_builtin_pipe_invalid_arg) << getFunctionName() <<
+              S->Context.OCLReserveIDTy <<
+              Call->getArg(1)->getSourceRange();
+  }
+
+  void errorIndexType(int ArgIdx) {
+    S->Diag(Call->getLocStart(),
+            diag::err_builtin_pipe_invalid_arg) << getFunctionName() <<
+            S->Context.UnsignedIntTy <<
+            Call->getArg(ArgIdx)->getSourceRange();
+  }
+
+private:
+  llvm::StringRef getFunctionName() {
+    return cast<FunctionDecl>(Call->getCalleeDecl())->getName();
+  }
+
+  ImageAccessAttr* getAccessModifierAttr() {
+    const Expr *Arg0 = Call->getArg(0);
+    assert (isa<DeclRefExpr>(Arg0) &&
+            "Not possible... pipes can only be passed as kernel arguments");
+
+    const DeclRefExpr *ArgRef = cast<DeclRefExpr>(Arg0);
+    return getOpenCLImageAcces(ArgRef->getDecl());
+  }
+
+  Sema *S;
+  const CallExpr *Call;
+};
+
+} // unnamed namespace
+
 SourceLocation Sema::getLocationOfStringLiteralByte(const StringLiteral *SL,
                                                     unsigned ByteNo) const {
   return SL->getLocationOfByte(ByteNo, getSourceManager(), LangOpts,
@@ -96,6 +234,145 @@ static bool SemaBuiltinAnnotation(Sema &S, CallExpr *TheCall) {
   return false;
 }
 
+// \brief Performs semantic analysis for the Pipe builtins call.
+// \param S Reference to the semantic analyzer.
+// \param TheCall A pointer to the builtin call.
+// \return True if a semantic error has been found, false otherwise.
+static bool SemaBuiltinPipe(Sema &S, CallExpr *TheCall) {
+  PipeBiCallSema PipeSema(S, TheCall);
+
+  // First argument should always be of type Pipe.
+  if (PipeSema.validatePipeArg()) {
+    PipeSema.errorPipeArgument();
+    return true;
+  }
+
+  // Validates the access modifier is compatible with the call.
+  if (!PipeSema.validateAccessModifier()) {
+    PipeSema.errorAcessModifier();
+    return true;
+  }
+
+  switch (TheCall->getNumArgs()) {
+  case 2:
+    // Second argument should be a pointer.
+    if (!PipeSema.argQuery(1, &Type::isPointerType)) {
+      PipeSema.errPacketArgument(1);
+      return true;
+    }
+
+    // The type of the pointer and the element type of the pipe should also be
+    // the same.
+    if (PipeSema.validateGenType(1)) {
+      PipeSema.errPipePacketType();
+      return true;
+    }
+    break;
+
+  case 4:
+    if (!PipeSema.argQuery(1, &Type::isReserveIDT)) {
+      PipeSema.errorReservedIdType();
+      return true;
+    }
+
+    if (!PipeSema.argQuery(2, &Type::isIntegerType) &&
+        !PipeSema.argQuery(2, &Type::isUnsignedIntegerType)) {
+      PipeSema.errorIndexType(2);
+      return true;
+    }
+
+    // The type of the pointer and the element type of the pipe should be the
+    // same.
+    if (PipeSema.validateGenType(3)) {
+      PipeSema.errPipePacketType();
+      return true;
+    }
+
+    break;
+  default:
+    PipeSema.errorNumArguments();
+    return true;
+  }
+
+  TheCall->setType(S.getASTContext().IntTy);
+
+  return false;
+}
+
+// \brief Performs a semantic analysis on the call to the given pipe-builtin
+//        call.
+// \param S Reference to the semantic analyzer.
+// \param TheCall The call to the builtin function to be analyzed.
+// \return True if a semantic error was found, false otherwise.
+static bool SemaBuiltinReservedRWPipe(Sema &S, CallExpr *TheCall) {
+  PipeBiCallSema PipeSema(S, TheCall);
+
+  if (2U != TheCall->getNumArgs()) {
+    PipeSema.errorNumArguments();
+    return true;
+  }
+
+  // The first parameter has to be a pipe.
+  if (PipeSema.validatePipeArg()) {
+    PipeSema.errorPipeArgument();
+    return true;
+  }
+
+  // The second argument should be the number of packets to be read/written.
+  if (!PipeSema.argQuery(1, &Type::isIntegerType) &&
+      !PipeSema.argQuery(1, &Type::isUnsignedIntegerType)) {
+    PipeSema.errorIndexType(1);
+    return true;
+  }
+
+  TheCall->setType(S.getASTContext().IntTy);
+
+  return false;
+}
+
+static bool SemaBuiltinCommitRWPipe(Sema &S, CallExpr *TheCall) {
+  PipeBiCallSema PipeSema(S, TheCall);
+
+  if (2U != TheCall->getNumArgs()) {
+    PipeSema.errorNumArguments();
+    return true;
+  }
+
+  // The first parameter should be of type pipe.
+  if (PipeSema.validatePipeArg()) {
+    PipeSema.errorPipeArgument();
+    return true;
+  }
+
+  // The secnod paramter should be of type reserve_id_t.
+  if (!PipeSema.argQuery(1, &Type::isReserveIDT)) {
+      PipeSema.errorReservedIdType();
+      return true;
+  }
+
+  TheCall->setType(S.getASTContext().VoidTy);
+
+  return false;
+}
+
+
+static bool SemaNumPacketesPipe(Sema &S, CallExpr *TheCall) {
+  PipeBiCallSema PipeSema(S, TheCall);
+
+  if (1U != TheCall->getNumArgs()) {
+    PipeSema.errorPipeArgument();
+    return true;
+  }
+
+  // The argument should be of type pipe.
+  if(PipeSema.validatePipeArg()) {
+    PipeSema.errorPipeArgument();
+    return true;
+  }
+  return false;
+}
+
+
 /// Check that the argument to __builtin_addressof is a glvalue, and set the
 /// result type to the corresponding pointer type.
 static bool SemaBuiltinAddressof(Sema &S, CallExpr *TheCall) {
@@ -258,6 +535,32 @@ static bool SemaBuiltinSEHScopeCheck(Sema &SemaRef, CallExpr *TheCall,
   return false;
 }
 
+// \brief Performs a semantic check on the given call, on whether it adheres to
+//        OpenCL 2.0 requirement, in which images with 'read_write' access mod.
+//        are not read with samplers.
+// \param TheCall the call expression to be examined.
+bool checkOpenCLRead(const CallExpr *TheCall) {
+  const Expr *Img = 0, *Sampler = 0;
+
+  for (CallExpr::const_arg_iterator It = TheCall->arg_begin(),
+                                    E = TheCall->arg_end();
+                                    It != E;
+                                    ++It) {
+    if (!Img && (*It)->getType()->isImageType())
+      Img = *It;
+
+    if (!Sampler && ((*It)->getType()->isSamplerT()))
+      Sampler = *It;
+  }
+
+  if (!Img || !Sampler)
+    return false;
+
+  return isa<DeclRefExpr>(Img->IgnoreImpCasts()) &&
+         getOpenCLImageAcces(cast<DeclRefExpr>(Img->IgnoreImpCasts())->
+         getDecl())->isReadWrite();
+}
+
 ExprResult
 Sema::CheckBuiltinFunctionCall(FunctionDecl *FDecl, unsigned BuiltinID,
                                CallExpr *TheCall) {
@@ -486,6 +789,39 @@ Sema::CheckBuiltinFunctionCall(FunctionDecl *FDecl, unsigned BuiltinID,
     if (SemaBuiltinAnnotation(*this, TheCall))
       return ExprError();
     break;
+  case Builtin::BIread_pipe:
+  case Builtin::BIwrite_pipe:
+    if (SemaBuiltinPipe(*this, TheCall))
+      return ExprError();
+    break;
+  case Builtin::BIreserve_read_pipe:
+  case Builtin::BIreserve_write_pipe:
+  case Builtin::BIwork_group_reserve_read_pipe:
+  case Builtin::BIwork_group_reserve_write_pipe:
+  case Builtin::BIsub_group_reserve_read_pipe:
+  case Builtin::BIsub_group_reserve_write_pipe:
+    // Since those two functions are declared with var args, therefore we need
+    // a semantic check for the argument.
+    if (SemaBuiltinReservedRWPipe(*this, TheCall))
+      return ExprError();
+
+    // We need to override the return type of the call expression.
+    TheCall->setType(Context.OCLReserveIDTy);
+    break;
+  case Builtin::BIcommit_read_pipe:
+  case Builtin::BIcommit_write_pipe:
+  case Builtin::BIwork_group_commit_read_pipe:
+  case Builtin::BIwork_group_commit_write_pipe:
+  case Builtin::BIsub_group_commit_read_pipe:
+  case Builtin::BIsub_group_commit_write_pipe:
+    if (SemaBuiltinCommitRWPipe(*this, TheCall))
+      return ExprError();
+    break;
+  case Builtin::BIget_pipe_num_packets:
+  case Builtin::BIget_pipe_max_packets:
+    if (SemaNumPacketesPipe(*this, TheCall))
+      return ExprError();
+    break;
   case Builtin::BI__builtin_addressof:
     if (SemaBuiltinAddressof(*this, TheCall))
       return ExprError();
@@ -682,6 +1018,42 @@ static QualType getNeonEltType(NeonTypeFlags Flags, ASTContext &Context,
   llvm_unreachable("Invalid NeonTypeFlag!");
 }
 
+static void checkAccessModifier(Sema &S, ImageAccessAttr* Actual,
+                                ImageAccessAttr* Expected, QualType Ty,
+                                SourceLocation Loc, SourceRange Range) {
+  // We allow two types of conversions:
+  // a) anything -> unkown
+  // b) unkown -> read_only
+  if (!Expected || (!Actual && Expected->isReadOnly()))
+    return;
+
+  if (Actual->getSemanticSpelling() == Expected->getSemanticSpelling())
+    return;
+
+  if (Ty->isImageType()) {
+    if (Actual->isReadWrite() || Expected->isReadWrite())
+      return;
+
+    // We assume that the type declaration has some access qualifier, since it
+    // is mandatory. Not doing so should result a syntax error.
+    S.Diag(Loc, diag::err_mismatch_access_qualifiers) <<
+          Actual << Expected << Range;
+    return;
+  }
+
+  if (Ty->isPipeType()) {
+    // Pipe qualifier defaults to read_only.
+    if((!Actual && Expected->isReadOnly()))
+      return;
+
+    // Since read_write is illegal for pipes, we need strict equality.
+    S.Diag(Loc, diag::err_mismatch_access_qualifiers) <<
+          Actual << Expected << Range;
+    return;
+  }
+}
+
+
 bool Sema::CheckNeonBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall) {
   llvm::APSInt Result;
   uint64_t mask = 0;
@@ -1415,6 +1787,47 @@ void Sema::checkCall(NamedDecl *FDecl, const FunctionProtoType *Proto,
         CheckArgumentWithTypeTag(I, Args.data());
     }
   }
+
+  // We don't treat variadic functions, since we can't match the access modifier
+  // in the function declaration.
+  if (!getLangOpts().OpenCL || VariadicDoesNotApply != CallType)
+    return;
+
+  if (!FDecl || !isa<FunctionDecl>(FDecl))
+    return;
+
+  const FunctionDecl *FnDecl = cast<FunctionDecl>(FDecl);
+
+  // Check if overloadble built-in function with floating point arguments takes
+  // integer values.
+  if (FnDecl->hasAttr<OverloadableAttr>()) {
+    for (unsigned Idx = 0; Idx < Args.size(); Idx++) {
+      const Expr *Arg = Args[Idx];
+      const ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(Arg);
+      if (!ICE || ICE->getCastKind() != CK_IntegralToFloating)
+        continue;
+      Diag(Loc, diag::warn_ocl_bultin_potential_ambiguity) << Range;
+    }
+  }
+
+  // This may indicate that this is a builtin function call, which will be
+  // treated by another part of Sema. (e.g., PipeBiCallSema).
+  if (FnDecl->getNumParams() != Args.size())
+    return;
+
+  // Check whether access attribute are respected.
+  for (unsigned Idx = 0; Idx < Args.size(); Idx++) {
+    const Expr *Arg = Args[Idx];
+    ImageAccessAttr* Expected = getOpenCLImageAcces(FnDecl->getParamDecl(Idx));
+    ImageAccessAttr* Actual = nullptr;
+
+    if (const DeclRefExpr *RefArg = dyn_cast<DeclRefExpr>(Arg->IgnoreImpCasts()))
+      Actual = getOpenCLImageAcces(RefArg->getDecl());
+
+    // Checking that the expected access modifier and the actual one match.
+    checkAccessModifier(*this, Actual, Expected, Arg->getType(),
+                        Arg->getExprLoc(), Range);
+  }
 }
 
 /// CheckConstructorCall - Check a constructor call for correctness and safety
@@ -1462,6 +1875,18 @@ bool Sema::CheckFunctionCall(FunctionDecl *FDecl, CallExpr *TheCall,
   if (getLangOpts().ObjC1)
     DiagnoseCStringFormatDirectiveInCFAPI(*this, FDecl, Args, NumArgs);
 
+  // OpenCL 2.0 Sec. 6.6 prohibits images with 'read_write' qualifier to read
+  // using a sampler.
+  // FIXME: this code is buggy - there should be additional check that TheCall
+  // is OpenCL built-in function call.
+  //if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200) {
+  //  if (checkOpenCLRead(TheCall)) {
+  //    Diag(TheCall->getLocStart(), diag::err_read_write_with_samplers) <<
+  //    TheCall->getSourceRange();
+  //    return true;
+  //  }
+  //}
+
   unsigned CMId = FDecl->getMemoryFunctionKind();
   if (CMId == 0)
     return false;
diff --git a/lib/Sema/SemaDecl.cpp b/lib/Sema/SemaDecl.cpp
index f95d106..4ec97b4 100644
--- a/lib/Sema/SemaDecl.cpp
+++ b/lib/Sema/SemaDecl.cpp
@@ -3884,6 +3884,10 @@ Decl *Sema::ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS,
   //   names into the program, or shall redeclare a name introduced by a
   //   previous declaration.
   if (!DeclaresAnything) {
+    if (getLangOpts().OpenCL) {
+      Diag(DS.getLocStart(), diag::err_no_declarators) << DS.getSourceRange();
+      return 0;
+    }
     // In C, we allow this as a (popular) extension / bug. Don't bother
     // producing further diagnostics for redundant qualifiers after this.
     Diag(DS.getLocStart(), diag::ext_no_declarators) << DS.getSourceRange();
@@ -5701,6 +5705,45 @@ Sema::ActOnVariableDeclarator(Scope *S, Declarator &D, DeclContext *DC,
   QualType R = TInfo->getType();
   DeclarationName Name = GetNameForDeclarator(D).getName();
 
+  // OpenCL v2.0 s6.13.16.1
+  // Pipes can only be passed as arguments to a function.
+  if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200 &&
+      R->isPipeType()) {
+    Diag(D.getIdentifierLoc(), diag::err_pipe_can_be_used_only_as_parameter);
+    D.setInvalidType();
+    return nullptr;
+  }
+
+  // OpenCL v2.0 s6.9.b
+  // An image type can only be used as a type of a function argument.
+  if (getLangOpts().OpenCL && R->isImageType()) {
+    Diag(D.getIdentifierLoc(), diag::err_image_type_can_be_used_only_as_parameter);
+    D.setInvalidType();
+    return nullptr;
+  }
+
+  // OpenCL v1.2 s6.5 p5
+  // There is no generic address space name for program scope variables.
+  // All program scope variables must be declared in the __constant address space.
+  if (getLangOpts().OpenCL && !S->getParent() &&
+      LangAS::opencl_constant != R.getAddressSpace()) {
+    // One exception is the sampler_t which can be declared as "const" instead
+    // of "__constant" address space.
+    if (R->isSamplerT() && R.isConstant(Context));
+    else if (R->isOpenCLSpecificType()) {
+      Diag(D.getIdentifierLoc(), diag::err_invalid_type_for_program_scope_var)
+          << R;
+      D.setInvalidType();
+    } else if (getLangOpts().OpenCLVersion < 200) {
+        Diag(D.getIdentifierLoc(), diag::err_program_scope_variable_non_constant);
+        D.setInvalidType();
+    } else if (LangAS::opencl_global != R.getAddressSpace()) {
+      Diag(D.getIdentifierLoc(),
+             diag::err_program_scope_variable_non_constant_or_global);
+      D.setInvalidType();
+    }
+  }
+
   DeclSpec::SCS SCSpec = D.getDeclSpec().getStorageClassSpec();
   StorageClass SC = StorageClassSpecToVarDeclStorageClass(D.getDeclSpec());
 
@@ -5784,17 +5827,17 @@ Sema::ActOnVariableDeclarator(Scope *S, Declarator &D, DeclContext *DC,
       R.getAddressSpace() == LangAS::opencl_global)) {
       Diag(D.getIdentifierLoc(), diag::err_wrong_sampler_addressspace);
     }
+    if (R.getAddressSpace() == LangAS::opencl_constant) {
+      if (SC == SC_Extern)
+        SC = SC_OpenCLConstantExtern;
+      else
+        SC = SC_OpenCLConstant;
+    }
 
     // OpenCL 1.2 spec, p6.9 r:
-    // The event type cannot be used to declare a program scope variable.
     // The event type cannot be used with the __local, __constant and __global
     // address space qualifiers.
     if (R->isEventT()) {
-      if (S->getParent() == nullptr) {
-        Diag(D.getLocStart(), diag::err_event_t_global_var);
-        D.setInvalidType();
-      }
-
       if (R.getAddressSpace()) {
         Diag(D.getLocStart(), diag::err_event_t_addr_space_qual);
         D.setInvalidType();
@@ -5826,6 +5869,8 @@ Sema::ActOnVariableDeclarator(Scope *S, Declarator &D, DeclContext *DC,
       // This is an out-of-line definition of a static data member.
       switch (SC) {
       case SC_None:
+      case SC_OpenCLConstant:
+      case SC_OpenCLConstantExtern:
         break;
       case SC_Static:
         Diag(D.getDeclSpec().getStorageClassSpecLoc(),
@@ -6119,6 +6164,8 @@ Sema::ActOnVariableDeclarator(Scope *S, Declarator &D, DeclContext *DC,
       case SC_Static:
       case SC_Extern:
       case SC_PrivateExtern:
+      case SC_OpenCLConstant:
+      case SC_OpenCLConstantExtern:
         break;
       }
     } else if (SC == SC_Register) {
@@ -6532,11 +6579,27 @@ void Sema::CheckVariableDeclarationType(VarDecl *NewVD) {
 
   // OpenCL v1.2 s6.8 -- The static qualifier is valid only in program
   // scope.
-  if (getLangOpts().OpenCLVersion == 120 &&
-      !getOpenCLOptions().cl_clang_storage_class_specifiers &&
-      NewVD->isStaticLocal()) {
-    Diag(NewVD->getLocation(), diag::err_static_function_scope);
-    NewVD->setInvalidDecl();
+  // (same for Metal, enabled for CUDA as well for compatibility)
+  if (NewVD->isStaticLocal() &&
+      ((getLangOpts().OpenCL &&
+        getLangOpts().OpenCLVersion >= 120 &&
+        !getOpenCLOptions().cl_clang_storage_class_specifiers) ||
+       getLangOpts().CUDA)) {
+    // however, if it is constexpr, this can be safely put into the constant address space
+    if (NewVD->isConstexpr()) {
+      // CUDA (backend) can handle this on its own
+      if (getLangOpts().OpenCL) {
+        QualType constant_T = Context.getAddrSpaceQualType(T, LangAS::opencl_constant);
+        TypeSourceInfo* constant_Tinfo = Context.getTrivialTypeSourceInfo(constant_T);
+        NewVD->setType(constant_Tinfo->getType());
+        NewVD->setTypeSourceInfo(constant_Tinfo);
+      }
+    }
+    // CUDA shared/local decls are allowed to be static, so ignore them
+    else if(!(getLangOpts().CUDA && NewVD->hasAttr<CUDASharedAttr>())) {
+      Diag(NewVD->getLocation(), diag::err_static_function_scope);
+      NewVD->setInvalidDecl();
+    }
     return;
   }
 
@@ -6547,28 +6610,43 @@ void Sema::CheckVariableDeclarationType(VarDecl *NewVD) {
   // address space.
   if (getLangOpts().OpenCL) {
     if (NewVD->isFileVarDecl()) {
-      if (!T->isSamplerT() &&
-          !(T.getAddressSpace() == LangAS::opencl_constant ||
-            (T.getAddressSpace() == LangAS::opencl_global &&
-             getLangOpts().OpenCLVersion == 200))) {
-        if (getLangOpts().OpenCLVersion == 200)
-          Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space)
-              << "global or constant";
-        else
-          Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space)
-              << "constant";
-        NewVD->setInvalidDecl();
-        return;
+      if (!T->isSamplerT()) {
+        // if the variable doesn't have an address space, but is a global static const variable,
+        // automatically add the constant address space
+        if (T.getAddressSpace() == 0 &&
+            (NewVD->isStaticDataMember() || NewVD->hasGlobalStorage()) &&
+            T.isConstQualified()) {
+          QualType constant_T = Context.getAddrSpaceQualType(T, LangAS::opencl_constant);
+          TypeSourceInfo* constant_Tinfo = Context.getTrivialTypeSourceInfo(constant_T);
+          NewVD->setType(constant_Tinfo->getType());
+          NewVD->setTypeSourceInfo(constant_Tinfo);
+        }
+        else {
+          if (!(T.getAddressSpace() == LangAS::opencl_constant ||
+                (T.getAddressSpace() == LangAS::opencl_global &&
+                 getLangOpts().OpenCLVersion >= 200))) {
+            if (getLangOpts().OpenCLVersion >= 200)
+              Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space)
+                  << "global or constant";
+            else
+              Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space)
+                  << "constant";
+            NewVD->setInvalidDecl();
+            return;
+          }
+        }
       }
     } else {
+      // TODO: does this need automatic "constant" handling?
+
       // OpenCL v2.0 s6.5.1 - Variables defined at program scope and static
       // variables inside a function can also be declared in the global
       // address space.
       if (NewVD->isStaticLocal() &&
           !(T.getAddressSpace() == LangAS::opencl_constant ||
             (T.getAddressSpace() == LangAS::opencl_global &&
-             getLangOpts().OpenCLVersion == 200))) {
-        if (getLangOpts().OpenCLVersion == 200)
+             getLangOpts().OpenCLVersion >= 200))) {
+        if (getLangOpts().OpenCLVersion >= 200)
           Diag(NewVD->getLocation(), diag::err_opencl_global_invalid_addr_space)
               << "global or constant";
         else
@@ -6582,7 +6660,7 @@ void Sema::CheckVariableDeclarationType(VarDecl *NewVD) {
       if (T.getAddressSpace() == LangAS::opencl_constant ||
           T.getAddressSpace() == LangAS::opencl_local) {
         FunctionDecl *FD = getCurFunctionDecl();
-        if (FD && !FD->hasAttr<OpenCLKernelAttr>()) {
+        if (FD && !FD->hasAttr<ComputeKernelAttr>()) {
           if (T.getAddressSpace() == LangAS::opencl_constant)
             Diag(NewVD->getLocation(), diag::err_opencl_non_kernel_variable)
                 << "constant";
@@ -6680,6 +6758,24 @@ void Sema::CheckVariableDeclarationType(VarDecl *NewVD) {
     NewVD->setInvalidDecl();
     return;
   }
+
+  // OpenCL 2.0: Enforce block 6.12.5: block's prototype cannot be variadic.
+  if (getLangOpts().OpenCL && LangOpts.OpenCLVersion >= 200 && T->isBlockPointerType()) {
+    const BlockPointerType *BlkTy = T->getAs<BlockPointerType>();
+    assert(BlkTy && "Not a block pointer.");
+
+    const FunctionProtoType *FTy =
+      BlkTy->getPointeeType()->getAs<FunctionProtoType>();
+    assert(FTy && "Not a function prototype.");
+
+    if (FTy->isVariadic()) {
+      Diag(NewVD->getLocation(), diag::err_block_proto_variadic) << T
+      << NewVD->getSourceRange();
+      NewVD->setInvalidDecl();
+      return;
+    }
+
+  }
 }
 
 /// \brief Perform semantic checking on a newly-created variable
@@ -7202,12 +7298,16 @@ enum OpenCLParamType {
   RecordKernelParam
 };
 
-static OpenCLParamType getOpenCLKernelParameterType(QualType PT) {
+static OpenCLParamType getOpenCLKernelParameterType(QualType PT, const bool is_metal) {
   if (PT->isPointerType()) {
     QualType PointeeType = PT->getPointeeType();
     if (PointeeType->isPointerType())
       return PtrPtrKernelParam;
-    return PointeeType.getAddressSpace() == 0 ? PrivatePtrKernelParam
+
+    unsigned addrSpace = PointeeType.getAddressSpace();
+    return (addrSpace != LangAS::opencl_global &&
+            addrSpace != LangAS::opencl_constant &&
+            addrSpace != LangAS::opencl_local) ? PrivatePtrKernelParam
                                               : PtrKernelParam;
   }
 
@@ -7223,7 +7323,10 @@ static OpenCLParamType getOpenCLKernelParameterType(QualType PT) {
   if (PT->isEventT())
     return InvalidKernelParam;
 
-  if (PT->isHalfType())
+  if (PT->isReserveIDT())
+    return InvalidKernelParam;
+
+  if (PT->isHalfType() && !is_metal)
     return InvalidKernelParam;
 
   if (PT->isRecordType())
@@ -7236,7 +7339,8 @@ static void checkIsValidOpenCLKernelParameter(
   Sema &S,
   Declarator &D,
   ParmVarDecl *Param,
-  llvm::SmallPtrSetImpl<const Type *> &ValidTypes) {
+  llvm::SmallPtrSetImpl<const Type *> &ValidTypes,
+  const bool is_metal) {
   QualType PT = Param->getType();
 
   // Cache the valid types we encounter to avoid rechecking structs that are
@@ -7244,7 +7348,7 @@ static void checkIsValidOpenCLKernelParameter(
   if (ValidTypes.count(PT.getTypePtr()))
     return;
 
-  switch (getOpenCLKernelParameterType(PT)) {
+  switch (getOpenCLKernelParameterType(PT, is_metal)) {
   case PtrPtrKernelParam:
     // OpenCL v1.2 s6.9.a:
     // A kernel function argument cannot be declared as a
@@ -7308,6 +7412,8 @@ static void checkIsValidOpenCLKernelParameter(
       continue;
     }
 
+    // TODO: this should also check base classes
+
     // Adds everything except the original parameter declaration (which is not a
     // field itself) to the history stack.
     const RecordDecl *RD;
@@ -7321,13 +7427,17 @@ static void checkIsValidOpenCLKernelParameter(
     // Add a null marker so we know when we've gone back up a level
     VisitStack.push_back(nullptr);
 
+    // if this is an aggregate of images, all is well
+    if (RD->getTypeForDecl()->isAggregateImageType())
+      continue;
+
     for (const auto *FD : RD->fields()) {
       QualType QT = FD->getType();
 
       if (ValidTypes.count(QT.getTypePtr()))
         continue;
 
-      OpenCLParamType ParamType = getOpenCLKernelParameterType(QT);
+      OpenCLParamType ParamType = getOpenCLKernelParameterType(QT, is_metal);
       if (ParamType == ValidKernelParam)
         continue;
 
@@ -8235,15 +8345,8 @@ Sema::ActOnFunctionDeclarator(Scope *S, Declarator &D, DeclContext *DC,
     }
   }
 
-  if (NewFD->hasAttr<OpenCLKernelAttr>()) {
-    // OpenCL v1.2 s6.8 static is invalid for kernel functions.
-    if ((getLangOpts().OpenCLVersion >= 120)
-        && (SC == SC_Static)) {
-      Diag(D.getIdentifierLoc(), diag::err_static_kernel);
-      D.setInvalidType();
-    }
-    
-    // OpenCL v1.2, s6.9 -- Kernels can only have return type void.
+  if (NewFD->hasAttr<ComputeKernelAttr>()) {
+    // Kernels can only have return type void.
     if (!NewFD->getReturnType()->isVoidType()) {
       SourceRange RTRange = NewFD->getReturnTypeSourceRange();
       Diag(D.getIdentifierLoc(), diag::err_expected_kernel_void_return_type)
@@ -8251,10 +8354,23 @@ Sema::ActOnFunctionDeclarator(Scope *S, Declarator &D, DeclContext *DC,
                                 : FixItHint());
       D.setInvalidType();
     }
+  }
+
+  if(NewFD->hasAttr<ComputeKernelAttr>() ||
+     NewFD->hasAttr<GraphicsVertexShaderAttr>() ||
+     NewFD->hasAttr<GraphicsFragmentShaderAttr>()) {
+    // static is invalid for kernel/vertex/fragment functions.
+    if (SC == SC_Static) {
+      Diag(D.getIdentifierLoc(), diag::err_static_kernel);
+      D.setInvalidType();
+    }
 
-    llvm::SmallPtrSet<const Type *, 16> ValidTypes;
-    for (auto Param : NewFD->params())
-      checkIsValidOpenCLKernelParameter(*this, D, Param, ValidTypes);
+    // only check this for opencl/metal
+    if (getLangOpts().OpenCL) {
+      llvm::SmallPtrSet<const Type *, 16> ValidTypes;
+      for (auto Param : NewFD->params())
+        checkIsValidOpenCLKernelParameter(*this, D, Param, ValidTypes, getLangOpts().Metal);
+    }
   }
   for (FunctionDecl::param_iterator PI = NewFD->param_begin(),
        PE = NewFD->param_end(); PI != PE; ++PI) {
@@ -8569,7 +8685,10 @@ bool Sema::CheckFunctionDeclaration(Scope *S, FunctionDecl *NewFD,
     // the function returns a UDT (class, struct, or union type) that is not C
     // compatible, and if it does, warn the user.
     // But, issue any diagnostic on the first declaration only.
-    if (Previous.empty() && NewFD->isExternC()) {
+    if (Previous.empty() && NewFD->isExternC() &&
+        // ignore this for vertex/fragment shaders
+        !NewFD->hasAttr<GraphicsVertexShaderAttr>() &&
+        !NewFD->hasAttr<GraphicsFragmentShaderAttr>()) {
       QualType R = NewFD->getReturnType();
       if (R->isIncompleteType() && !R->isVoidType())
         Diag(NewFD->getLocation(), diag::warn_return_value_udt_incomplete)
@@ -8610,9 +8729,10 @@ void Sema::CheckMain(FunctionDecl* FD, const DeclSpec& DS) {
     FD->setConstexpr(false);
   }
 
-  if (getLangOpts().OpenCL) {
+  // TODO: this doesn't seem necessary?
+  if (getLangOpts().OpenCL || getLangOpts().CUDA) {
     Diag(FD->getLocation(), diag::err_opencl_no_main)
-        << FD->hasAttr<OpenCLKernelAttr>();
+        << FD->hasAttr<ComputeKernelAttr>();
     FD->setInvalidDecl();
     return;
   }
@@ -9473,7 +9593,8 @@ void Sema::AddInitializerToDecl(Decl *RealDecl, Expr *Init,
     // C++ does not have this restriction.
     if (!getLangOpts().CPlusPlus && !VDecl->isInvalidDecl()) {
       const Expr *Culprit;
-      if (VDecl->getStorageClass() == SC_Static)
+      if (VDecl->getStorageClass() == SC_Static ||
+          VDecl->getStorageClass() == SC_OpenCLConstant)
         CheckForConstantInitializer(Init, DclT);
       // C89 is stricter than C99 for non-static aggregate types.
       // C89 6.5.7p3: All the expressions [...] in an initializer list
@@ -9707,7 +9828,7 @@ void Sema::ActOnUninitializedDecl(Decl *RealDecl,
     // be initialized.
     if (!Var->isInvalidDecl() &&
         Var->getType().getAddressSpace() == LangAS::opencl_constant &&
-        Var->getStorageClass() != SC_Extern && !Var->getInit()) {
+        Var->getStorageClass() != SC_OpenCLConstantExtern && !Var->getInit()) {
       Diag(Var->getLocation(), diag::err_opencl_constant_no_init);
       Var->setInvalidDecl();
       return;
@@ -9915,6 +10036,9 @@ void Sema::ActOnCXXForRangeDecl(Decl *D) {
   case SC_Register:
     Error = 4;
     break;
+  case SC_OpenCLConstant:
+  case SC_OpenCLConstantExtern:
+    llvm_unreachable("Unexpected storage class");
   }
   if (Error != -1) {
     Diag(VD->getOuterLocStart(), diag::err_for_range_storage_class)
@@ -10628,11 +10752,17 @@ ParmVarDecl *Sema::CheckParameter(DeclContext *DC, SourceLocation StartLoc,
   if (T.getAddressSpace() != 0) {
     // OpenCL allows function arguments declared to be an array of a type
     // to be qualified with an address space.
-    if (!(getLangOpts().OpenCL && T->isArrayType())) {
+    if (!((getLangOpts().OpenCL || getLangOpts().CUDA) && T->isArrayType())) {
       Diag(NameLoc, diag::err_arg_with_address_space);
       New->setInvalidDecl();
     }
   }   
+  // Passing pointer to image is invalid in OpenCL.
+  if (getLangOpts().OpenCL && T->isPointerType() &&
+      T->getPointeeType()->isImageType()) {
+    Diag(NameLoc, diag::err_opencl_pointer_to_image);
+    New->setInvalidDecl();
+  }
 
   return New;
 }
@@ -10673,6 +10803,28 @@ void Sema::ActOnFinishKNRParamDeclarations(Scope *S, Declarator &D,
   }
 }
 
+static void AggregateTypeCompleter(Sema& S, const CXXRecordDecl* decl) {
+	if(decl == nullptr) return;
+	
+	// make sure decl is complete
+	S.RequireCompleteType(decl->getLocStart(), QualType(decl->getTypeForDecl(), 0),
+						  diag::err_typecheck_decl_incomplete_type);
+	
+	// must have definition
+	if(!decl->hasDefinition()) return;
+	
+	// iterate over / recurse into all bases, and complete all their fields
+	for(const auto& base : decl->bases()) {
+		AggregateTypeCompleter(S, base.getType()->getAsCXXRecordDecl());
+	}
+	
+	// iterate over and complete all fields
+	for(const auto& field : decl->fields()) {
+		S.RequireCompleteType(field->getLocStart(), field->getType(),
+							  diag::err_typecheck_decl_incomplete_type);
+	}
+}
+
 Decl *
 Sema::ActOnStartOfFunctionDef(Scope *FnBodyScope, Declarator &D,
                               MultiTemplateParamsArg TemplateParameterLists,
@@ -10720,8 +10872,10 @@ static bool ShouldWarnAboutMissingPrototype(const FunctionDecl *FD,
   if (FD->isFunctionTemplateSpecialization())
     return false;
 
-  // Don't warn for OpenCL kernels.
-  if (FD->hasAttr<OpenCLKernelAttr>())
+  // Don't warn for compute kernels, or vertex/fragment shaders.
+  if (FD->hasAttr<ComputeKernelAttr>() ||
+      FD->hasAttr<GraphicsVertexShaderAttr>() ||
+      FD->hasAttr<GraphicsFragmentShaderAttr>())
     return false;
 
   // Don't warn on explicitly deleted functions.
@@ -10901,6 +11055,32 @@ Decl *Sema::ActOnStartOfFunctionDef(Scope *FnBodyScope, Decl *D,
   CheckParmsForFunctionDef(FD->param_begin(), FD->param_end(),
                            /*CheckParameterNames=*/true);
 
+  // for kernel and shader functions: make sure that function parameter types are complete,
+  // including pointer/pointee types that must always be complete as well, since their sizes
+  // and (possibly) structure need to be known later on
+  if(FD->hasAttr<ComputeKernelAttr>() ||
+     FD->hasAttr<GraphicsVertexShaderAttr>() ||
+     FD->hasAttr<GraphicsFragmentShaderAttr>()) {
+    for (const auto& Param : FD->params()) {
+      const auto param_type = Param->getType();
+      const CXXRecordDecl* cxx_rdecl = nullptr;
+      if(param_type->isPointerType()) {
+        const auto pointee_type = param_type->getPointeeType();
+        RequireCompleteType(Param->getLocation(), pointee_type,
+                            diag::err_typecheck_decl_incomplete_type);
+        cxx_rdecl = pointee_type->getAsCXXRecordDecl();
+      }
+      else {
+        RequireCompleteType(Param->getLocation(), param_type,
+                            diag::err_typecheck_decl_incomplete_type);
+        cxx_rdecl = param_type->getAsCXXRecordDecl();
+      }
+
+      // if this is an aggregate, ensure that all contained types are also complete
+      AggregateTypeCompleter(*this, cxx_rdecl);
+    }
+  }
+
   // Introduce our parameters into the function scope
   for (auto Param : FD->params()) {
     Param->setOwningFunction(FD);
@@ -11345,6 +11525,9 @@ NamedDecl *Sema::ImplicitlyDefineFunction(SourceLocation Loc,
   unsigned diag_id;
   if (II.getName().startswith("__builtin_"))
     diag_id = diag::warn_builtin_unknown;
+  else if (getLangOpts().OpenCL)
+    // Don't allow imlicit function declarations in OpenCL
+    diag_id = diag::err_opencl_implicit_function_decl;
   else if (getLangOpts().C99)
     diag_id = diag::ext_implicit_function_decl;
   else
@@ -13076,7 +13259,7 @@ FieldDecl *Sema::CheckFieldDecl(DeclarationName Name, QualType T,
   }
 
   // OpenCL v1.2 s6.9.c: bitfields are not supported.
-  if (BitWidth && getLangOpts().OpenCL) {
+  if (BitWidth && getLangOpts().OpenCL && !getLangOpts().CPlusPlus) {
     Diag(Loc, diag::err_opencl_bitfields);
     InvalidDecl = true;
   }
diff --git a/lib/Sema/SemaDeclAttr.cpp b/lib/Sema/SemaDeclAttr.cpp
index f94c822..b8ff0c4 100644
--- a/lib/Sema/SemaDeclAttr.cpp
+++ b/lib/Sema/SemaDeclAttr.cpp
@@ -79,9 +79,12 @@ static bool hasFunctionProto(const Decl *D) {
 /// parameters. It is an error to call this on a K&R function (use
 /// hasFunctionProto first).
 static unsigned getFunctionOrMethodNumParams(const Decl *D) {
-  if (const FunctionType *FnTy = D->getFunctionType())
-    return cast<FunctionProtoType>(FnTy)->getNumParams();
-  if (const BlockDecl *BD = dyn_cast<BlockDecl>(D))
+  if (const FunctionType *FnTy = D->getFunctionType()) {
+    if (hasFunctionProto(D))
+      return cast<FunctionProtoType>(FnTy)->getNumParams();
+    else return 0;
+  }
+  if (const auto *BD = dyn_cast<BlockDecl>(D))
     return BD->getNumParams();
   return cast<ObjCMethodDecl>(D)->param_size();
 }
@@ -2255,6 +2258,94 @@ static void handleVisibilityAttr(Sema &S, Decl *D, const AttributeList &Attr,
     D->addAttr(newAttr);
 }
 
+static void handleFloorImageDataTypeAttr(Sema &S, Decl *D, const AttributeList &Attr) {
+  if (!Attr.hasParsedType()) {
+    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments)
+      << Attr.getName() << 1;
+    return;
+  }
+
+  TypeSourceInfo *ParmTSI = nullptr;
+  S.GetTypeFromParser(Attr.getTypeArg(), &ParmTSI);
+  D->addAttr(::new (S.Context) FloorImageDataTypeAttr(Attr.getLoc(), S.Context, ParmTSI,
+                                                      Attr.getAttributeSpellingListIndex()));
+}
+
+static void handleGraphicsFBOColorLocationAttr(Sema &S, Decl *D, const AttributeList &Attr) {
+  if (!checkAttributeNumArgs(S, Attr, 1)) return;
+  S.AddGraphicsFBOColorLocationAttr(Attr.getRange(), D, Attr.getArgAsExpr(0),
+                                    Attr.getAttributeSpellingListIndex());
+}
+
+void Sema::AddGraphicsFBOColorLocationAttr(SourceRange AttrRange, Decl *D, Expr *E, unsigned SpellingListIndex) {
+  GraphicsFBOColorLocationAttr TmpAttr(AttrRange, Context, E, SpellingListIndex);
+  SourceLocation AttrLoc = AttrRange.getBegin();
+
+  QualType T;
+  if (ValueDecl *VD = dyn_cast<ValueDecl>(D))
+    T = VD->getType();
+  else {
+    Diag(AttrLoc, diag::err_attribute_argument_type) <<
+      &TmpAttr << AANT_ArgumentIntegerConstant;
+    return;
+  }
+
+  // TODO: check usage
+
+  if (!E->isValueDependent()) {
+    // TODO: might want to use/check isPotentialConstantExprUnevaluated
+
+    llvm::APSInt ColorLoc(32);
+    ExprResult ICE
+      = VerifyIntegerConstantExpression(E, &ColorLoc,
+          diag::err_align_value_attribute_argument_not_int,
+            /*AllowFold*/ true);
+    if (ICE.isInvalid())
+      return;
+
+    // check for < 0 location
+    if (ColorLoc.isNegative()) {
+      unsigned diagID = Diags.getCustomDiagID(DiagnosticsEngine::Error, "%0");
+      Diags.Report(AttrRange.getBegin(), diagID) << "location must not be negative!";
+      return;
+    }
+
+    auto loc_attr = ::new (Context) GraphicsFBOColorLocationAttr(AttrRange, Context, ICE.get(), SpellingListIndex);
+    loc_attr->setEvalLocation((unsigned int)ColorLoc.getZExtValue());
+    D->addAttr(loc_attr);
+    return;
+  }
+
+  // Save dependent expressions in the AST to be instantiated.
+  D->addAttr(::new (Context) GraphicsFBOColorLocationAttr(TmpAttr));
+  return;
+}
+
+static void handleGraphicsFBODepthTypeAttr(Sema &S, Decl *D, const AttributeList &Attr) {
+  if (!checkAttributeNumArgs(S, Attr, 1)) return;
+
+  GraphicsFBODepthTypeAttr::DepthQualifierType type;
+  if (Attr.isArgIdent(0)) {
+    IdentifierLoc *Ident = Attr.getArgAsIdent(0);
+    StringRef TypeString = Ident->Ident->getName();
+
+    if (!GraphicsFBODepthTypeAttr::ConvertStrToDepthQualifierType(TypeString, type)) {
+      S.Diag(Ident->Loc, diag::warn_attribute_type_not_supported)
+        << Attr.getName() << TypeString;
+      return;
+    }
+  }
+  else {
+    S.Diag(Attr.getLoc(), diag::err_attribute_argument_type) <<
+      Attr.getName() << AANT_ArgumentIdentifier;
+    return;
+  }
+
+  D->addAttr(::new (S.Context)
+             GraphicsFBODepthTypeAttr(Attr.getRange(), S.Context, type,
+                                      Attr.getAttributeSpellingListIndex()));
+}
+
 static void handleObjCMethodFamilyAttr(Sema &S, Decl *decl,
                                        const AttributeList &Attr) {
   ObjCMethodDecl *method = cast<ObjCMethodDecl>(decl);
@@ -3606,29 +3697,6 @@ static void handleOptimizeNoneAttr(Sema &S, Decl *D,
     D->addAttr(Optnone);
 }
 
-static void handleGlobalAttr(Sema &S, Decl *D, const AttributeList &Attr) {
-  if (checkAttrMutualExclusion<CUDADeviceAttr>(S, D, Attr.getRange(),
-                                               Attr.getName()) ||
-      checkAttrMutualExclusion<CUDAHostAttr>(S, D, Attr.getRange(),
-                                             Attr.getName())) {
-    return;
-  }
-  FunctionDecl *FD = cast<FunctionDecl>(D);
-  if (!FD->getReturnType()->isVoidType()) {
-    SourceRange RTRange = FD->getReturnTypeSourceRange();
-    S.Diag(FD->getTypeSpecStartLoc(), diag::err_kern_type_not_void_return)
-        << FD->getType()
-        << (RTRange.isValid() ? FixItHint::CreateReplacement(RTRange, "void")
-                              : FixItHint());
-    return;
-  }
-
-  D->addAttr(::new (S.Context)
-              CUDAGlobalAttr(Attr.getRange(), S.Context,
-                             Attr.getAttributeSpellingListIndex()));
-
-}
-
 static void handleGNUInlineAttr(Sema &S, Decl *D, const AttributeList &Attr) {
   FunctionDecl *Fn = cast<FunctionDecl>(D);
   if (!Fn->isInlineSpecified()) {
@@ -3726,6 +3794,34 @@ static void handleCallConvAttr(Sema &S, Decl *D, const AttributeList &Attr) {
   }
 }
 
+// OpenCL 2.0 spec, section 6.7.2:
+// The optional __attribute__((nosvm)) qualifier can be used with a pointer
+// variable to informa the compiler that the pointer does not refer to a shared
+// virtual memory region.
+static void handleOpenCLNoSVMAttr(Sema &S, Decl *D, const AttributeList &Attr){
+  if (S.getLangOpts().OpenCLVersion < 200) {
+    S.Diag(Attr.getLoc(), diag::err_nosvm_opencl_version);
+    Attr.setInvalid();
+    return;
+  }
+
+  if (!isa<VarDecl>(D)) {
+    S.Diag(Attr.getLoc(), diag::err_nosvm_attr_not_pointer);
+    Attr.setInvalid();
+    return;
+  }
+
+  VarDecl *VD = llvm::cast<VarDecl>(D);
+
+  if (!VD->getType()->isPointerType()) {
+    S.Diag(Attr.getLoc(), diag::err_nosvm_attr_not_pointer);
+    Attr.setInvalid();
+    return;
+  }
+
+  D->addAttr(OpenCLNoSVMAttr::CreateImplicit(S.Context, Attr.getRange()));
+}
+
 bool Sema::CheckCallingConvAttr(const AttributeList &attr, CallingConv &CC, 
                                 const FunctionDecl *FD) {
   if (attr.isInvalid())
@@ -5066,16 +5162,13 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   case AttributeList::AT_FormatArg:
     handleFormatArgAttr(S, D, Attr);
     break;
-  case AttributeList::AT_CUDAGlobal:
-    handleGlobalAttr(S, D, Attr);
-    break;
   case AttributeList::AT_CUDADevice:
-    handleSimpleAttributeWithExclusions<CUDADeviceAttr, CUDAGlobalAttr>(S, D,
-                                                                        Attr);
+    handleSimpleAttributeWithExclusions<CUDADeviceAttr, ComputeKernelAttr>(S, D,
+                                                                           Attr);
     break;
   case AttributeList::AT_CUDAHost:
-    handleSimpleAttributeWithExclusions<CUDAHostAttr, CUDAGlobalAttr>(S, D,
-                                                                      Attr);
+    handleSimpleAttributeWithExclusions<CUDAHostAttr, ComputeKernelAttr>(S, D,
+                                                                         Attr);
     break;
   case AttributeList::AT_GNUInline:
     handleGNUInlineAttr(S, D, Attr);
@@ -5331,11 +5424,41 @@ static void ProcessDeclAttribute(Sema &S, Scope *scope, Decl *D,
   case AttributeList::AT_IntelOclBicc:
     handleCallConvAttr(S, D, Attr);
     break;
-  case AttributeList::AT_OpenCLKernel:
-    handleSimpleAttribute<OpenCLKernelAttr>(S, D, Attr);
+  case AttributeList::AT_ComputeKernel:
+    handleSimpleAttribute<ComputeKernelAttr>(S, D, Attr);
+    break;
+  case AttributeList::AT_GraphicsVertexShader:
+    handleSimpleAttribute<GraphicsVertexShaderAttr>(S, D, Attr);
+    break;
+  case AttributeList::AT_GraphicsFragmentShader:
+    handleSimpleAttribute<GraphicsFragmentShaderAttr>(S, D, Attr);
+    break;
+  case AttributeList::AT_ImageAccess:
+    handleSimpleAttribute<ImageAccessAttr>(S, D, Attr);
+    break;
+  case AttributeList::AT_OpenCLNoSVM:
+    handleOpenCLNoSVMAttr(S, D, Attr);
+    break;
+  case AttributeList::AT_FloorImageDataType:
+    handleFloorImageDataTypeAttr(S, D, Attr);
+    break;
+  case AttributeList::AT_VectorCompat:
+    handleSimpleAttribute<VectorCompatAttr>(S, D, Attr);
+    break;
+  case AttributeList::AT_GraphicsFBOColorLocation:
+    handleGraphicsFBOColorLocationAttr(S, D, Attr);
+    break;
+  case AttributeList::AT_GraphicsFBODepthType:
+    handleGraphicsFBODepthTypeAttr(S, D, Attr);
+    break;
+  case AttributeList::AT_GraphicsVertexPosition:
+    handleSimpleAttribute<GraphicsVertexPositionAttr>(S, D, Attr);
+    break;
+  case AttributeList::AT_GraphicsPointSize:
+    handleSimpleAttribute<GraphicsPointSizeAttr>(S, D, Attr);
     break;
-  case AttributeList::AT_OpenCLImageAccess:
-    handleSimpleAttribute<OpenCLImageAccessAttr>(S, D, Attr);
+  case AttributeList::AT_GraphicsStageInput:
+    handleSimpleAttribute<GraphicsStageInputAttr>(S, D, Attr);
     break;
   case AttributeList::AT_InternalLinkage:
     handleInternalLinkageAttr(S, D, Attr);
@@ -5492,7 +5615,7 @@ void Sema::ProcessDeclAttributeList(Scope *S, Decl *D,
   // good to have a way to specify "these attributes must appear as a group",
   // for these. Additionally, it would be good to have a way to specify "these
   // attribute must never appear as a group" for attributes like cold and hot.
-  if (!D->hasAttr<OpenCLKernelAttr>()) {
+  if (!D->hasAttr<ComputeKernelAttr>()) {
     // These attributes cannot be applied to a non-kernel function.
     if (Attr *A = D->getAttr<ReqdWorkGroupSizeAttr>()) {
       // FIXME: This emits a different error message than
diff --git a/lib/Sema/SemaExpr.cpp b/lib/Sema/SemaExpr.cpp
index 5a2eb60..d8eb2a1 100644
--- a/lib/Sema/SemaExpr.cpp
+++ b/lib/Sema/SemaExpr.cpp
@@ -44,6 +44,7 @@
 #include "clang/Sema/SemaFixItUtils.h"
 #include "clang/Sema/Template.h"
 #include "llvm/Support/ConvertUTF.h"
+#include <sstream>
 using namespace clang;
 using namespace sema;
 
@@ -197,6 +198,96 @@ DiagnoseAvailabilityOfDecl(Sema &S, NamedDecl *D, SourceLocation Loc,
     return Result;
 }
 
+// \brief Preform dynamic type checking on the actual arguments passed to the
+// call.
+static bool CheckEnqueueKernel(const CallExpr *TheCall, ArrayRef<Expr*> Args,
+                               Sema &S) {
+  // The index of the block paramater in overload I.
+  #define BLOCK_INDEX_I   3U
+  // The index of the block paramater in overload II.
+  #define BLOCK_INDEX_II  6U
+
+  // Minimum number of arguments in overload I.
+  #define MIN_NUM_ARGS_I  5U
+  // Minimum number of arguments in overload II.
+  #define MIN_NUM_ARGS_II 8U
+
+  QualType BlkTy;
+
+  // There are two overloads of the function which receives blocks, we need
+  // to figure if the call is one of them.
+  const unsigned NumArgs = Args.size();
+  unsigned BlkIdx = 0;
+
+  if (NumArgs >= MIN_NUM_ARGS_I) {
+    QualType ArgTy = Args[BLOCK_INDEX_I]->getType();
+
+    if (ArgTy->isBlockPointerType()) {
+      BlkTy = ArgTy->getPointeeType();
+      BlkIdx = BLOCK_INDEX_I;
+    }
+    else if (NumArgs >= MIN_NUM_ARGS_II) {
+      ArgTy = Args[BLOCK_INDEX_II]->getType();
+      if (ArgTy->isBlockPointerType()) {
+        BlkTy = ArgTy->getPointeeType();
+        BlkIdx = BLOCK_INDEX_II;
+      }
+    }
+  }
+
+  if (BlkTy.isNull())
+    return false;
+
+  bool Invalid = false;
+
+  // Making sure that if the type is a pointer, it is in local AS.
+  const FunctionProtoType *BlkProto = BlkTy->getAs<FunctionProtoType>();
+  for (unsigned i = 0; i<BlkProto->getNumParams(); i++) {
+    QualType ParmTy = BlkProto->getParamType(i);
+    if (!ParmTy->isPointerType() ||
+        ParmTy->getPointeeType().getAddressSpace() != LangAS::opencl_local) {
+      S.Diag(Args[BlkIdx]->getLocStart(), diag::err_invalid_block_as_parameter)
+             << BlkTy << TheCall->getSourceRange();
+      Invalid = true;
+    }
+  }
+
+  // Making sure that all variadic arguments are of type unsigned int.
+  unsigned VariadicIdx = ((FunctionDecl*)TheCall->getCalleeDecl())->
+           getMinRequiredArguments();
+
+  // Making sure that the number of local arg sizes corresponds the number of
+  // pointers in the block.
+  unsigned NumLocalSizes = NumArgs - VariadicIdx +1;
+  if (BlkProto->getNumParams() != NumLocalSizes) {
+    S.Diag(Args[BlkIdx]->getLocStart(),
+           diag::err_enqueue_kernel_num_args_mismatch) <<
+    TheCall->getSourceRange();
+    Invalid = true;
+  }
+
+ for (unsigned i=(VariadicIdx-1); i<NumArgs; i++) {
+    const Expr *Arg = Args[i];
+    const BuiltinType *BITy = Arg->getType().getCanonicalType()->
+                              getAs<BuiltinType>();
+    if (BITy && (BITy->getKind() == BuiltinType::UInt ||
+                 BITy->getKind() == BuiltinType::ULong ||
+                 BITy->getKind() == BuiltinType::UInt128 ||
+                 BITy->getKind() == BuiltinType::ULongLong)){
+         //at va positions natively accept UInt type
+          //and accept U types to be interpreted as 32bit sizes of local mem
+          continue;
+      }
+      else {
+          S.Diag(Arg->getLocStart(), diag::err_variadic_enqueue_kernel) <<
+          TheCall->getSourceRange();
+          Invalid = true;
+      }
+  }
+
+  return Invalid;
+}
+
 /// \brief Emit a note explaining that this function is deleted.
 void Sema::NoteDeletedFunction(FunctionDecl *Decl) {
   assert(Decl->isDeleted());
@@ -508,7 +599,7 @@ ExprResult Sema::DefaultFunctionArrayConversion(Expr *E, bool Diagnose) {
   if (Ty->isFunctionType()) {
     // If we are here, we are not calling a function but taking
     // its address (which is not allowed in OpenCL v1.0 s6.8.a.3).
-    if (getLangOpts().OpenCL) {
+    if (getLangOpts().OpenCL && !LangOpts.CPlusPlus) {
       if (Diagnose)
         Diag(E->getExprLoc(), diag::err_opencl_taking_function_address);
       return ExprError();
@@ -791,6 +882,35 @@ ExprResult Sema::UsualUnaryConversions(Expr *E) {
   return E;
 }
 
+// Find out which conversion function to call for a vector with the given
+// element type.
+//
+// TODO: unused?
+/*static std::string vec_conversion_function_for_type(BuiltinType::Kind elem_type)
+{
+    switch (elem_type)
+    {
+        case BuiltinType::Float:
+            return "convert_double";
+        case BuiltinType::Char_S:
+        case BuiltinType::SChar:
+        case BuiltinType::Short:
+            return "convert_int";
+        case BuiltinType::Char_U:
+        case BuiltinType::UChar:
+        case BuiltinType::UShort:
+            return "convert_uint";
+        default:
+            // We won't get here because the call to this function will happen
+            // only if elem_type->isPromotableIntegerType(), which apart
+            // from the above types includes bool, and vectors of bools don't
+            // currently exist in OpenCL
+            //
+            assert(0 && "Invalid vector type in conversion");
+            return "";
+    }
+}*/
+
 /// DefaultArgumentPromotion (C99 6.5.2.2p6). Used for function calls that
 /// do not have a prototype. Arguments that have type float or __fp16
 /// are promoted to double. All other argument types are converted by
@@ -804,12 +924,15 @@ ExprResult Sema::DefaultArgumentPromotion(Expr *E) {
     return ExprError();
   E = Res.get();
 
-  // If this is a 'float' or '__fp16' (CVR qualified or typedef) promote to
-  // double.
-  const BuiltinType *BTy = Ty->getAs<BuiltinType>();
-  if (BTy && (BTy->getKind() == BuiltinType::Half ||
-              BTy->getKind() == BuiltinType::Float))
-    E = ImpCastExprToType(E, Context.DoubleTy, CK_FloatingCast).get();
+  if (!getLangOpts().OpenCL || ((getLangOpts().OpenCLVersion >= 120) ||
+                                getOpenCLOptions().cl_khr_fp64)) {
+    // If this is a 'float' or '__fp16' (CVR qualified or typedef) promote to
+    // double.
+    const BuiltinType *BTy = Ty->getAs<BuiltinType>();
+    if (BTy && (BTy->getKind() == BuiltinType::Half ||
+      BTy->getKind() == BuiltinType::Float))
+      E = ImpCastExprToType(E, Context.DoubleTy, CK_FloatingCast).get();
+  }
 
   // C++ performs lvalue-to-rvalue conversion as a default argument
   // promotion, even on class types, but note:
@@ -3297,7 +3420,9 @@ ExprResult Sema::ActOnNumericConstant(const Token &Tok, Scope *UDLScope) {
 
   if (Literal.isFloatingLiteral()) {
     QualType Ty;
-    if (Literal.isFloat)
+    if (Literal.isHalf)
+      Ty = Context.HalfTy;
+    else if (Literal.isFloat)
       Ty = Context.FloatTy;
     else if (!Literal.isLong)
       Ty = Context.DoubleTy;
@@ -4263,6 +4388,7 @@ Sema::CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,
                                       Expr *Idx, SourceLocation RLoc) {
   Expr *LHSExp = Base;
   Expr *RHSExp = Idx;
+  bool LHSIsPointerType = false;
 
   // Perform default conversions.
   if (!LHSExp->getType()->getAs<VectorType>()) {
@@ -4294,6 +4420,7 @@ Sema::CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,
     BaseExpr = LHSExp;
     IndexExpr = RHSExp;
     ResultType = PTy->getPointeeType();
+    LHSIsPointerType = true;
   } else if (const ObjCObjectPointerType *PTy =
                LHSTy->getAs<ObjCObjectPointerType>()) {
     BaseExpr = LHSExp;
@@ -4394,6 +4521,13 @@ Sema::CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,
                           diag::err_subscript_incomplete_type, BaseExpr))
     return ExprError();
 
+  if (getLangOpts().OpenCL && ResultType->isHalfType() && !LHSIsPointerType &&
+      !getOpenCLOptions().cl_khr_fp16) {
+    Diag(BaseExpr->getLocStart(), diag::err_opencl_subscript) << ResultType <<
+    BaseExpr->getType() << BaseExpr->getSourceRange();
+    return ExprError();
+  }
+
   assert(VK == VK_RValue || LangOpts.CPlusPlus ||
          !ResultType.isCForbiddenLValueType());
 
@@ -4866,6 +5000,9 @@ static bool isPlaceholderToRemoveAsArg(QualType type) {
 
   switch (placeholder->getKind()) {
   // Ignore all the non-placeholder types.
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
 #define PLACEHOLDER_TYPE(ID, SINGLETON_ID)
 #define BUILTIN_TYPE(ID, SINGLETON_ID) case BuiltinType::ID:
 #include "clang/AST/BuiltinTypes.def"
@@ -5264,7 +5401,7 @@ Sema::BuildResolvedCallExpr(Expr *Fn, NamedDecl *NDecl,
   if (getLangOpts().CUDA) {
     if (Config) {
       // CUDA: Kernel calls must be to global functions
-      if (FDecl && !FDecl->hasAttr<CUDAGlobalAttr>())
+      if (FDecl && !FDecl->hasAttr<ComputeKernelAttr>())
         return ExprError(Diag(LParenLoc,diag::err_kern_call_not_global_function)
             << FDecl->getName() << Fn->getSourceRange());
 
@@ -5274,12 +5411,17 @@ Sema::BuildResolvedCallExpr(Expr *Fn, NamedDecl *NDecl,
             << Fn->getType() << Fn->getSourceRange());
     } else {
       // CUDA: Calls to global functions must be configured
-      if (FDecl && FDecl->hasAttr<CUDAGlobalAttr>())
+      if (FDecl && FDecl->hasAttr<ComputeKernelAttr>())
         return ExprError(Diag(LParenLoc, diag::err_global_call_not_config)
             << FDecl->getName() << Fn->getSourceRange());
     }
   }
 
+  if (LangOpts.OpenCL && LangOpts.OpenCLVersion >= 200)
+    if (FDecl && FDecl->getName() == "enqueue_kernel")
+      if(CheckEnqueueKernel(TheCall, Args, *this))
+        return ExprError();
+
   // Check for a valid return type
   if (CheckCallReturnType(FuncT->getReturnType(), Fn->getLocStart(), TheCall,
                           FDecl))
@@ -6131,9 +6273,25 @@ static QualType checkConditionalPointerCompatibility(Sema &S, ExprResult &LHS,
     // In this situation, we assume void* type. No especially good
     // reason, but this is what gcc does, and we do have to pick
     // to get a consistent AST.
-    QualType incompatTy = S.Context.getPointerType(S.Context.VoidTy);
-    LHS = S.ImpCastExprToType(LHS.get(), incompatTy, CK_BitCast);
-    RHS = S.ImpCastExprToType(RHS.get(), incompatTy, CK_BitCast);
+    QualType incompatTy;
+    if (S.getLangOpts().OpenCL && S.LangOpts.OpenCLVersion >= 200) {
+      incompatTy = S.Context.getPointerType(S.Context.getAddrSpaceQualType(
+          S.Context.VoidTy, LangAS::opencl_generic));
+      LHS = S.ImpCastExprToType(
+          LHS.get(), incompatTy,
+          (lhQual.getAddressSpace() != LangAS::opencl_generic)
+              ? CK_AddressSpaceConversion
+              : CK_BitCast);
+      RHS = S.ImpCastExprToType(
+          RHS.get(), incompatTy,
+          (rhQual.getAddressSpace() != LangAS::opencl_generic)
+              ? CK_AddressSpaceConversion
+              : CK_BitCast);
+    } else {
+      incompatTy = S.Context.getPointerType(S.Context.VoidTy);
+      LHS = S.ImpCastExprToType(LHS.get(), incompatTy, CK_BitCast);
+      RHS = S.ImpCastExprToType(RHS.get(), incompatTy, CK_BitCast);
+    }
     return incompatTy;
   }
 
@@ -6233,6 +6391,18 @@ static bool checkPointerIntegerMismatch(Sema &S, ExprResult &Int,
   return true;
 }
 
+static bool checkBlockType(Sema &S, const Expr *E) {
+  if (const CallExpr *CE = dyn_cast<CallExpr>(E)) {
+    QualType Ty = CE->getCallee()->getType();
+    if (Ty->isBlockPointerType()) {
+      S.Diag(E->getExprLoc(), diag::err_ternary_with_block);
+      return false;
+    }
+  }
+
+  return false;
+}
+
 /// \brief Simple conversion between integer and floating point types.
 ///
 /// Used when handling the OpenCL conditional operator where the
@@ -6462,6 +6632,12 @@ QualType Sema::CheckConditionalOperands(ExprResult &Cond, ExprResult &LHS,
   QualType LHSTy = LHS.get()->getType();
   QualType RHSTy = RHS.get()->getType();
 
+  // OpenCL 6.12.5 forbids blocks from being part of ternary expressions.
+  if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200) {
+    if (checkBlockType(*this, LHS.get()) || checkBlockType(*this, RHS.get()))
+      return QualType();
+  }
+
   // If both operands have arithmetic type, do the usual arithmetic conversions
   // to find a common type: C99 6.5.15p3,5.
   if (LHSTy->isArithmeticType() && RHSTy->isArithmeticType()) {
@@ -7353,6 +7529,11 @@ Sema::CheckAssignmentConstraints(QualType LHSType, ExprResult &RHS,
     }
   }
 
+  if (LHSType->isSamplerT() && RHSType->isIntegerType()) {
+    Kind = CK_IntToOCLSampler;
+    return Compatible;
+  }
+
   return Incompatible;
 }
 
@@ -7575,7 +7756,8 @@ QualType Sema::InvalidOperands(SourceLocation Loc, ExprResult &LHS,
 static bool tryVectorConvertAndSplat(Sema &S, ExprResult *scalar,
                                      QualType scalarTy,
                                      QualType vectorEltTy,
-                                     QualType vectorTy) {
+                                     QualType vectorTy,
+                                     SourceLocation Loc) {
   // The conversion to apply to the scalar before splatting it,
   // if necessary.
   CastKind scalarCast = CK_Invalid;
@@ -7590,8 +7772,14 @@ static bool tryVectorConvertAndSplat(Sema &S, ExprResult *scalar,
   } else if (vectorEltTy->isRealFloatingType()) {
     if (scalarTy->isRealFloatingType()) {
       if (S.getLangOpts().OpenCL &&
-          S.Context.getFloatingTypeOrder(vectorEltTy, scalarTy) < 0)
-        return true;
+          S.Context.getFloatingTypeOrder(vectorEltTy, scalarTy) < 0) {
+          // OpenCL V2.0 6.2.6.p2:
+          // An error shall occur if any scalar operand type has greater rank
+          // than the type of the vector element.
+          S.Diag(Loc, diag::err_scalar_type_rank_greater_than_vector_type)
+            << scalarTy << vectorTy;
+          return true;
+      }
       scalarCast = CK_FloatingCast;
     }
     else if (scalarTy->isIntegralType(S.Context))
@@ -7683,13 +7871,13 @@ QualType Sema::CheckVectorOperands(ExprResult &LHS, ExprResult &RHS,
   // the vector element type and splat.
   if (!RHSVecType && isa<ExtVectorType>(LHSVecType)) {
     if (!tryVectorConvertAndSplat(*this, &RHS, RHSType,
-                                  LHSVecType->getElementType(), LHSType))
+                                  LHSVecType->getElementType(), LHSType, Loc))
       return LHSType;
   }
   if (!LHSVecType && isa<ExtVectorType>(RHSVecType)) {
     if (!tryVectorConvertAndSplat(*this, (IsCompAssign ? nullptr : &LHS),
                                   LHSType, RHSVecType->getElementType(),
-                                  RHSType))
+                                  RHSType, Loc))
       return RHSType;
   }
 
@@ -9174,6 +9362,18 @@ QualType Sema::CheckCompareOperands(ExprResult &LHS, ExprResult &RHS,
     return ResultTy;
   }
 
+  if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200) {
+    if (LHSIsNull && RHSType->isQueueT()) {
+      LHS = ImpCastExprToType(LHS.get(), RHSType, CK_NullToPointer);
+      return ResultTy;
+    }
+
+    if (LHSType->isQueueT() && RHSIsNull) {
+      RHS = ImpCastExprToType(RHS.get(), LHSType, CK_NullToPointer);
+      return ResultTy;
+    }
+  }
+
   return InvalidOperands(Loc, LHS, RHS);
 }
 
@@ -10041,7 +10241,7 @@ QualType Sema::CheckAddressOfOperand(ExprResult &OrigOp, SourceLocation OpLoc) {
   Expr *op = OrigOp.get()->IgnoreParens();
 
   // OpenCL v1.0 s6.8.a.3: Pointers to functions are not allowed.
-  if (LangOpts.OpenCL && op->getType()->isFunctionType()) {
+  if (LangOpts.OpenCL && !LangOpts.CPlusPlus && op->getType()->isFunctionType()) {
     Diag(op->getExprLoc(), diag::err_opencl_taking_function_address);
     return QualType();
   }
@@ -10199,6 +10399,15 @@ QualType Sema::CheckAddressOfOperand(ExprResult &OrigOp, SourceLocation OpLoc) {
   // If the operand has type "type", the result has type "pointer to type".
   if (op->getType()->isObjCObjectType())
     return Context.getObjCObjectPointerType(op->getType());
+
+  if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200) {
+    const QualType Ty = OrigOp.get()->getType();
+    if (Ty->isBlockPointerType()) {
+      Diag(OpLoc, diag::err_typecheck_unary_expr) << Ty << op->getSourceRange();
+      return QualType();
+    }
+  }
+
   return Context.getPointerType(op->getType());
 }
 
@@ -10239,8 +10448,18 @@ static QualType CheckIndirectionOperand(Sema &S, Expr *Op, ExprValueKind &VK,
                                      Op->getSourceRange());
   }
 
-  if (const PointerType *PT = OpTy->getAs<PointerType>())
+  if (const PointerType *PT = OpTy->getAs<PointerType>()) {
     Result = PT->getPointeeType();
+    // OpenCL v1.2 s6.1.1.1 p2:
+    // The half data type can only be used to declare a pointer to a buffer that
+    // contains half values
+    if (S.getLangOpts().OpenCL && S.getLangOpts().OpenCLVersion >= 200 &&
+        Result->isBlockPointerType()) {
+      S.Diag(OpLoc, diag::err_opencl_dereferencing) << OpTy
+                                                    << Op->getSourceRange();
+      return QualType();
+    }
+  }
   else if (const ObjCObjectPointerType *OPT =
              OpTy->getAs<ObjCObjectPointerType>())
     Result = OPT->getPointeeType();
@@ -10453,6 +10672,22 @@ ExprResult Sema::CreateBuiltinBinOp(SourceLocation OpLoc,
     RHSExpr = Init.get();
   }
 
+  if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200) {
+    QualType LHSTy = LHSExpr->getType(), RHSTy = RHSExpr->getType();
+    // OpenCL 2.0 Section 6.13.11.1 allows atomic varibles to be initialized by
+    // the ATOMIC_VAR_INIT macro.
+    if (LHSTy->isAtomicType() || RHSTy->isAtomicType()) {
+      SourceRange SR(LHSExpr->getLocStart(), RHSExpr->getLocEnd());
+      if (BO_Assign == Opc)
+        Diag(OpLoc, diag::err_atomic_init_constant) << SR;
+      else {
+        Diag(OpLoc, diag::err_typecheck_invalid_operands) << LHSTy.getAsString()
+        << RHSTy.getAsString() << SR;
+      }
+      return ExprError();
+    }
+  }
+
   ExprResult LHS = LHSExpr, RHS = RHSExpr;
   QualType ResultTy;     // Result type of the binary operator.
   // The following two variables are used for compound assignment operators
@@ -10954,6 +11189,18 @@ ExprResult Sema::BuildBinOp(Scope *S, SourceLocation OpLoc,
 ExprResult Sema::CreateBuiltinUnaryOp(SourceLocation OpLoc,
                                       UnaryOperatorKind Opc,
                                       Expr *InputExpr) {
+
+  if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200) {
+    QualType Ty = InputExpr->getType();
+
+    // The only legal unary operation for atomics is '&'.
+    if (Opc != UO_AddrOf && Ty->isAtomicType()) {
+        Diag(OpLoc, diag::err_typecheck_unary_expr) << Ty.getAsString() <<
+        InputExpr->getSourceRange();
+        return ExprError();
+    }
+  }
+
   ExprResult Input = InputExpr;
   ExprValueKind VK = VK_RValue;
   ExprObjectKind OK = OK_Ordinary;
@@ -12925,13 +13172,16 @@ static bool captureInBlock(BlockScopeInfo *BSI, VarDecl *Var,
   bool ByRef = false;
       
   // Blocks are not allowed to capture arrays.
-  if (CaptureType->isArrayType()) {
-    if (BuildAndDiagnose) {
-      S.Diag(Loc, diag::err_ref_array_type);
-      S.Diag(Var->getLocation(), diag::note_previous_decl) 
-      << Var->getDeclName();
+  // Only if it's not OpenCL 2.0.
+  if (!(S.getLangOpts().OpenCL && S.getLangOpts().OpenCLVersion >= 200)) {
+    if (CaptureType->isArrayType()) {
+      if (BuildAndDiagnose) {
+        S.Diag(Loc, diag::err_ref_array_type);
+        S.Diag(Var->getLocation(), diag::note_previous_decl)
+          << Var->getDeclName();
+      }
+      return false;
     }
-    return false;
   }
 
   // Forbid the block-capture of autoreleasing variables.
@@ -12945,7 +13195,11 @@ static bool captureInBlock(BlockScopeInfo *BSI, VarDecl *Var,
     return false;
   }
   const bool HasBlocksAttr = Var->hasAttr<BlocksAttr>();
-  if (HasBlocksAttr || CaptureType->isReferenceType()) {
+  if (HasBlocksAttr || CaptureType->isReferenceType() ||
+        // This is a unique behavior for OpenCL 2.0, since array capturing is
+        // allowed.
+          (S.getLangOpts().OpenCL && S.getLangOpts().OpenCLVersion >= 200 &&
+           CaptureType->isArrayType())) {
     // Block capture by reference does not change the capture or
     // declaration reference types.
     ByRef = true;
@@ -14627,6 +14881,9 @@ ExprResult Sema::CheckPlaceholderExpr(Expr *E) {
     return ExprError();
 
   // Everything else should be impossible.
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
 #define BUILTIN_TYPE(Id, SingletonId) \
   case BuiltinType::Id:
 #define PLACEHOLDER_TYPE(Id, SingletonId)
diff --git a/lib/Sema/SemaExprCXX.cpp b/lib/Sema/SemaExprCXX.cpp
index 38fbea1..43d7bdb 100644
--- a/lib/Sema/SemaExprCXX.cpp
+++ b/lib/Sema/SemaExprCXX.cpp
@@ -3438,6 +3438,18 @@ Sema::PerformImplicitConversion(Expr *From, QualType ToType,
                              From->getValueKind()).get();
     break;
 
+  case ICK_Zero_Queue_Conversion:
+    From = ImpCastExprToType(From, ToType,
+                             CK_ZeroToOCLQueue,
+                             From->getValueKind()).get();
+    break;
+
+  case ICK_Int_Sampler_Conversion:
+    From = ImpCastExprToType(From, ToType,
+                             CK_IntToOCLSampler,
+                             From->getValueKind()).get();
+    break;
+
   case ICK_Lvalue_To_Rvalue:
   case ICK_Array_To_Pointer:
   case ICK_Function_To_Pointer:
diff --git a/lib/Sema/SemaExprMember.cpp b/lib/Sema/SemaExprMember.cpp
index 9c345f8..21835b2 100644
--- a/lib/Sema/SemaExprMember.cpp
+++ b/lib/Sema/SemaExprMember.cpp
@@ -337,6 +337,7 @@ CheckExtVectorComponent(Sema &S, QualType baseType, ExprValueKind &VK,
     if (HexSwizzle)
       compStr++;
 
+    // TODO: add SPIR pass to scalarize all non-{1,2,3,4,8,16} vector uses
     while (*compStr) {
       if (!vecType->isAccessorWithinNumElements(*compStr++)) {
         S.Diag(OpLoc, diag::err_ext_vector_component_exceeds_length)
@@ -1716,7 +1717,8 @@ BuildFieldReferenceExpr(Sema &S, Expr *BaseExpr, bool IsArrow,
     Qualifiers MemberQuals
     = S.Context.getCanonicalType(MemberType).getQualifiers();
 
-    assert(!MemberQuals.hasAddressSpace());
+    // this should very well be possible
+    //assert(!MemberQuals.hasAddressSpace());
 
 
     Qualifiers Combined = BaseQuals + MemberQuals;
diff --git a/lib/Sema/SemaInit.cpp b/lib/Sema/SemaInit.cpp
index c3a8946..eda3f5c 100644
--- a/lib/Sema/SemaInit.cpp
+++ b/lib/Sema/SemaInit.cpp
@@ -1108,7 +1108,8 @@ void InitListChecker::CheckSubElementType(const InitializedEntity &Entity,
     }
 
     // Fall through for subaggregate initialization
-  } else if (ElemType->isScalarType() || ElemType->isAtomicType()) {
+  } else if (ElemType->isScalarType() || ElemType->isAtomicType() ||
+             (SemaRef.getLangOpts().OpenCLVersion >= 200 && ElemType->isExecType())) {
     // FIXME: Need to handle atomic aggregate types with implicit init lists.
     return CheckScalarType(Entity, IList, ElemType, Index,
                            StructuredList, StructuredIndex);
@@ -1166,7 +1167,7 @@ void InitListChecker::CheckSubElementType(const InitializedEntity &Entity,
   //   subaggregate, brace elision is assumed and the initializer is
   //   considered for the initialization of the first member of
   //   the subaggregate.
-  if (!SemaRef.getLangOpts().OpenCL && 
+  if (!SemaRef.getLangOpts().OpenCL &&
       (ElemType->isAggregateType() || ElemType->isVectorType())) {
     CheckImplicitInitList(Entity, IList, ElemType, Index, StructuredList,
                           StructuredIndex);
@@ -2969,6 +2970,7 @@ void InitializationSequence::Step::Destroy() {
   case SK_StdInitializerListConstructorCall:
   case SK_OCLSamplerInit:
   case SK_OCLZeroEvent:
+  case SK_OCLZeroQueue:
     break;
 
   case SK_ConversionSequence:
@@ -3234,6 +3236,13 @@ void InitializationSequence::AddOCLZeroEventStep(QualType T) {
   Steps.push_back(S);
 }
 
+void InitializationSequence::AddOCLZeroQueueStep(QualType T) {
+  Step S;
+  S.Kind = SK_OCLZeroQueue;
+  S.Type = T;
+  Steps.push_back(S);
+}
+
 void InitializationSequence::RewrapReferenceInitList(QualType T,
                                                      InitListExpr *Syntactic) {
   assert(Syntactic->getNumInits() == 1 &&
@@ -4223,6 +4232,7 @@ static void TryReferenceInitializationCore(Sema &S,
   //         where "cv1 T1" is reference-compatible with "cv3 T3",
   //
   // DR1287 removes the "implicitly" here.
+  bool isOpenCLASRef = false;
   if (T2->isRecordType()) {
     if (RefRelationship == Sema::Ref_Incompatible) {
       ConvOvlResult = TryRefInitWithConversionFunction(
@@ -4243,8 +4253,15 @@ static void TryReferenceInitializationCore(Sema &S,
       return;
     }
 
-    Sequence.SetFailed(InitializationSequence::FK_ReferenceInitDropsQualifiers);
-    return;
+    if(S.getLangOpts().OpenCL &&
+       ((cv1T1.getAddressSpace() == 0 && cv2T2.getAddressSpace() != 0) ||
+        (cv1T1.getAddressSpace() != 0 && cv2T2.getAddressSpace() == 0))) {
+      isOpenCLASRef = true;
+    }
+    if(!isOpenCLASRef) {
+      Sequence.SetFailed(InitializationSequence::FK_ReferenceInitDropsQualifiers);
+      return;
+    }
   }
 
   //      - Otherwise, a temporary of type "cv1 T1" is created and initialized
@@ -4767,6 +4784,12 @@ static bool TryOCLSamplerInitialization(Sema &S,
                                         InitializationSequence &Sequence,
                                         QualType DestType,
                                         Expr *Initializer) {
+  // TODO/NOTE: this breaks things, don't do it
+  /*if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Initializer))
+    if (const VarDecl *VD = dyn_cast<VarDecl>(DRE->getDecl()))
+      if (const CastExpr* Init = dyn_cast_or_null<CastExpr>(VD->getInit()))
+        Initializer = const_cast<Expr*>(Init->getSubExpr());*/
+
   if (!S.getLangOpts().OpenCL || !DestType->isSamplerT() ||
     !Initializer->isIntegerConstantExpr(S.getASTContext()))
     return false;
@@ -4796,6 +4819,20 @@ static bool TryOCLZeroEventInitialization(Sema &S,
   return true;
 }
 
+static bool TryOCLZeroQueueInitialization(Sema &S,
+                                          InitializationSequence &Sequence,
+                                          QualType DestType,
+                                          Expr *Initializer) {
+  if (!S.getLangOpts().OpenCL || S.getLangOpts().OpenCLVersion < 200 ||
+      !DestType->isQueueT() ||
+      !Initializer->isIntegerConstantExpr(S.getASTContext()) ||
+      (Initializer->EvaluateKnownConstInt(S.getASTContext()) != 0))
+    return false;
+
+  Sequence.AddOCLZeroQueueStep(DestType);
+  return true;
+}
+
 InitializationSequence::InitializationSequence(Sema &S,
                                                const InitializedEntity &Entity,
                                                const InitializationKind &Kind,
@@ -4983,13 +5020,21 @@ void InitializationSequence::InitializeFrom(Sema &S,
         tryObjCWritebackConversion(S, *this, Entity, Initializer)) {
       return;
     }
+  }
 
+  // need to try these when using C++ with OpenCL
+  if (!S.getLangOpts().CPlusPlus || S.getLangOpts().OpenCL) {
     if (TryOCLSamplerInitialization(S, *this, DestType, Initializer))
       return;
 
     if (TryOCLZeroEventInitialization(S, *this, DestType, Initializer))
       return;
 
+    if (TryOCLZeroQueueInitialization(S, *this, DestType, Initializer))
+      return;
+  }
+
+  if (!S.getLangOpts().CPlusPlus) {
     // Handle initialization in C
     AddCAssignmentStep(DestType);
     MaybeProduceObjCObject(S, *this, Entity);
@@ -6135,6 +6180,20 @@ InitializationSequence::Perform(Sema &S,
       << Init->getSourceRange();
   }
 
+  QualType ETy = Entity.getType();
+  Qualifiers TyQualifiers = ETy.getQualifiers();
+  bool HasGlobalAS = TyQualifiers.hasAddressSpace() &&
+                     TyQualifiers.getAddressSpace() == LangAS::opencl_global;
+
+  if (S.getLangOpts().OpenCL && S.getLangOpts().OpenCLVersion >= 200 &&
+      ETy->isAtomicType() && !HasGlobalAS &&
+      Entity.getKind() == InitializedEntity::EK_Variable && Args.size() > 0) {
+    const Expr *Init = Args[0];
+    S.Diag(Init->getLocStart(), diag::err_atomic_init_addressspace) <<
+    SourceRange(Entity.getDecl()->getLocStart(), Init->getLocEnd());
+    return ExprError();
+  }
+
   // Diagnose cases where we initialize a pointer to an array temporary, and the
   // pointer obviously outlives the temporary.
   if (Args.size() == 1 && Args[0]->getType()->isArrayType() &&
@@ -6189,7 +6248,8 @@ InitializationSequence::Perform(Sema &S,
   case SK_ProduceObjCObject:
   case SK_StdInitializerList:
   case SK_OCLSamplerInit:
-  case SK_OCLZeroEvent: {
+  case SK_OCLZeroEvent:
+  case SK_OCLZeroQueue: {
     assert(Args.size() == 1);
     CurInit = Args[0];
     if (!CurInit.get()) return ExprError();
@@ -6298,7 +6358,10 @@ InitializationSequence::Perform(Sema &S,
 
     case SK_BindReferenceToTemporary: {
       // Make sure the "temporary" is actually an rvalue.
-      assert(CurInit.get()->isRValue() && "not a temporary");
+      // TODO: fix this!
+      //if(CurInit.get()->getType()) {
+      //assert(CurInit.get()->isRValue() && "not a temporary");
+      //}
 
       // Check exception specifications
       if (S.CheckExceptionSpecCompatibility(CurInit.get(), DestType))
@@ -6742,16 +6805,32 @@ InitializationSequence::Perform(Sema &S,
       assert(Step->Type->isSamplerT() && 
              "Sampler initialization on non-sampler type.");
 
-      QualType SourceType = CurInit.get()->getType();
-
-      if (Entity.isParameterKind()) {
-        if (!SourceType->isSamplerT())
-          S.Diag(Kind.getLocation(), diag::err_sampler_argument_required)
+      Expr *Init = CurInit.get();
+      // In case of passing sampler or integer variable to a function
+      // use its initializer
+      if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Init))
+        Init = const_cast<Expr*>(cast<VarDecl>(DRE->getDecl())->getInit());
+      if (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(Init))
+        if (ICE->getCastKind() == CK_IntToOCLSampler)
+          Init = ICE->getSubExpr();
+
+      QualType SourceType = Init->getType();
+      bool isConst = Init->isConstantInitializer(S.Context, false);
+      InitializedEntity::EntityKind EntityKind = Entity.getKind();
+      if (EntityKind == InitializedEntity::EK_Variable ||
+          EntityKind == InitializedEntity::EK_Parameter) {
+        if (!isConst)
+          S.Diag(Kind.getLocation(), diag::err_sampler_initializer_not_constant);
+        if (!SourceType->isIntegerType() ||
+            32 != S.Context.getIntWidth(SourceType))
+          S.Diag(Kind.getLocation(), diag::err_sampler_initializer_not_integer)
             << SourceType;
-      } else if (Entity.getKind() != InitializedEntity::EK_Variable) {
+      } else
         llvm_unreachable("Invalid EntityKind!");
-      }
 
+      CurInit = S.ImpCastExprToType(Init, Step->Type,
+                                    CK_IntToOCLSampler,
+                                    Init->getValueKind());
       break;
     }
     case SK_OCLZeroEvent: {
@@ -6763,6 +6842,15 @@ InitializationSequence::Perform(Sema &S,
                                     CurInit.get()->getValueKind());
       break;
     }
+    case SK_OCLZeroQueue: {
+      assert(Step->Type->isQueueT() &&
+             "Event initialization on non queue type.");
+
+      CurInit = S.ImpCastExprToType(CurInit.get(), Step->Type,
+                                    CK_ZeroToOCLQueue,
+                                    CurInit.get()->getValueKind());
+      break;
+    }
     }
   }
 
@@ -7544,6 +7632,10 @@ void InitializationSequence::dump(raw_ostream &OS) const {
     case SK_OCLZeroEvent:
       OS << "OpenCL event_t from zero";
       break;
+
+    case SK_OCLZeroQueue:
+      OS << "OpenCL queue_t from zero";
+      break;
     }
 
     OS << " [" << S->Type.getAsString() << ']';
diff --git a/lib/Sema/SemaLookup.cpp b/lib/Sema/SemaLookup.cpp
index 45dc2e3..10d034e 100644
--- a/lib/Sema/SemaLookup.cpp
+++ b/lib/Sema/SemaLookup.cpp
@@ -690,6 +690,16 @@ static bool LookupBuiltin(Sema &S, LookupResult &R) {
             S.Context.BuiltinInfo.isPredefinedLibFunction(BuiltinID))
           return false;
 
+        // OpenCL v1.2 s6.9.f:
+        // The library functions defined in the C99 standard headers assert.h,
+        // ctype.h, complex.h, errno.h, fenv.h, float.h, inttypes.h, limits.h,
+        // locale.h, setjmp.h, signal.h, stdarg.h, stdio.h, stdlib.h, string.h,
+        // tgmath.h, time.h, wchar.h and wctype.h are not available and cannot
+        // be included by a program.
+        if (S.getLangOpts().OpenCL &&
+            S.Context.BuiltinInfo.isPredefinedLibFunction(BuiltinID))
+          return false;
+
         if (NamedDecl *D = S.LazilyCreateBuiltin((IdentifierInfo *)II,
                                                  BuiltinID, S.TUScope,
                                                  R.isForRedeclaration(),
diff --git a/lib/Sema/SemaOverload.cpp b/lib/Sema/SemaOverload.cpp
index d6a0ff7..e46218a 100644
--- a/lib/Sema/SemaOverload.cpp
+++ b/lib/Sema/SemaOverload.cpp
@@ -23,6 +23,7 @@
 #include "clang/Basic/DiagnosticOptions.h"
 #include "clang/Basic/PartialDiagnostic.h"
 #include "clang/Basic/TargetInfo.h"
+#include "clang/Lex/Preprocessor.h"
 #include "clang/Sema/Initialization.h"
 #include "clang/Sema/Lookup.h"
 #include "clang/Sema/SemaInternal.h"
@@ -127,14 +128,14 @@ ImplicitConversionRank clang::GetConversionRank(ImplicitConversionKind Kind) {
     ICR_Conversion,
     ICR_Conversion,
     ICR_Conversion,
-    ICR_Conversion,
+    ICR_OCL_Scalar_Widening,
     ICR_Complex_Real_Conversion,
     ICR_Conversion,
     ICR_Conversion,
     ICR_Writeback_Conversion,
-    ICR_Exact_Match, // NOTE(gbiv): This may not be completely right --
-                     // it was omitted by the patch that added
-                     // ICK_Zero_Event_Conversion
+    ICR_Conversion,
+    ICR_Conversion,
+    ICR_Conversion,
     ICR_C_Conversion
   };
   return Rank[(int)Kind];
@@ -168,7 +169,9 @@ static const char* GetImplicitConversionName(ImplicitConversionKind Kind) {
     "Block Pointer conversion",
     "Transparent Union Conversion",
     "Writeback conversion",
-    "OpenCL Zero Event Conversion",
+    "Zero Event conversion",
+    "Zero Queue Conversion",
+    "Integer-to-Sampler conversion",
     "C specific type conversion"
   };
   return Name[Kind];
@@ -1703,6 +1706,15 @@ static bool IsStandardConversion(Sema &S, Expr* From, QualType ToType,
              From->EvaluateKnownConstInt(S.getASTContext()) == 0) {
     SCS.Second = ICK_Zero_Event_Conversion;
     FromType = ToType;
+  } else if (ToType->isQueueT() &&
+             From->isIntegerConstantExpr(S.getASTContext()) &&
+             (From->EvaluateKnownConstInt(S.getASTContext()) == 0)) {
+    SCS.Second = ICK_Zero_Queue_Conversion;
+    FromType = ToType;
+  } else if (ToType->isSamplerT() &&
+             From->isIntegerConstantExpr(S.getASTContext())) {
+    SCS.Second = ICK_Int_Sampler_Conversion;
+    FromType = ToType;
   } else {
     // No second conversion required.
     SCS.Second = ICK_Identity;
@@ -4129,7 +4141,7 @@ Sema::CompareReferenceRelationship(SourceLocation Loc,
     
   if (T1Quals == T2Quals)
     return Ref_Compatible;
-  else if (T1Quals.compatiblyIncludes(T2Quals))
+  else if (T1Quals.compatiblyIncludes(T2Quals, !getASTContext().getLangOpts().OpenCL))
     return Ref_Compatible_With_Added_Qualification;
   else
     return Ref_Related;
@@ -4455,7 +4467,7 @@ TryReferenceInit(Sema &S, Expr *Init, QualType DeclType,
     T1Quals.removeObjCLifetime();
     T2Quals.removeObjCGCAttr();
     T2Quals.removeObjCLifetime();
-    if (!T1Quals.compatiblyIncludes(T2Quals))
+    if (!T1Quals.compatiblyIncludes(T2Quals, !S.getLangOpts().OpenCL))
       return ICS;
   }
 
@@ -5050,6 +5062,8 @@ static bool CheckConvertedConstantConversions(Sema &S,
   case ICK_NoReturn_Adjustment:
   case ICK_Integral_Promotion:
   case ICK_Integral_Conversion: // Narrowing conversions are checked elsewhere.
+  case ICK_Zero_Queue_Conversion:
+  case ICK_Int_Sampler_Conversion:
     return true;
 
   case ICK_Boolean_Conversion:
@@ -5788,6 +5802,41 @@ Sema::AddOverloadCandidate(FunctionDecl *Function,
     return;
   }
 
+  // OpenCL
+  // A candidate function that uses extentions that are not enabled or
+  // supported is not viable.
+  bool hasHalf = getOpenCLOptions().cl_khr_fp16 &&
+                 PP.getSupportedPragmas().cl_khr_fp16;
+  bool hasDouble = PP.getSupportedPragmas().cl_khr_fp64;
+
+  if (getLangOpts().OpenCL) {
+    if (!hasHalf && Function->getReturnType()->isHalfType()) {
+      Candidate.Viable = false;
+      Candidate.FailureKind = ovl_fail_bad_target;
+      return;
+    }
+    if (!hasDouble && Function->getReturnType()->isDoubleType()) {
+      Candidate.Viable = false;
+      Candidate.FailureKind = ovl_fail_bad_target;
+      return;
+    }
+    for (FunctionDecl::param_iterator PI = Function->param_begin(),
+         PE = Function->param_end(); PI != PE; ++PI) {
+      ParmVarDecl *Param = *PI;
+      QualType PT = Param->getType();
+      if (!hasHalf && PT->isHalfType()) {
+        Candidate.Viable = false;
+        Candidate.FailureKind = ovl_fail_bad_target;
+        return;
+      }
+      if (!hasDouble && PT->isDoubleType()) {
+        Candidate.Viable = false;
+        Candidate.FailureKind = ovl_fail_bad_target;
+        return;
+      }
+    }
+  }
+
   // (CUDA B.1): Check for invalid calls between targets.
   if (getLangOpts().CUDA)
     if (const FunctionDecl *Caller = dyn_cast<FunctionDecl>(CurContext))
diff --git a/lib/Sema/SemaTemplateDeduction.cpp b/lib/Sema/SemaTemplateDeduction.cpp
index 71faafc..dfa486b 100644
--- a/lib/Sema/SemaTemplateDeduction.cpp
+++ b/lib/Sema/SemaTemplateDeduction.cpp
@@ -2691,7 +2691,7 @@ CheckOriginalCallArgDeduction(Sema &S, Sema::OriginalCallArg OriginalArg,
 
     if (AQuals == DeducedAQuals) {
       // Qualifiers match; there's nothing to do.
-    } else if (!DeducedAQuals.compatiblyIncludes(AQuals)) {
+    } else if (!DeducedAQuals.compatiblyIncludes(AQuals, !S.getLangOpts().OpenCL)) {
       return true;
     } else {        
       // Qualifiers are compatible, so have the argument type adopt the
diff --git a/lib/Sema/SemaTemplateInstantiateDecl.cpp b/lib/Sema/SemaTemplateInstantiateDecl.cpp
index 7a452af..450d90e 100644
--- a/lib/Sema/SemaTemplateInstantiateDecl.cpp
+++ b/lib/Sema/SemaTemplateInstantiateDecl.cpp
@@ -227,6 +227,30 @@ static void instantiateDependentCUDALaunchBoundsAttr(
                         Attr.getSpellingListIndex());
 }
 
+static void instantiateDependentFloorImageDataTypeAttr(
+    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,
+    const FloorImageDataTypeAttr *A, const Decl *Tmpl, Decl *New) {
+  TypeSourceInfo *Result = S.SubstType(A->getImageDataTypeLoc(), TemplateArgs,
+                                       A->getLocation(), DeclarationName());
+  if (Result) {
+    FloorImageDataTypeAttr *new_attr = new (S.getASTContext())
+        FloorImageDataTypeAttr(A->getLocation(), S.getASTContext(), Result,
+                               A->getSpellingListIndex());
+    New->addAttr(new_attr);
+  }
+}
+
+static void instantiateDependentGraphicsFBOColorLocationAttr(
+    Sema &S, const MultiLevelTemplateArgumentList &TemplateArgs,
+    const GraphicsFBOColorLocationAttr *A, const Decl *Tmpl, Decl *New) {
+  // TODO: check Tmpl with isPotentialConstantExprUnevaluated?
+  EnterExpressionEvaluationContext Unevaluated(S, Sema::ConstantEvaluated);
+  ExprResult Result = S.SubstExpr(A->getColorLocation(), TemplateArgs);
+  if (!Result.isInvalid())
+    S.AddGraphicsFBOColorLocationAttr(A->getLocation(), New, Result.getAs<Expr>(),
+                                      A->getSpellingListIndex());
+}
+
 void Sema::InstantiateAttrs(const MultiLevelTemplateArgumentList &TemplateArgs,
                             const Decl *Tmpl, Decl *New,
                             LateInstantiatedAttrVec *LateAttrs,
@@ -273,6 +297,18 @@ void Sema::InstantiateAttrs(const MultiLevelTemplateArgumentList &TemplateArgs,
       }
     }
 
+    const FloorImageDataTypeAttr *ImgType = dyn_cast<FloorImageDataTypeAttr>(TmplAttr);
+    if (ImgType && ImgType->getImageDataType()->isDependentType()) {
+      instantiateDependentFloorImageDataTypeAttr(*this, TemplateArgs, ImgType, Tmpl, New);
+      continue;
+    }
+
+    const GraphicsFBOColorLocationAttr *ColorLoc = dyn_cast<GraphicsFBOColorLocationAttr>(TmplAttr);
+    if (ColorLoc) {
+      instantiateDependentGraphicsFBOColorLocationAttr(*this, TemplateArgs, ColorLoc, Tmpl, New);
+      continue;
+    }
+
     assert(!TmplAttr->isPackExpansion());
     if (TmplAttr->isLateParsed() && LateAttrs) {
       // Late parsed attributes must be instantiated and attached after the
diff --git a/lib/Sema/SemaTemplateVariadic.cpp b/lib/Sema/SemaTemplateVariadic.cpp
index cb67d71..f03300a 100644
--- a/lib/Sema/SemaTemplateVariadic.cpp
+++ b/lib/Sema/SemaTemplateVariadic.cpp
@@ -740,6 +740,13 @@ bool Sema::containsUnexpandedParameterPacks(Declarator &D) {
   case TST_auto_type:
   case TST_decltype_auto:
   case TST_unknown_anytype:
+#define GENERIC_IMAGE_TYPE(ImgType, Id) case TST_##ImgType##_t:
+#include "clang/Basic/OpenCLImageTypes.def"
+  case TST_sampler_t:
+  case TST_event_t:
+  case TST_queue_t:
+  case TST_clk_event_t:
+  case TST_reserve_id_t:
   case TST_error:
     break;
   }
diff --git a/lib/Sema/SemaType.cpp b/lib/Sema/SemaType.cpp
index f6ad132..30d03c5 100644
--- a/lib/Sema/SemaType.cpp
+++ b/lib/Sema/SemaType.cpp
@@ -20,6 +20,7 @@
 #include "clang/AST/DeclObjC.h"
 #include "clang/AST/DeclTemplate.h"
 #include "clang/AST/Expr.h"
+#include "clang/AST/Type.h"
 #include "clang/AST/TypeLoc.h"
 #include "clang/AST/TypeLocVisitor.h"
 #include "clang/Lex/Preprocessor.h"
@@ -33,6 +34,7 @@
 #include "clang/Sema/Template.h"
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallString.h"
+#include "llvm/ADT/StringSwitch.h"
 #include "llvm/Support/ErrorHandling.h"
 
 using namespace clang;
@@ -282,7 +284,8 @@ enum TypeAttrLocation {
 
 static void processTypeAttrs(TypeProcessingState &state,
                              QualType &type, TypeAttrLocation TAL,
-                             AttributeList *attrs);
+                             AttributeList *attrs, Declarator &D,
+                             unsigned int OpenCLVersion);
 
 static bool handleFunctionTypeAttr(TypeProcessingState &state,
                                    AttributeList &attr,
@@ -1171,6 +1174,21 @@ TypeResult Sema::actOnObjCTypeArgsAndProtocolQualifiers(
   return CreateParsedType(Result, ResultTInfo);
 }
 
+static StringRef getImageAccessAttrStr(AttributeList *attrs) {
+  if (attrs) {
+
+    AttributeList *Next;
+    do {
+      AttributeList &Attr = *attrs;
+      Next = Attr.getNext();
+      if (Attr.getKind() == AttributeList::AT_ImageAccess) {
+        return Attr.getName()->getName();
+      }
+    } while (Next);
+  }
+  return "";
+}
+
 /// \brief Convert the specified declspec to the appropriate type
 /// object.
 /// \param state Specifies the declarator containing the declaration specifier
@@ -1281,6 +1299,9 @@ static QualType ConvertDeclSpecToType(TypeProcessingState &state) {
         S.Diag(DeclLoc, diag::err_missing_actual_pipe_type)
           << DS.getSourceRange();
         declarator.setInvalidType(true);
+      } else if (S.getLangOpts().OpenCL) {
+        S.Diag(DeclLoc, diag::err_opencl_missing_type_specifier)
+          << DS.getSourceRange();
       } else {
         S.Diag(DeclLoc, diag::ext_missing_type_specifier)
           << DS.getSourceRange();
@@ -1422,13 +1443,6 @@ static QualType ConvertDeclSpecToType(TypeProcessingState &state) {
               << Result << "cl_khr_fp64";
           declarator.setInvalidType(true);
         }
-      } else if (!S.getOpenCLOptions().cl_khr_gl_msaa_sharing &&
-                 (Result->isImage2dMSAAT() || Result->isImage2dArrayMSAAT() ||
-                  Result->isImage2dArrayMSAATDepth() ||
-                  Result->isImage2dMSAATDepth())) {
-        S.Diag(DS.getTypeSpecTypeLoc(), diag::err_type_requires_extension)
-            << Result << "cl_khr_gl_msaa_sharing";
-        declarator.setInvalidType(true);
       }
     }
 
@@ -1539,6 +1553,45 @@ static QualType ConvertDeclSpecToType(TypeProcessingState &state) {
     }
     break;
 
+  case DeclSpec::TST_sampler_t:
+    Result = Context.OCLSamplerTy;
+    break;
+
+  case DeclSpec::TST_event_t:
+    Result = Context.OCLEventTy;
+    break;
+  case DeclSpec::TST_queue_t:
+    Result = Context.OCLQueueTy;
+    break;
+  case DeclSpec::TST_clk_event_t:
+    Result = Context.OCLClkEventTy;
+    break;
+  case DeclSpec::TST_reserve_id_t:
+    Result = Context.OCLReserveIDTy;
+    break;
+
+#if 0 // TODO: enable this when using ro/wo/rw image types
+#define GENERIC_IMAGE_TYPE(ImgType, Id) \
+  case DeclSpec::TST_##ImgType##_t: \
+    Result = llvm::StringSwitch<QualType>( \
+                 getImageAccessAttrStr(DS.getAttributes().getList())) \
+                 .Cases("write_only", "__write_only", Context.Id##WOTy) \
+                 .Cases("read_write", "__read_write", Context.Id##RWTy) \
+                 .Default(Context.Id##ROTy); \
+    break;
+#include "clang/Basic/OpenCLImageTypes.def"
+#else
+#define GENERIC_IMAGE_TYPE(ImgType, Id) \
+  case DeclSpec::TST_##ImgType##_t: \
+    Result = llvm::StringSwitch<QualType>( \
+                 getImageAccessAttrStr(DS.getAttributes().getList())) \
+                 .Cases("write_only", "__write_only", Context.Id##Ty) \
+                 .Cases("read_write", "__read_write", Context.Id##Ty) \
+                 .Default(Context.Id##Ty); \
+    break;
+#include "clang/Basic/OpenCLImageTypes.def"
+#endif
+
   case DeclSpec::TST_error:
     Result = Context.IntTy;
     declarator.setInvalidType(true);
@@ -1575,7 +1628,8 @@ static QualType ConvertDeclSpecToType(TypeProcessingState &state) {
   // attributes are pushed around.
   // pipe attributes will be handled later ( at GetFullTypeForDeclarator )
   if (!DS.isTypeSpecPipe())
-      processTypeAttrs(state, Result, TAL_DeclSpec, DS.getAttributes().getList());
+      processTypeAttrs(state, Result, TAL_DeclSpec, DS.getAttributes().getList(),
+                       declarator, S.getLangOpts().OpenCLVersion);
 
   // Apply const/volatile/restrict qualifiers to T.
   if (unsigned TypeQuals = DS.getTypeQualifiers()) {
@@ -1939,7 +1993,9 @@ QualType Sema::BuildReferenceType(QualType T, bool SpelledAsLValue,
 ///
 /// \param T The type to which we'll be building a Pipe.
 ///
-/// \param Loc We do not use it for now.
+/// \param Loc The location of the entity whose type involves this
+/// pointer type or, if there is no such entity, the location of the
+/// type that will have pointer type.
 ///
 /// \returns A suitable pipe type, if there are no errors. Otherwise, returns a
 /// NULL type.
@@ -1968,7 +2024,8 @@ static bool isArraySizeVLA(Sema &S, Expr *ArraySize, llvm::APSInt &SizeVal) {
   } Diagnoser;
 
   return S.VerifyIntegerConstantExpression(ArraySize, &SizeVal, Diagnoser,
-                                           S.LangOpts.GNUMode).isInvalid();
+                                           S.LangOpts.GNUMode ||
+                                           S.LangOpts.OpenCL).isInvalid();
 }
 
 
@@ -2176,6 +2233,13 @@ QualType Sema::BuildArrayType(QualType T, ArrayType::ArraySizeModifier ASM,
     Diag(Loc, diag::warn_vla_used);
   }
 
+  QualType ElemTy = Context.getBaseElementType(T);
+  if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion >= 200 &&
+      ElemTy->isBlockPointerType()) {
+    Diag(Loc, diag::err_invalid_block_array);
+    return QualType();
+  }
+
   return T;
 }
 
@@ -2231,7 +2295,7 @@ bool Sema::CheckFunctionReturnType(QualType T, SourceLocation Loc) {
   }
 
   // Functions cannot return half FP.
-  if (T->isHalfType() && !getLangOpts().HalfArgsAndReturns) {
+  if (T->isHalfType() && !getLangOpts().HalfArgsAndReturns && !LangOpts.OpenCL && !LangOpts.CUDA) {
     Diag(Loc, diag::err_parameters_retval_cannot_have_fp16_type) << 1 <<
       FixItHint::CreateInsertion(Loc, "*");
     return true;
@@ -2261,7 +2325,7 @@ QualType Sema::BuildFunctionType(QualType T,
     if (ParamType->isVoidType()) {
       Diag(Loc, diag::err_param_with_void_type);
       Invalid = true;
-    } else if (ParamType->isHalfType() && !getLangOpts().HalfArgsAndReturns) {
+    } else if (ParamType->isHalfType() && !getLangOpts().HalfArgsAndReturns && !LangOpts.OpenCL && !LangOpts.CUDA) {
       // Disallow half FP arguments.
       Diag(Loc, diag::err_parameters_retval_cannot_have_fp16_type) << 0 <<
         FixItHint::CreateInsertion(Loc, "*");
@@ -2621,7 +2685,8 @@ static QualType GetDeclSpecTypeForDeclarator(TypeProcessingState &state,
     // "void" instead.
     T = SemaRef.Context.VoidTy;
     processTypeAttrs(state, T, TAL_DeclSpec,
-                     D.getDeclSpec().getAttributes().getList());
+                     D.getDeclSpec().getAttributes().getList(),
+                     D, SemaRef.getLangOpts().OpenCLVersion);
     break;
 
   case UnqualifiedId::IK_ConversionFunctionId:
@@ -2979,14 +3044,14 @@ getCCForDeclaratorChunk(Sema &S, Declarator &D,
   CallingConv CC = S.Context.getDefaultCallingConvention(FTI.isVariadic,
                                                          IsCXXInstanceMethod);
 
-  // Attribute AT_OpenCLKernel affects the calling convention only on
+  // Attribute AT_ComputeKernel affects the calling convention only on
   // the SPIR target, hence it cannot be treated as a calling
   // convention attribute. This is the simplest place to infer
   // "spir_kernel" for OpenCL kernels on SPIR.
   if (CC == CC_SpirFunction) {
     for (const AttributeList *Attr = D.getDeclSpec().getAttributes().getList();
          Attr; Attr = Attr->getNext()) {
-      if (Attr->getKind() == AttributeList::AT_OpenCLKernel) {
+      if (Attr->getKind() == AttributeList::AT_ComputeKernel) {
         CC = CC_SpirKernel;
         break;
       }
@@ -3811,7 +3876,7 @@ static TypeSourceInfo *GetFullTypeForDeclarator(TypeProcessingState &state,
             S.Diag(D.getIdentifierLoc(), diag::err_opencl_half_return) << T;
             D.setInvalidType(true);
           } 
-        } else if (!S.getLangOpts().HalfArgsAndReturns) {
+        } else if (!S.getLangOpts().HalfArgsAndReturns && !S.getLangOpts().CUDA) {
           S.Diag(D.getIdentifierLoc(),
             diag::err_parameters_retval_cannot_have_fp16_type) << 1;
           D.setInvalidType(true);
@@ -3921,7 +3986,7 @@ static TypeSourceInfo *GetFullTypeForDeclarator(TypeProcessingState &state,
 
       FunctionType::ExtInfo EI(getCCForDeclaratorChunk(S, D, FTI, chunkIndex));
 
-      if (!FTI.NumParams && !FTI.isVariadic && !LangOpts.CPlusPlus) {
+      if (!FTI.NumParams && !FTI.isVariadic && !LangOpts.CPlusPlus  && !LangOpts.OpenCL) {
         // Simple void foo(), where the incoming T is the result type.
         T = Context.getFunctionNoProtoType(T, EI);
       } else {
@@ -4010,7 +4075,7 @@ static TypeSourceInfo *GetFullTypeForDeclarator(TypeProcessingState &state,
                 D.setInvalidType();
                 Param->setInvalidDecl();
               }
-            } else if (!S.getLangOpts().HalfArgsAndReturns) {
+            } else if (!S.getLangOpts().HalfArgsAndReturns || S.getLangOpts().CUDA) {
               S.Diag(Param->getLocation(),
                 diag::err_parameters_retval_cannot_have_fp16_type) << 0;
               D.setInvalidType();
@@ -4132,7 +4197,7 @@ static TypeSourceInfo *GetFullTypeForDeclarator(TypeProcessingState &state,
     }
 
     case DeclaratorChunk::Pipe: {
-      T = S.BuildPipeType(T, DeclType.Loc );
+      T = S.BuildPipeType(T, DeclType.Loc);
       break;
     }
     }
@@ -4144,7 +4209,8 @@ static TypeSourceInfo *GetFullTypeForDeclarator(TypeProcessingState &state,
 
     // See if there are any attributes on this declarator chunk.
     processTypeAttrs(state, T, TAL_DeclChunk,
-                     const_cast<AttributeList *>(DeclType.getAttrs()));
+                     const_cast<AttributeList *>(DeclType.getAttrs()),
+                     D, S.getLangOpts().OpenCLVersion);
   }
 
   assert(!T.isNull() && "T must not be null after this point");
@@ -4237,7 +4303,8 @@ static TypeSourceInfo *GetFullTypeForDeclarator(TypeProcessingState &state,
   }
 
   // Apply any undistributed attributes from the declarator.
-  processTypeAttrs(state, T, TAL_DeclName, D.getAttributes());
+  processTypeAttrs(state, T, TAL_DeclName, D.getAttributes(),
+                   D, S.getLangOpts().OpenCLVersion);
 
   // Diagnose any ignored type attributes.
   state.diagnoseIgnoredTypeAttrs(T);
@@ -5065,16 +5132,16 @@ static void HandleAddressSpaceTypeAttribute(QualType &Type,
   } else {
     // The keyword-based type attributes imply which address space to use.
     switch (Attr.getKind()) {
-    case AttributeList::AT_OpenCLGlobalAddressSpace:
+    case AttributeList::AT_GlobalAddressSpace:
       ASIdx = LangAS::opencl_global; break;
-    case AttributeList::AT_OpenCLLocalAddressSpace:
+    case AttributeList::AT_LocalAddressSpace:
       ASIdx = LangAS::opencl_local; break;
-    case AttributeList::AT_OpenCLConstantAddressSpace:
+    case AttributeList::AT_ConstantAddressSpace:
       ASIdx = LangAS::opencl_constant; break;
-    case AttributeList::AT_OpenCLGenericAddressSpace:
+    case AttributeList::AT_GenericAddressSpace:
       ASIdx = LangAS::opencl_generic; break;
     default:
-      assert(Attr.getKind() == AttributeList::AT_OpenCLPrivateAddressSpace);
+      assert(Attr.getKind() == AttributeList::AT_PrivateAddressSpace);
       ASIdx = 0; break;
     }
   }
@@ -6218,7 +6285,8 @@ static void HandleNeonVectorTypeAttr(QualType& CurType,
 }
 
 static void processTypeAttrs(TypeProcessingState &state, QualType &type,
-                             TypeAttrLocation TAL, AttributeList *attrs) {
+                             TypeAttrLocation TAL, AttributeList *attrs,
+                             Declarator &D, unsigned int OpenCLVersion) {
   // Scan through and apply attributes to this type where it makes sense.  Some
   // attributes (such as __address_space__, __vector_size__, etc) apply to the
   // type, but others can be present in the type specifiers even though they
@@ -6279,11 +6347,11 @@ static void processTypeAttrs(TypeProcessingState &state, QualType &type,
       // it it breaks large amounts of Linux software.
       attr.setUsedAsTypeAttr();
       break;
-    case AttributeList::AT_OpenCLPrivateAddressSpace:
-    case AttributeList::AT_OpenCLGlobalAddressSpace:
-    case AttributeList::AT_OpenCLLocalAddressSpace:
-    case AttributeList::AT_OpenCLConstantAddressSpace:
-    case AttributeList::AT_OpenCLGenericAddressSpace:
+    case AttributeList::AT_PrivateAddressSpace:
+    case AttributeList::AT_GlobalAddressSpace:
+    case AttributeList::AT_LocalAddressSpace:
+    case AttributeList::AT_ConstantAddressSpace:
+    case AttributeList::AT_GenericAddressSpace:
     case AttributeList::AT_AddressSpace:
       HandleAddressSpaceTypeAttribute(type, attr, state.getSema());
       attr.setUsedAsTypeAttr();
@@ -6312,11 +6380,32 @@ static void processTypeAttrs(TypeProcessingState &state, QualType &type,
                                VectorType::NeonPolyVector);
       attr.setUsedAsTypeAttr();
       break;
-    case AttributeList::AT_OpenCLImageAccess:
+    case AttributeList::AT_ImageAccess:
       // FIXME: there should be some type checking happening here, I would
       // imagine, but the original handler's checking was entirely superfluous.
       attr.setUsedAsTypeAttr();
       break;
+    case AttributeList::AT_FloorImageDataType:
+      attr.setUsedAsTypeAttr();
+      break;
+    case AttributeList::AT_VectorCompat:
+      attr.setUsedAsTypeAttr();
+      break;
+    case AttributeList::AT_GraphicsFBOColorLocation:
+      attr.setUsedAsTypeAttr();
+      break;
+    case AttributeList::AT_GraphicsFBODepthType:
+      attr.setUsedAsTypeAttr();
+      break;
+    case AttributeList::AT_GraphicsVertexPosition:
+      attr.setUsedAsTypeAttr();
+      break;
+    case AttributeList::AT_GraphicsPointSize:
+      attr.setUsedAsTypeAttr();
+      break;
+    case AttributeList::AT_GraphicsStageInput:
+      attr.setUsedAsTypeAttr();
+      break;
 
     MS_TYPE_ATTRS_CASELIST:
       if (!handleMSPointerTypeQualifierAttr(state, attr, type))
@@ -6393,7 +6482,8 @@ static void processTypeAttrs(TypeProcessingState &state, QualType &type,
   // (...)
   // Pointers that are declared without pointing to a named address space point
   // to the generic address space.
-  if (state.getSema().getLangOpts().OpenCLVersion >= 200 &&
+  // NOTE: disabled due to it being _very_ incompatible to other backends right now
+  /*if (state.getSema().getLangOpts().OpenCLVersion >= 200 &&
       !hasOpenCLAddressSpace && type.getAddressSpace() == 0 &&
       (TAL == TAL_DeclSpec || TAL == TAL_DeclChunk)) {
     Declarator &D = state.getDeclarator();
@@ -6414,7 +6504,7 @@ static void processTypeAttrs(TypeProcessingState &state, QualType &type,
              D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_static)
       type = state.getSema().Context.getAddrSpaceQualType(
           type, LangAS::opencl_global);
-  }
+  }*/
 }
 
 void Sema::completeExprArrayBound(Expr *E) {
diff --git a/lib/Serialization/ASTCommon.cpp b/lib/Serialization/ASTCommon.cpp
index 2b78d74..c22d8fc 100644
--- a/lib/Serialization/ASTCommon.cpp
+++ b/lib/Serialization/ASTCommon.cpp
@@ -127,42 +127,11 @@ serialization::TypeIdxFromBuiltin(const BuiltinType *BT) {
   case BuiltinType::ObjCSel:
     ID = PREDEF_TYPE_OBJC_SEL;
     break;
-  case BuiltinType::OCLImage1d:
-    ID = PREDEF_TYPE_IMAGE1D_ID;
-    break;
-  case BuiltinType::OCLImage1dArray:
-    ID = PREDEF_TYPE_IMAGE1D_ARR_ID;
-    break;
-  case BuiltinType::OCLImage1dBuffer:
-    ID = PREDEF_TYPE_IMAGE1D_BUFF_ID;
-    break;
-  case BuiltinType::OCLImage2d:
-    ID = PREDEF_TYPE_IMAGE2D_ID;
-    break;
-  case BuiltinType::OCLImage2dArray:
-    ID = PREDEF_TYPE_IMAGE2D_ARR_ID;
-    break;
-  case BuiltinType::OCLImage2dDepth:
-    ID = PREDEF_TYPE_IMAGE2D_DEP_ID;
-    break;
-  case BuiltinType::OCLImage2dArrayDepth:
-    ID = PREDEF_TYPE_IMAGE2D_ARR_DEP_ID;
-    break;
-  case BuiltinType::OCLImage2dMSAA:
-    ID = PREDEF_TYPE_IMAGE2D_MSAA_ID;
-    break;
-  case BuiltinType::OCLImage2dArrayMSAA:
-    ID = PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID;
-    break;
-  case BuiltinType::OCLImage2dMSAADepth:
-    ID = PREDEF_TYPE_IMAGE2D_MSAA_DEP_ID;
-    break;
-  case BuiltinType::OCLImage2dArrayMSAADepth:
-    ID = PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID;
-    break;
-  case BuiltinType::OCLImage3d:
-    ID = PREDEF_TYPE_IMAGE3D_ID;
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id: \
+    ID = PREDEF_TYPE_##Id##_ID; \
     break;
+#include "clang/Basic/OpenCLImageTypes.def"
   case BuiltinType::OCLSampler:
     ID = PREDEF_TYPE_SAMPLER_ID;
     break;
diff --git a/lib/Serialization/ASTReader.cpp b/lib/Serialization/ASTReader.cpp
index 833ff57..cfe0fd7 100644
--- a/lib/Serialization/ASTReader.cpp
+++ b/lib/Serialization/ASTReader.cpp
@@ -6046,42 +6046,11 @@ QualType ASTReader::GetType(TypeID ID) {
     case PREDEF_TYPE_OBJC_SEL:
       T = Context.ObjCBuiltinSelTy;
       break;
-    case PREDEF_TYPE_IMAGE1D_ID:
-      T = Context.OCLImage1dTy;
-      break;
-    case PREDEF_TYPE_IMAGE1D_ARR_ID:
-      T = Context.OCLImage1dArrayTy;
-      break;
-    case PREDEF_TYPE_IMAGE1D_BUFF_ID:
-      T = Context.OCLImage1dBufferTy;
-      break;
-    case PREDEF_TYPE_IMAGE2D_ID:
-      T = Context.OCLImage2dTy;
-      break;
-    case PREDEF_TYPE_IMAGE2D_ARR_ID:
-      T = Context.OCLImage2dArrayTy;
-      break;
-    case PREDEF_TYPE_IMAGE2D_DEP_ID:
-      T = Context.OCLImage2dDepthTy;
-      break;
-    case PREDEF_TYPE_IMAGE2D_ARR_DEP_ID:
-      T = Context.OCLImage2dArrayDepthTy;
-      break;
-    case PREDEF_TYPE_IMAGE2D_MSAA_ID:
-      T = Context.OCLImage2dMSAATy;
-      break;
-    case PREDEF_TYPE_IMAGE2D_ARR_MSAA_ID:
-      T = Context.OCLImage2dArrayMSAATy;
-      break;
-    case PREDEF_TYPE_IMAGE2D_MSAA_DEP_ID:
-      T = Context.OCLImage2dMSAADepthTy;
-      break;
-    case PREDEF_TYPE_IMAGE2D_ARR_MSAA_DEPTH_ID:
-      T = Context.OCLImage2dArrayMSAADepthTy;
-      break;
-    case PREDEF_TYPE_IMAGE3D_ID:
-      T = Context.OCLImage3dTy;
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+    case PREDEF_TYPE_##Id##_ID: \
+      T = Context.SingletonId; \
       break;
+#include "clang/Basic/OpenCLImageTypes.def"
     case PREDEF_TYPE_SAMPLER_ID:
       T = Context.OCLSamplerTy;
       break;
diff --git a/lib/StaticAnalyzer/Core/ExprEngineC.cpp b/lib/StaticAnalyzer/Core/ExprEngineC.cpp
index 175225b..367c242 100644
--- a/lib/StaticAnalyzer/Core/ExprEngineC.cpp
+++ b/lib/StaticAnalyzer/Core/ExprEngineC.cpp
@@ -341,6 +341,8 @@ void ExprEngine::VisitCast(const CastExpr *CastE, const Expr *Ex,
       case CK_AnyPointerToBlockPointerCast:
       case CK_ObjCObjectLValueCast:
       case CK_ZeroToOCLEvent:
+      case CK_ZeroToOCLQueue:
+      case CK_IntToOCLSampler:
       case CK_LValueBitCast: {
         // Delegate to SValBuilder to process.
         SVal V = state->getSVal(Ex, LCtx);
diff --git a/tools/driver/Makefile b/tools/driver/Makefile
index 347702e..5a29f62 100644
--- a/tools/driver/Makefile
+++ b/tools/driver/Makefile
@@ -33,7 +33,7 @@ endif
 
 LINK_COMPONENTS := $(TARGETS_TO_BUILD) asmparser bitreader bitwriter codegen \
                    instrumentation ipo irreader linker objcarcopts option \
-                   profiledata selectiondag
+                   profiledata selectiondag spirvlib bitwriter32 bitwriter35
 USEDLIBS = clangFrontendTool.a clangFrontend.a clangDriver.a \
            clangSerialization.a clangCodeGen.a clangParse.a clangSema.a \
            clangRewriteFrontend.a clangRewrite.a
diff --git a/tools/driver/cc1_main.cpp b/tools/driver/cc1_main.cpp
index 8240561..6be005c 100644
--- a/tools/driver/cc1_main.cpp
+++ b/tools/driver/cc1_main.cpp
@@ -73,6 +73,30 @@ int cc1_main(ArrayRef<const char *> Argv, const char *Argv0, void *MainAddr) {
   PCHOps->registerWriter(llvm::make_unique<ObjectFilePCHContainerWriter>());
   PCHOps->registerReader(llvm::make_unique<ObjectFilePCHContainerReader>());
 
+  // Enable OpenCL supported pragmas by default.
+  OpenCLOptions &SP = Clang->getPreprocessorOpts().SupportedPragmas;
+  SP.cl_khr_3d_image_writes = 1;
+  SP.cl_khr_byte_addressable_store = 1;
+  SP.cl_khr_depth_images = 1;
+  SP.cl_khr_d3d10_sharing = 1;
+  SP.cl_khr_fp16 = 1;
+  SP.cl_khr_fp64 = 1;
+  SP.cl_khr_gl_event = 1;
+  SP.cl_khr_gl_msaa_sharing = 1;
+  SP.cl_khr_gl_sharing = 1;
+  SP.cl_khr_int64_base_atomics = 1;
+  SP.cl_khr_int64_extended_atomics = 1;
+  SP.cl_khr_global_int32_base_atomics = 1;
+  SP.cl_khr_global_int32_extended_atomics = 1;
+  SP.cl_khr_local_int32_base_atomics = 1;
+  SP.cl_khr_local_int32_extended_atomics = 1;
+  SP.cl_khr_subgroups = 1;
+  SP.cl_khr_mipmap_image = 1;
+  SP.cl_khr_mipmap_image_writes = 1;
+  SP.cl_intel_subgroups = 1;
+
+  SP.cl_clang_storage_class_specifiers = 1;
+
   // Initialize targets first, so that --version shows registered targets.
   llvm::InitializeAllTargets();
   llvm::InitializeAllTargetMCs();
diff --git a/tools/libclang/CIndex.cpp b/tools/libclang/CIndex.cpp
index 9086c60..dbbb32f 100644
--- a/tools/libclang/CIndex.cpp
+++ b/tools/libclang/CIndex.cpp
@@ -1456,18 +1456,9 @@ bool CursorVisitor::VisitBuiltinTypeLoc(BuiltinTypeLoc TL) {
   case BuiltinType::Void:
   case BuiltinType::NullPtr:
   case BuiltinType::Dependent:
-  case BuiltinType::OCLImage1d:
-  case BuiltinType::OCLImage1dArray:
-  case BuiltinType::OCLImage1dBuffer:
-  case BuiltinType::OCLImage2d:
-  case BuiltinType::OCLImage2dArray:
-  case BuiltinType::OCLImage2dDepth:
-  case BuiltinType::OCLImage2dArrayDepth:
-  case BuiltinType::OCLImage2dMSAA:
-  case BuiltinType::OCLImage2dArrayMSAA:
-  case BuiltinType::OCLImage2dMSAADepth:
-  case BuiltinType::OCLImage2dArrayMSAADepth:
-  case BuiltinType::OCLImage3d:
+#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \
+  case BuiltinType::Id:
+#include "clang/Basic/OpenCLImageTypes.def"
   case BuiltinType::OCLSampler:
   case BuiltinType::OCLEvent:
   case BuiltinType::OCLClkEvent:
@@ -4403,11 +4394,11 @@ CXString clang_getCursorKindSpelling(enum CXCursorKind Kind) {
   case CXCursor_NoDuplicateAttr:
     return cxstring::createRef("attribute(noduplicate)");
   case CXCursor_CUDAConstantAttr:
-    return cxstring::createRef("attribute(constant)");
+    return cxstring::createRef("attribute(constant_cuda)");
   case CXCursor_CUDADeviceAttr:
     return cxstring::createRef("attribute(device)");
-  case CXCursor_CUDAGlobalAttr:
-    return cxstring::createRef("attribute(global)");
+  case CXCursor_ComputeKernelAttr:
+    return cxstring::createRef("attribute(compute_kernel)");
   case CXCursor_CUDAHostAttr:
     return cxstring::createRef("attribute(host)");
   case CXCursor_CUDASharedAttr:
@@ -6782,6 +6773,8 @@ enum CX_StorageClass clang_Cursor_getStorageClass(CXCursor C) {
   }
   switch (sc) {
   case SC_None:
+  case SC_OpenCLConstant: // unsupported in here
+  case SC_OpenCLConstantExtern: // unsupported in here
     return CX_SC_None;
   case SC_Extern:
     return CX_SC_Extern;
diff --git a/tools/libclang/CXCursor.cpp b/tools/libclang/CXCursor.cpp
index c766d2d..b4fed25 100644
--- a/tools/libclang/CXCursor.cpp
+++ b/tools/libclang/CXCursor.cpp
@@ -55,7 +55,7 @@ static CXCursorKind GetCursorKind(const Attr *A) {
     case attr::NoDuplicate: return CXCursor_NoDuplicateAttr;
     case attr::CUDAConstant: return CXCursor_CUDAConstantAttr;
     case attr::CUDADevice: return CXCursor_CUDADeviceAttr;
-    case attr::CUDAGlobal: return CXCursor_CUDAGlobalAttr;
+    case attr::ComputeKernel: return CXCursor_ComputeKernelAttr;
     case attr::CUDAHost: return CXCursor_CUDAHostAttr;
     case attr::CUDAShared: return CXCursor_CUDASharedAttr;
     case attr::Visibility: return CXCursor_VisibilityAttr;
diff --git a/tools/libclang/CXType.cpp b/tools/libclang/CXType.cpp
index 44bb631..63b8ff3 100644
--- a/tools/libclang/CXType.cpp
+++ b/tools/libclang/CXType.cpp
@@ -533,8 +533,8 @@ CXCallingConv clang_getFunctionTypeCallingConv(CXType X) {
       TCALLINGCONV(AAPCS);
       TCALLINGCONV(AAPCS_VFP);
       TCALLINGCONV(IntelOclBicc);
-    case CC_SpirFunction: return CXCallingConv_Unexposed;
-    case CC_SpirKernel: return CXCallingConv_Unexposed;
+      TCALLINGCONV(SpirFunction);
+      TCALLINGCONV(SpirKernel);
       break;
     }
 #undef TCALLINGCONV
diff --git a/tools/libclang/Makefile b/tools/libclang/Makefile
index 84914e0..7f72558 100644
--- a/tools/libclang/Makefile
+++ b/tools/libclang/Makefile
@@ -18,7 +18,7 @@ SHARED_LIBRARY = 1
 include $(CLANG_LEVEL)/../../Makefile.config
 LINK_COMPONENTS := $(TARGETS_TO_BUILD) asmparser bitreader bitwriter core \
                    instrumentation ipo mc mcparser objcarcopts option support \
-                   object
+                   object spirvlib bitwriter32 bitwriter35
 USEDLIBS = clangIndex.a clangARCMigrate.a \
 	   clangRewriteFrontend.a \
 	   clangFormat.a \
diff --git a/unittests/ASTMatchers/ASTMatchersTest.cpp b/unittests/ASTMatchers/ASTMatchersTest.cpp
index cd18df8..3627010 100644
--- a/unittests/ASTMatchers/ASTMatchersTest.cpp
+++ b/unittests/ASTMatchers/ASTMatchersTest.cpp
@@ -724,7 +724,7 @@ TEST(DeclarationMatcher, MatchCudaDecl) {
   EXPECT_TRUE(notMatchesWithCuda("void f() {}",
                                  cudaKernelCallExpr()));
   EXPECT_FALSE(notMatchesWithCuda("__attribute__((global)) void f() {}",
-                                  hasAttr(clang::attr::CUDAGlobal)));
+                                  hasAttr(clang::attr::ComputeKernel)));
 }
 
 // Implements a run method that returns whether BoundNodes contains a
